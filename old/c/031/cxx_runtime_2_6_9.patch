diff -urN linux-2.6.9_orig/arch/i386/Makefile linux-2.6.9/arch/i386/Makefile
--- linux-2.6.9_orig/arch/i386/Makefile	2004-10-26 13:20:14.000000000 +0000
+++ linux-2.6.9/arch/i386/Makefile	2004-10-26 13:39:58.000000000 +0000
@@ -21,9 +21,11 @@
 CHECKFLAGS	+= -D__i386__
 
 CFLAGS += -pipe -msoft-float
+CXXFLAGS += -pipe -msoft-float
 
 # prevent gcc from keeping the stack 16 byte aligned
 CFLAGS += $(call cc-option,-mpreferred-stack-boundary=2)
+CXXFLAGS += $(call check_gcc,-mpreferred-stack-boundary=2,)
 
 align := $(subst -functions=0,,$(call cc-option,-falign-functions=0,-malign-functions=0))
 cflags-$(CONFIG_M386)		+= -march=i386
@@ -59,8 +61,10 @@
 # Disable unit-at-a-time mode, it makes gcc use a lot more stack
 # due to the lack of sharing of stacklots.
 CFLAGS += $(call cc-option,-fno-unit-at-a-time)
+CXXFLAGS += $(call check_gcc,-fno-unit-at-a-time,)
 
 CFLAGS += $(cflags-y)
+CXXFLAGS += $(cflags-y)
 
 # Default subarch .c files
 mcore-y  := mach-default
@@ -112,6 +116,7 @@
 drivers-$(CONFIG_PM)			+= arch/i386/power/
 
 CFLAGS += $(mflags-y)
+CXXFLAGS += $(mflags-y)
 AFLAGS += $(mflags-y)
 
 boot := arch/i386/boot
diff -urN linux-2.6.9_orig/include/asm-i386/elf.h linux-2.6.9/include/asm-i386/elf.h
--- linux-2.6.9_orig/include/asm-i386/elf.h	2004-10-26 13:20:38.000000000 +0000
+++ linux-2.6.9/include/asm-i386/elf.h	2004-10-26 13:26:04.000000000 +0000
@@ -136,7 +136,9 @@
 #define VSYSCALL_BASE	(__fix_to_virt(FIX_VSYSCALL))
 #define VSYSCALL_EHDR	((const struct elfhdr *) VSYSCALL_BASE)
 #define VSYSCALL_ENTRY	((unsigned long) &__kernel_vsyscall)
+#ifndef __cplusplus
 extern void __kernel_vsyscall;
+#endif
 
 #define ARCH_DLINFO						\
 do {								\
diff -urN linux-2.6.9_orig/include/asm-i386/gcc/auto-host.h linux-2.6.9/include/asm-i386/gcc/auto-host.h
--- linux-2.6.9_orig/include/asm-i386/gcc/auto-host.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/asm-i386/gcc/auto-host.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,570 @@
+/* auto-host.h.  Generated by configure.  */
+/* config.in.  Generated from configure.ac by autoheader.  */
+
+/* 1234 = LIL_ENDIAN, 4321 = BIGENDIAN */
+#define BYTEORDER 1234
+
+/* Define as the number of bits in a byte, if \`limits.h' doesn't. */
+/* #undef CHAR_BIT */
+
+/* Define 0/1 to force the choice for exception handling model. */
+/* #undef CONFIG_SJLJ_EXCEPTIONS */
+
+/* Define to enable the use of a default assembler. */
+/* #undef DEFAULT_ASSEMBLER */
+
+/* Define to enable the use of a default linker. */
+/* #undef DEFAULT_LINKER */
+
+/* Define if you want to use __cxa_atexit, rather than atexit, to register C++
+   destructors for local statics and global objects. This is essential for
+   fully standards-compliant handling of destructors, but requires
+   __cxa_atexit in libc. */
+#define DEFAULT_USE_CXA_ATEXIT 1
+
+/* Define if you want more run-time sanity checks. This one gets a grab bag of
+   miscellaneous but relatively cheap checks. */
+/* #undef ENABLE_CHECKING */
+
+/* Define if you want fold checked that it never destructs its argument. This
+   is quite expensive. */
+/* #undef ENABLE_FOLD_CHECKING */
+
+/* Define if you want the garbage collector to operate in maximally paranoid
+   mode, validating the entire heap and collecting garbage at every
+   opportunity. This is extremely expensive. */
+/* #undef ENABLE_GC_ALWAYS_COLLECT */
+
+/* Define if you want the garbage collector to do object poisoning and other
+   memory allocation checks. This is quite expensive. */
+/* #undef ENABLE_GC_CHECKING */
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+#define ENABLE_NLS 1
+
+/* Define if you want all operations on RTL (the basic data structure of the
+   optimizer and back end) to be checked for dynamic type safety at runtime.
+   This is quite expensive. */
+/* #undef ENABLE_RTL_CHECKING */
+
+/* Define if you want RTL flag accesses to be checked against the RTL codes
+   that are supported for each access macro. This is relatively cheap. */
+/* #undef ENABLE_RTL_FLAG_CHECKING */
+
+/* Define if you want all operations on trees (the basic data structure of the
+   front ends) to be checked for dynamic type safety at runtime. This is
+   moderately expensive. */
+/* #undef ENABLE_TREE_CHECKING */
+
+/* Define if you want to run subprograms and generated programs through
+   valgrind (a memory checker). This is extremely expensive. */
+/* #undef ENABLE_VALGRIND_CHECKING */
+
+/* Define to 1 if installation paths should be looked up in Windows32
+   Registry. Ignored on non windows32 hosts. */
+/* #undef ENABLE_WIN32_REGISTRY */
+
+/* Define to the name of a file containing a list of extra machine modes for
+   this architecture. */
+#define EXTRA_MODES_FILE "config/i386/i386-modes.def"
+
+/* Define to enable detailed memory allocation stats gathering. */
+/* #undef GATHER_STATISTICS */
+
+/* Define to the type of elements in the array set by `getgroups'. Usually
+   this is either `int' or `gid_t'. */
+#define GETGROUPS_T gid_t
+
+/* Define to 1 if you have the `alphasort' function. */
+#define HAVE_ALPHASORT 1
+
+/* Define if your assembler supports dwarf2 .file/.loc directives, and
+   preserves file table indices exactly as given. */
+#define HAVE_AS_DWARF2_DEBUG_LINE 1
+
+/* Define if your assembler supports explicit relocations. */
+/* #undef HAVE_AS_EXPLICIT_RELOCS */
+
+/* Define if your assembler supports the --gdwarf2 option. */
+#define HAVE_AS_GDWARF2_DEBUG_FLAG 1
+
+/* Define true if the assembler supports '.long foo@GOTOFF'. */
+#define HAVE_AS_GOTOFF_IN_DATA 1
+
+/* Define if your assembler supports the --gstabs option. */
+#define HAVE_AS_GSTABS_DEBUG_FLAG 1
+
+/* Define if your assembler supports the Sun syntax for cmov. */
+/* #undef HAVE_AS_IX86_CMOV_SUN_SYNTAX */
+
+/* Define if your assembler supports .sleb128 and .uleb128. */
+#define HAVE_AS_LEB128 1
+
+/* Define if your assembler supports ltoffx and ldxmov relocations. */
+/* #undef HAVE_AS_LTOFFX_LDXMOV_RELOCS */
+
+/* Define if your assembler supports mfcr field. */
+/* #undef HAVE_AS_MFCRF */
+
+/* Define if your assembler supports the -no-mul-bug-abort option. */
+/* #undef HAVE_AS_NO_MUL_BUG_ABORT_OPTION */
+
+/* Define if your assembler supports offsetable %lo(). */
+/* #undef HAVE_AS_OFFSETABLE_LO10 */
+
+/* Define if your assembler supports .register. */
+/* #undef HAVE_AS_REGISTER_PSEUDO_OP */
+
+/* Define if your assembler supports -relax option. */
+/* #undef HAVE_AS_RELAX_OPTION */
+
+/* Define if your assembler and linker support unaligned PC relative relocs.
+   */
+/* #undef HAVE_AS_SPARC_UA_PCREL */
+
+/* Define if your assembler and linker support unaligned PC relative relocs
+   against hidden symbols. */
+/* #undef HAVE_AS_SPARC_UA_PCREL_HIDDEN */
+
+/* Define if your assembler supports thread-local storage. */
+#define HAVE_AS_TLS 1
+
+/* Define to 1 if you have the `atoll' function. */
+#define HAVE_ATOLL 1
+
+/* Define to 1 if you have the `atoq' function. */
+/* #undef HAVE_ATOQ */
+
+/* Define to 1 if you have the `clock' function. */
+#define HAVE_CLOCK 1
+
+/* Define if <time.h> defines clock_t. */
+#define HAVE_CLOCK_T 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_ABORT 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_ATOF 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_ATOL 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_BASENAME 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_CALLOC 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_CLOCK 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_ERRNO 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_FPRINTF_UNLOCKED 0
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_FPUTS_UNLOCKED 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_FREE 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_FWRITE_UNLOCKED 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_GETCWD 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_GETENV 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_GETOPT 0
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_GETRLIMIT 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_GETRUSAGE 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_GETWD 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_LDGETNAME 0
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_MALLOC 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_PUTC_UNLOCKED 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_REALLOC 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_SBRK 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_SETRLIMIT 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_SNPRINTF 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_STRSIGNAL 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_STRSTR 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_TIMES 1
+
+/* Define to 1 if we found this declaration otherwise define to 0. */
+#define HAVE_DECL_VASPRINTF 1
+
+/* Define to 1 if you have the <direct.h> header file. */
+/* #undef HAVE_DIRECT_H */
+
+/* Define to 1 if you have the `dup2' function. */
+#define HAVE_DUP2 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the `fork' function. */
+#define HAVE_FORK 1
+
+/* Define to 1 if you have the `fprintf_unlocked' function. */
+/* #undef HAVE_FPRINTF_UNLOCKED */
+
+/* Define to 1 if you have the `fputc_unlocked' function. */
+#define HAVE_FPUTC_UNLOCKED 1
+
+/* Define to 1 if you have the `fputs_unlocked' function. */
+#define HAVE_FPUTS_UNLOCKED 1
+
+/* Define to 1 if you have the `fwrite_unlocked' function. */
+#define HAVE_FWRITE_UNLOCKED 1
+
+/* Define if your assembler supports .balign and .p2align. */
+#define HAVE_GAS_BALIGN_AND_P2ALIGN 1
+
+/* Define if your assembler uses the new HImode fild and fist notation. */
+#define HAVE_GAS_FILDS_FISTS 1
+
+/* Define if your assembler and linker support .hidden. */
+#define HAVE_GAS_HIDDEN 1
+
+/* Define if your assembler supports specifying the maximum number of bytes to
+   skip when using the GAS .p2align command. */
+#define HAVE_GAS_MAX_SKIP_P2ALIGN 1
+
+/* Define 0/1 if your assembler supports marking sections with SHF_MERGE flag.
+   */
+#define HAVE_GAS_SHF_MERGE 1
+
+/* Define if your assembler supports .subsection and .subsection -1 starts
+   emitting at the beginning of your section. */
+#define HAVE_GAS_SUBSECTION_ORDERING 1
+
+/* Define if your assembler supports .weak. */
+#define HAVE_GAS_WEAK 1
+
+/* Define to 1 if you have the `getrlimit' function. */
+#define HAVE_GETRLIMIT 1
+
+/* Define to 1 if you have the `getrusage' function. */
+#define HAVE_GETRUSAGE 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define if you have the iconv() function. */
+#define HAVE_ICONV 1
+
+/* Define to 1 if you have the <iconv.h> header file. */
+#define HAVE_ICONV_H 1
+
+/* Define .init_array/.fini_array sections are available and working. */
+#define HAVE_INITFINI_ARRAY 1
+
+/* Define if you have a working <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `kill' function. */
+#define HAVE_KILL 1
+
+/* Define to 1 if you have the <langinfo.h> header file. */
+#define HAVE_LANGINFO_H 1
+
+/* Define if your <locale.h> file defines LC_MESSAGES. */
+#define HAVE_LC_MESSAGES 1
+
+/* Define to 1 if you have the <ldfcn.h> header file. */
+/* #undef HAVE_LDFCN_H */
+
+/* Define if your linker supports --as-needed and --no-as-needed options. */
+/* #undef HAVE_LD_AS_NEEDED */
+
+/* Define if your linker supports --eh-frame-hdr option. */
+#define HAVE_LD_EH_FRAME_HDR 1
+
+/* Define if your linker supports -pie option. */
+#define HAVE_LD_PIE 1
+
+/* Define if your linker links a mix of read-only and read-write sections into
+   a read-write section. */
+#define HAVE_LD_RO_RW_SECTION_MIXING 1
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if you have the <locale.h> header file. */
+#define HAVE_LOCALE_H 1
+
+/* Define if your compiler supports the \`long long' type. */
+#define HAVE_LONG_LONG 1
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#define HAVE_MALLOC_H 1
+
+/* Define to 1 if you have the `mbstowcs' function. */
+#define HAVE_MBSTOWCS 1
+
+/* Define if valgrind's memcheck.h header is installed. */
+/* #undef HAVE_MEMCHECK_H */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mincore' function. */
+#define HAVE_MINCORE 1
+
+/* Define to 1 if you have the `mmap' function. */
+#define HAVE_MMAP 1
+
+/* Define if mmap with MAP_ANON(YMOUS) works. */
+#define HAVE_MMAP_ANON 1
+
+/* Define if mmap of /dev/zero works. */
+#define HAVE_MMAP_DEV_ZERO 1
+
+/* Define if read-only mmap of a plain file works. */
+#define HAVE_MMAP_FILE 1
+
+/* Define to 1 if you have the `nl_langinfo' function. */
+#define HAVE_NL_LANGINFO 1
+
+/* Define if printf supports "%p". */
+#define HAVE_PRINTF_PTR 1
+
+/* Define to 1 if you have the `putc_unlocked' function. */
+#define HAVE_PUTC_UNLOCKED 1
+
+/* Define to 1 if you have the `scandir' function. */
+#define HAVE_SCANDIR 1
+
+/* Define to 1 if you have the `setlocale' function. */
+#define HAVE_SETLOCALE 1
+
+/* Define to 1 if you have the `setrlimit' function. */
+#define HAVE_SETRLIMIT 1
+
+/* Define if you have a working <stdbool.h> header file. */
+#define HAVE_STDBOOL_H 1
+
+/* Define to 1 if you have the <stddef.h> header file. */
+#define HAVE_STDDEF_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strsignal' function. */
+#define HAVE_STRSIGNAL 1
+
+/* Define if <sys/times.h> defines struct tms. */
+#define HAVE_STRUCT_TMS 1
+
+/* Define to 1 if you have the `sysconf' function. */
+#define HAVE_SYSCONF 1
+
+/* Define to 1 if you have the <sys/file.h> header file. */
+#define HAVE_SYS_FILE_H 1
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+#define HAVE_SYS_MMAN_H 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+#define HAVE_SYS_RESOURCE_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/times.h> header file. */
+#define HAVE_SYS_TIMES_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
+#define HAVE_SYS_WAIT_H 1
+
+/* Define to 1 if you have the `times' function. */
+#define HAVE_TIMES 1
+
+/* Define to 1 if you have the <time.h> header file. */
+#define HAVE_TIME_H 1
+
+/* Define if <sys/types.h> defines \`uchar'. */
+/* #undef HAVE_UCHAR */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define if valgrind's valgrind/memcheck.h header is installed. */
+/* #undef HAVE_VALGRIND_MEMCHECK_H */
+
+/* Define to 1 if you have the `vfork' function. */
+#define HAVE_VFORK 1
+
+/* Define to 1 if you have the <vfork.h> header file. */
+/* #undef HAVE_VFORK_H */
+
+/* Define to 1 if you have the <wchar.h> header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define to 1 if you have the `wcswidth' function. */
+#define HAVE_WCSWIDTH 1
+
+/* Define to 1 if `fork' works. */
+#define HAVE_WORKING_FORK 1
+
+/* Define this macro if mbstowcs does not crash when its first argument is
+   NULL. */
+#define HAVE_WORKING_MBSTOWCS 1
+
+/* Define to 1 if `vfork' works. */
+#define HAVE_WORKING_VFORK 1
+
+/* Define if the \`_Bool' type is built-in. */
+#define HAVE__BOOL 1
+
+/* Define if your compiler supports the \`__int64' type. */
+/* #undef HAVE___INT64 */
+
+/* Define if the host machine stores words of multi-word integers in
+   big-endian order. */
+/* #undef HOST_WORDS_BIG_ENDIAN */
+
+/* Define as const if the declaration of iconv() needs const. */
+#define ICONV_CONST 
+
+/* Define if host mkdir takes a single argument. */
+/* #undef MKDIR_TAKES_ONE_ARG */
+
+/* Define to 1 if HOST_WIDE_INT must be 64 bits wide (see hwint.h). */
+/* #undef NEED_64BIT_HOST_WIDE_INT */
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+/* #undef NO_MINUS_C_MINUS_O */
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""
+
+/* Define to PREFIX/include if cpp should also search that directory. */
+#define PREFIX_INCLUDE_DIR "NONE/include"
+
+/* The number of bytes in type int */
+#define SIZEOF_INT 4
+
+/* The number of bytes in type long */
+#define SIZEOF_LONG 4
+
+/* The number of bytes in type long long */
+#define SIZEOF_LONG_LONG 8
+
+/* The number of bytes in type short */
+#define SIZEOF_SHORT 2
+
+/* The number of bytes in type void * */
+#define SIZEOF_VOID_P 4
+
+/* The number of bytes in type __int64 */
+/* #undef SIZEOF___INT64 */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define if you can safely include both <string.h> and <strings.h>. */
+#define STRING_WITH_STRINGS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define if your assembler mis-optimizes .eh_frame data. */
+/* #undef USE_AS_TRADITIONAL_FORMAT */
+
+/* Define if gcc should use -lunwind. */
+/* #undef USE_LIBUNWIND_EXCEPTIONS */
+
+/* Define to be the last portion of registry key on windows hosts. */
+/* #undef WIN32_REGISTRY_KEY */
+
+/* whether byteorder is bigendian */
+/* #undef WORDS_BIGENDIAN */
+
+/* Always define this when using the GNU C Library */
+#define _GNU_SOURCE 1
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef gid_t */
+
+/* Define as `__inline' if that's what the C compiler calls it, or to nothing
+   if it is not supported. */
+/* #undef inline */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define to \`long' if <sys/resource.h> doesn't define. */
+/* #undef rlim_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef ssize_t */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef uid_t */
+
+/* Define as `fork' if `vfork' does not work. */
+/* #undef vfork */
diff -urN linux-2.6.9_orig/include/asm-i386/gcc/tconfig.h linux-2.6.9/include/asm-i386/gcc/tconfig.h
--- linux-2.6.9_orig/include/asm-i386/gcc/tconfig.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/asm-i386/gcc/tconfig.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,7 @@
+#ifndef GCC_TCONFIG_H
+#define GCC_TCONFIG_H
+#ifdef IN_GCC
+# include "ansidecl.h"
+#endif
+#define USED_FOR_TARGET
+#endif /* GCC_TCONFIG_H */
diff -urN linux-2.6.9_orig/include/asm-i386/gcc/tm.h linux-2.6.9/include/asm-i386/gcc/tm.h
--- linux-2.6.9_orig/include/asm-i386/gcc/tm.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/asm-i386/gcc/tm.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,19 @@
+#ifndef GCC_TM_H
+#define GCC_TM_H
+#ifdef IN_GCC
+# undef fastcall
+# include "config/i386/i386.h"
+# include "config/i386/unix.h"
+# include "config/i386/att.h"
+# include "config/dbxelf.h"
+# include "config/elfos.h"
+# include "config/svr4.h"
+# include "config/linux.h"
+# include "config/i386/linux.h"
+# include "defaults.h"
+#endif
+#if defined IN_GCC && !defined GENERATOR_FILE && !defined USED_FOR_TARGET
+# include "insn-constants.h"
+# include "insn-flags.h"
+#endif
+#endif /* GCC_TM_H */
diff -urN linux-2.6.9_orig/include/c++/begin_include.h linux-2.6.9/include/c++/begin_include.h
--- linux-2.6.9_orig/include/c++/begin_include.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/c++/begin_include.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,25 @@
+/*  begin_include.h
+ *
+ *  Copyright (C) - Reykjavik University 2004
+ *  Authors:            Petur Runolfsson
+ *  E-mail:     pronto@ru.is
+ */
+
+#ifndef CXX_BEGIN_INCLUDE_H_INCLUDED
+# define CXX_BEGIN_INCLUDE_H_INCLUDED
+#endif
+
+/* Provide defines for C++ keywords that are used as identifiers in
+ * kernel headers. Those headers can be included from C++ code if this
+ * file is included first. */
+#ifdef __cplusplus
+
+extern "C" {
+
+# define new newx
+# define namespace namespacex
+# define private privatex
+# define class classx
+# define typename typenamex
+# define virtual virtualx
+#endif
diff -urN linux-2.6.9_orig/include/c++/bits/c++config.h linux-2.6.9/include/c++/bits/c++config.h
--- linux-2.6.9_orig/include/c++/bits/c++config.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/c++/bits/c++config.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,6 @@
+#ifndef LINUX_BITS_CXXCONFIG_H_INCLUDED
+#define LINUX_BITS_CXXCONFIG_H_INCLUDED
+
+
+
+#endif
diff -urN linux-2.6.9_orig/include/c++/bits/gthr.h linux-2.6.9/include/c++/bits/gthr.h
--- linux-2.6.9_orig/include/c++/bits/gthr.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/c++/bits/gthr.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,62 @@
+/*  gthr.h
+ *
+ *  Copyright (C) - Reykjavik University 2004
+ *  Authors:            Petur Runolfsson
+ *  E-mail:     pronto@ru.is
+ */
+
+#ifndef CXX_BITS_GTHR_H_INCLUDED
+#define CXX_BITS_GTHR_H_INCLUDED
+
+/* See gcc/gthr.h in gcc-3.4.0 */
+
+#include <c++/begin_include.h>
+#include <linux/spinlock.h>
+#include <c++/end_include.h>
+
+#define __GTHREADS 1
+
+typedef spinlock_t __gthread_mutex_t;
+
+#define __gthread_mutex_lock(lock) spin_lock_irq(lock)
+#define __gthread_mutex_unlock(lock) spin_unlock_irq(lock)
+#define __GTHREAD_MUTEX_INIT SPIN_LOCK_UNLOCKED
+
+typedef struct {
+   spinlock_t lock;
+   volatile int initialized;
+} __gthread_once_t;
+
+#define __GTHREAD_ONCE_INIT { SPIN_LOCK_UNLOCKED, 0 }
+
+#ifdef __cplusplus
+extern "C"
+#else
+static
+#endif
+inline int __gthread_once(__gthread_once_t *once, void (*func) (void))
+{
+   if (!once->initialized) {
+      spin_lock_irq(&once->lock);
+
+      if (!once->initialized) {
+         func();
+         once->initialized = 1;
+      }
+
+      spin_unlock_irq(&once->lock);
+   }
+   return 0;
+}
+
+#ifdef __cplusplus
+extern "C"
+#else
+static
+#endif
+inline int __gthread_active_p(void)
+{
+   return 1;
+}
+
+#endif
diff -urN linux-2.6.9_orig/include/c++/climits linux-2.6.9/include/c++/climits
--- linux-2.6.9_orig/include/c++/climits	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/c++/climits	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,12 @@
+#ifndef LINUX_CLIMITS_INCLUDED
+#define LINUX_CLIMITS_INCLUDED
+
+#include <linux/kernel.h>
+
+#undef INT_MAX
+#define INT_MAX __INT_MAX__
+
+#undef LONG_MAX
+#define LONG_MAX __LONG_MAX__
+
+#endif
diff -urN linux-2.6.9_orig/include/c++/cstddef linux-2.6.9/include/c++/cstddef
--- linux-2.6.9_orig/include/c++/cstddef	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/c++/cstddef	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,18 @@
+// -*- C++ -*-
+
+#ifndef __cplusplus
+#error "This file is only for C++"
+#endif
+
+#ifndef LINUX_CSTDDEF_INCLUDED
+#define LINUX_CSTDDEF_INCLUDED
+
+#include <begin_include.h>
+#include <linux/types.h>
+#include <end_include.h>
+
+namespace std {
+   using ::size_t;
+}
+
+#endif
diff -urN linux-2.6.9_orig/include/c++/cstdlib linux-2.6.9/include/c++/cstdlib
--- linux-2.6.9_orig/include/c++/cstdlib	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/c++/cstdlib	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,20 @@
+// -*- C++ -*-
+
+#ifndef __cplusplus
+#error "This file is only for C++"
+#endif
+
+#ifndef LINUX_CSTDLIB_INCLUDED
+#define LINUX_CSTDLIB_INCLUDED
+
+#include <begin_include.h>
+#include <linux/types.h>
+#include <end_include.h>
+
+namespace std {
+   using ::cxx_malloc;
+   using ::cxx_free;
+   using ::cxx_abort;
+}
+
+#endif
diff -urN linux-2.6.9_orig/include/c++/cstring linux-2.6.9/include/c++/cstring
--- linux-2.6.9_orig/include/c++/cstring	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/c++/cstring	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,18 @@
+#ifndef LINUX_CSTRING_INCLUDED
+#define LINUX_CSTRING_INCLUDED
+
+#include <asm/string.h>
+
+namespace std {
+   extern "C" inline void* cxx_memset(void* dst, const void* src, size_t sz)
+   {
+      return memset(dst, src, sz);
+   }
+}
+
+using std::cxx_memset;
+
+#undef memset
+#define memset cxx_memset
+
+#endif
diff -urN linux-2.6.9_orig/include/c++/cxxabi.h linux-2.6.9/include/c++/cxxabi.h
--- linux-2.6.9_orig/include/c++/cxxabi.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/c++/cxxabi.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,558 @@
+// new abi support -*- C++ -*-
+  
+// Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+// 
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+// Written by Nathan Sidwell, Codesourcery LLC, <nathan@codesourcery.com>
+ 
+/* This file declares the new abi entry points into the runtime. It is not
+   normally necessary for user programs to include this header, or use the
+   entry points directly. However, this header is available should that be
+   needed.
+   
+   Some of the entry points are intended for both C and C++, thus this header
+   is includable from both C and C++. Though the C++ specific parts are not
+   available in C, naturally enough.  */
+
+#ifndef _CXXABI_H
+#define _CXXABI_H 1
+
+#ifdef __cplusplus
+
+// We use the compiler builtins __SIZE_TYPE__ and __PTRDIFF_TYPE__ instead of
+// std::size_t and std::ptrdiff_t respectively. This makes us independent of
+// the conformance level of <cstddef> and whether -fhonor-std was supplied.
+// <cstddef> is not currently available during compiler building anyway.
+// Including <stddef.h> would be wrong, as that would rudely place size_t in
+// the global namespace.
+
+#include <typeinfo>
+
+namespace __cxxabiv1
+{
+
+/* type information for int, float etc */
+class __fundamental_type_info
+  : public std::type_info
+{
+public:
+  virtual ~__fundamental_type_info ();
+public:
+  explicit __fundamental_type_info (const char *__n)
+    : std::type_info (__n)
+    { }
+};
+
+/* type information for array objects */
+class __array_type_info
+  : public std::type_info
+{
+/* abi defined member functions */
+protected:
+  virtual ~__array_type_info ();
+public:
+  explicit __array_type_info (const char *__n)
+    : std::type_info (__n)
+    { }
+};
+
+/* type information for functions (both member and non-member) */
+class __function_type_info
+  : public std::type_info
+{
+/* abi defined member functions */
+public:
+  virtual ~__function_type_info ();
+public:
+  explicit __function_type_info (const char *__n)
+    : std::type_info (__n)
+    { }
+  
+/* implementation defined member functions */
+protected:
+  virtual bool __is_function_p () const;
+};
+
+/* type information for enumerations */
+class __enum_type_info
+  : public std::type_info
+{
+/* abi defined member functions */
+public:
+  virtual ~__enum_type_info ();
+public:
+  explicit __enum_type_info (const char *__n)
+    : std::type_info (__n)
+    { }
+};
+
+/* common type information for simple pointers and pointers to member */
+class __pbase_type_info
+  : public std::type_info
+{
+/* abi defined member variables */
+public:
+  unsigned int __flags; /* qualification of the target object */
+  const std::type_info *__pointee;   /* type of pointed to object */
+
+/* abi defined member functions */
+public:
+  virtual ~__pbase_type_info ();
+public:
+  explicit __pbase_type_info (const char *__n,
+                                int __quals,
+                                const std::type_info *__type)
+    : std::type_info (__n), __flags (__quals), __pointee (__type)
+    { }
+
+/* implementation defined types */
+public:
+  enum __masks {
+    __const_mask = 0x1,
+    __volatile_mask = 0x2,
+    __restrict_mask = 0x4,
+    __incomplete_mask = 0x8,
+    __incomplete_class_mask = 0x10
+  };
+
+/* implementation defined member functions */
+protected:
+  virtual bool __do_catch (const std::type_info *__thr_type,
+                           void **__thr_obj,
+                           unsigned __outer) const;
+protected:
+  inline virtual bool __pointer_catch (const __pbase_type_info *__thr_type,
+                                       void **__thr_obj,
+                                       unsigned __outer) const;
+};
+
+/* type information for simple pointers */
+class __pointer_type_info
+  : public __pbase_type_info
+{
+/* abi defined member functions */
+public:
+  virtual ~__pointer_type_info ();
+public:
+  explicit __pointer_type_info (const char *__n,
+                                int __quals,
+                                const std::type_info *__type)
+    : __pbase_type_info (__n, __quals, __type)
+    { }
+
+/* implementation defined member functions */
+protected:
+  virtual bool __is_pointer_p () const;
+
+protected:
+  virtual bool __pointer_catch (const __pbase_type_info *__thr_type,
+                                void **__thr_obj,
+                                unsigned __outer) const;
+};
+
+class __class_type_info;
+
+/* type information for a pointer to member variable */
+class __pointer_to_member_type_info
+  : public __pbase_type_info
+{
+/* abi defined member variables */
+public:
+  __class_type_info *__context;   /* class of the member */
+
+/* abi defined member functions */
+public:
+  virtual ~__pointer_to_member_type_info ();
+public:
+  explicit __pointer_to_member_type_info (const char *__n,
+                                          int __quals,
+                                          const std::type_info *__type,
+                                          __class_type_info *__klass)
+    : __pbase_type_info (__n, __quals, __type), __context (__klass)
+    { }
+
+/* implementation defined member functions */
+protected:
+  virtual bool __pointer_catch (const __pbase_type_info *__thr_type,
+                                void **__thr_obj,
+                                unsigned __outer) const;
+};
+
+/* helper class for __vmi_class_type */
+class __base_class_type_info
+{
+/* abi defined member variables */
+public:
+  const __class_type_info* __base_type;    /* base class type */
+  long __offset_flags;            /* offset and info */
+
+/* implementation defined types */
+public:
+  enum __offset_flags_masks {
+    __virtual_mask = 0x1,
+    __public_mask = 0x2,
+    __hwm_bit = 2,
+    __offset_shift = 8          /* bits to shift offset by */
+  };
+  
+/* implementation defined member functions */
+public:
+  bool __is_virtual_p () const
+    { return __offset_flags & __virtual_mask; }
+  bool __is_public_p () const
+    { return __offset_flags & __public_mask; }
+  __PTRDIFF_TYPE__ __offset () const
+    { 
+      // This shift, being of a signed type, is implementation defined. GCC
+      // implements such shifts as arithmetic, which is what we want.
+      return static_cast<__PTRDIFF_TYPE__> (__offset_flags) >> __offset_shift;
+    }
+};
+
+/* type information for a class */
+class __class_type_info
+  : public std::type_info
+{
+/* abi defined member functions */
+public:
+  virtual ~__class_type_info ();
+public:
+  explicit __class_type_info (const char *__n)
+    : type_info (__n)
+    { }
+
+/* implementation defined types */
+public:
+  /* sub_kind tells us about how a base object is contained within a derived
+     object. We often do this lazily, hence the UNKNOWN value. At other times
+     we may use NOT_CONTAINED to mean not publicly contained. */
+  enum __sub_kind
+  {
+    __unknown = 0,              /* we have no idea */
+    __not_contained,            /* not contained within us (in some */
+                                /* circumstances this might mean not contained */
+                                /* publicly) */
+    __contained_ambig,          /* contained ambiguously */
+    
+    __contained_virtual_mask = __base_class_type_info::__virtual_mask, /* via a virtual path */
+    __contained_public_mask = __base_class_type_info::__public_mask,   /* via a public path */
+    __contained_mask = 1 << __base_class_type_info::__hwm_bit,         /* contained within us */
+    
+    __contained_private = __contained_mask,
+    __contained_public = __contained_mask | __contained_public_mask
+  };
+
+public:  
+  struct __upcast_result;
+  struct __dyncast_result;
+
+/* implementation defined member functions */
+protected:
+  virtual bool __do_upcast (const __class_type_info *__dst_type, void **__obj_ptr) const;
+
+protected:
+  virtual bool __do_catch (const type_info *__thr_type, void **__thr_obj,
+                           unsigned __outer) const;
+
+
+public:
+  /* Helper for upcast. See if DST is us, or one of our bases. */
+  /* Return false if not found, true if found. */
+  virtual bool __do_upcast (const __class_type_info *__dst,
+                            const void *__obj,
+                            __upcast_result &__restrict __result) const;
+
+public:
+  /* Indicate whether SRC_PTR of type SRC_TYPE is contained publicly within
+     OBJ_PTR. OBJ_PTR points to a base object of our type, which is the
+     destination type. SRC2DST indicates how SRC objects might be contained
+     within this type.  If SRC_PTR is one of our SRC_TYPE bases, indicate the
+     virtuality. Returns not_contained for non containment or private
+     containment. */
+  inline __sub_kind __find_public_src (__PTRDIFF_TYPE__ __src2dst,
+                                       const void *__obj_ptr,
+                                       const __class_type_info *__src_type,
+                                       const void *__src_ptr) const;
+
+public:
+  /* dynamic cast helper. ACCESS_PATH gives the access from the most derived
+     object to this base. DST_TYPE indicates the desired type we want. OBJ_PTR
+     points to a base of our type within the complete object. SRC_TYPE
+     indicates the static type started from and SRC_PTR points to that base
+     within the most derived object. Fill in RESULT with what we find. Return
+     true if we have located an ambiguous match. */
+  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,
+                             __sub_kind __access_path,
+                             const __class_type_info *__dst_type,
+                             const void *__obj_ptr,
+                             const __class_type_info *__src_type,
+                             const void *__src_ptr,
+                             __dyncast_result &__result) const;
+public:
+  /* Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE bases are
+     inherited by the type started from -- which is not necessarily the
+     current type. The current type will be a base of the destination type.
+     OBJ_PTR points to the current base. */
+  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,
+                                           const void *__obj_ptr,
+                                           const __class_type_info *__src_type,
+                                           const void *__src_ptr) const;
+};
+
+/* type information for a class with a single non-virtual base */
+class __si_class_type_info
+  : public __class_type_info
+{
+/* abi defined member variables */
+public:
+  const __class_type_info *__base_type;
+
+/* abi defined member functions */
+public:
+  virtual ~__si_class_type_info ();
+public:
+  explicit __si_class_type_info (const char *__n,
+                                 const __class_type_info *__base)
+    : __class_type_info (__n), __base_type (__base)
+    { }
+
+/* implementation defined member functions */
+protected:
+  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,
+                             __sub_kind __access_path,
+                             const __class_type_info *__dst_type,
+                             const void *__obj_ptr,
+                             const __class_type_info *__src_type,
+                             const void *__src_ptr,
+                             __dyncast_result &__result) const;
+  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,
+                                           const void *__obj_ptr,
+                                           const __class_type_info *__src_type,
+                                           const void *__sub_ptr) const;
+  virtual bool __do_upcast (const __class_type_info *__dst,
+                            const void *__obj,
+                            __upcast_result &__restrict __result) const;
+};
+
+/* type information for a class with multiple and/or virtual bases */
+class __vmi_class_type_info : public __class_type_info {
+/* abi defined member variables */
+public:
+  unsigned int __flags;         /* details about the class hierarchy */
+  unsigned int __base_count;    /* number of direct bases */
+  __base_class_type_info __base_info[1]; /* array of bases */
+  /* The array of bases uses the trailing array struct hack
+     so this class is not constructable with a normal constructor. It is
+     internally generated by the compiler. */
+
+/* abi defined member functions */
+public:
+  virtual ~__vmi_class_type_info ();
+public:
+  explicit __vmi_class_type_info (const char *__n,
+                                  int ___flags)
+    : __class_type_info (__n), __flags (___flags), __base_count (0)
+    { }
+
+/* implementation defined types */
+public:
+  enum __flags_masks {
+    __non_diamond_repeat_mask = 0x1,   /* distinct instance of repeated base */
+    __diamond_shaped_mask = 0x2,       /* diamond shaped multiple inheritance */
+    __flags_unknown_mask = 0x10
+  };
+
+/* implementation defined member functions */
+protected:
+  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,
+                             __sub_kind __access_path,
+                             const __class_type_info *__dst_type,
+                             const void *__obj_ptr,
+                             const __class_type_info *__src_type,
+                             const void *__src_ptr,
+                             __dyncast_result &__result) const;
+  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,
+                                           const void *__obj_ptr,
+                                           const __class_type_info *__src_type,
+                                           const void *__src_ptr) const;
+  virtual bool __do_upcast (const __class_type_info *__dst,
+                            const void *__obj,
+                            __upcast_result &__restrict __result) const;
+};
+
+/* dynamic cast runtime */
+extern "C"
+void *__dynamic_cast (const void *__src_ptr,    /* object started from */
+                      const __class_type_info *__src_type, /* static type of object */
+                      const __class_type_info *__dst_type, /* desired target type */
+                      __PTRDIFF_TYPE__ __src2dst); /* how src and dst are related */
+
+    /* src2dst has the following possible values
+       >= 0: src_type is a unique public non-virtual base of dst_type
+             dst_ptr + src2dst == src_ptr
+       -1: unspecified relationship
+       -2: src_type is not a public base of dst_type
+       -3: src_type is a multiple public non-virtual base of dst_type */
+
+/* array ctor/dtor routines */
+
+/* allocate and construct array */
+extern "C"
+void *__cxa_vec_new (__SIZE_TYPE__ __element_count,
+                     __SIZE_TYPE__ __element_size,
+                     __SIZE_TYPE__ __padding_size,
+                     void (*__constructor) (void *),
+                     void (*__destructor) (void *));
+
+extern "C"
+void *__cxa_vec_new2 (__SIZE_TYPE__ __element_count,
+                      __SIZE_TYPE__ __element_size,
+                      __SIZE_TYPE__ __padding_size,
+                      void (*__constructor) (void *),
+                      void (*__destructor) (void *),
+                      void *(*__alloc) (__SIZE_TYPE__),
+                      void (*__dealloc) (void *));
+
+extern "C"
+void *__cxa_vec_new3 (__SIZE_TYPE__ __element_count,
+                      __SIZE_TYPE__ __element_size,
+                      __SIZE_TYPE__ __padding_size,
+                      void (*__constructor) (void *),
+                      void (*__destructor) (void *),
+                      void *(*__alloc) (__SIZE_TYPE__),
+                      void (*__dealloc) (void *, __SIZE_TYPE__));
+
+/* construct array */
+extern "C"
+void __cxa_vec_ctor (void *__array_address,
+                     __SIZE_TYPE__ __element_count,
+                     __SIZE_TYPE__ __element_size,
+                     void (*__constructor) (void *),
+                     void (*__destructor) (void *));
+
+extern "C"
+void __cxa_vec_cctor (void *dest_array,
+		      void *src_array,
+		      __SIZE_TYPE__ element_count,
+		      __SIZE_TYPE__ element_size,
+		      void (*constructor) (void *, void *),
+		      void (*destructor) (void *));
+ 
+/* destruct array */
+extern "C"
+void __cxa_vec_dtor (void *__array_address,
+                     __SIZE_TYPE__ __element_count,
+                     __SIZE_TYPE__ __element_size,
+                     void (*__destructor) (void *));
+
+/* destruct array */
+extern "C"
+void __cxa_vec_cleanup (void *__array_address,
+			__SIZE_TYPE__ __element_count,
+			__SIZE_TYPE__ __element_size,
+			void (*__destructor) (void *));
+
+/* destruct and release array */
+extern "C"
+void __cxa_vec_delete (void *__array_address,
+                       __SIZE_TYPE__ __element_size,
+                       __SIZE_TYPE__ __padding_size,
+                       void (*__destructor) (void *));
+
+extern "C"
+void __cxa_vec_delete2 (void *__array_address,
+                        __SIZE_TYPE__ __element_size,
+                        __SIZE_TYPE__ __padding_size,
+                        void (*__destructor) (void *),
+                        void (*__dealloc) (void *));
+                  
+extern "C"
+void __cxa_vec_delete3 (void *__array_address,
+                        __SIZE_TYPE__ __element_size,
+                        __SIZE_TYPE__ __padding_size,
+                        void (*__destructor) (void *),
+                        void (*__dealloc) (void *, __SIZE_TYPE__));
+
+/* guard variables */
+
+/* The ABI requires a 64-bit type.  */
+__extension__ typedef int __guard __attribute__((mode (__DI__)));
+
+extern "C"
+int __cxa_guard_acquire (__guard *);
+
+extern "C"
+void __cxa_guard_release (__guard *);
+
+extern "C"
+void __cxa_guard_abort (__guard *);
+
+/* pure virtual functions */
+
+extern "C" void
+__cxa_pure_virtual (void);
+
+/* exception handling */
+
+extern "C" void
+__cxa_bad_cast ();
+
+extern "C" void
+__cxa_bad_typeid ();
+
+/* DSO destruction */
+
+extern "C" int
+__cxa_atexit (void (*)(void *), void *, void *);
+
+extern "C" int
+__cxa_finalize (void *);
+
+/* demangling routines */
+
+extern "C" 
+char *__cxa_demangle (const char *__mangled_name,
+		      char *__output_buffer,
+		      __SIZE_TYPE__ *__length,
+		      int *__status);
+
+// Returns the type_info for the currently handled exception [15.3/8], or
+// null if there is none.
+extern "C"
+std::type_info *__cxa_current_exception_type ();
+
+} /* namespace __cxxabiv1 */
+
+/* User programs should use the alias `abi'. */
+namespace abi = __cxxabiv1;
+
+#else
+#endif /* __cplusplus */
+
+
+#endif /* __CXXABI_H */
diff -urN linux-2.6.9_orig/include/c++/end_include.h linux-2.6.9/include/c++/end_include.h
--- linux-2.6.9_orig/include/c++/end_include.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/c++/end_include.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,24 @@
+/*  end_include.h
+ *
+ *  Copyright (C) - Reykjavik University 2004
+ *  Authors:            Petur Runolfsson
+ *  E-mail:     pronto@ru.is
+ */
+
+/* This file must always be paired with begin_include.h */
+#ifndef CXX_BEGIN_INCLUDE_H_INCLUDED
+# error "end_include.h used without begin_include.h"
+#endif
+
+#ifdef __cplusplus
+
+# undef new
+# undef namespace
+# undef private
+# undef class
+# undef typename
+# undef virtual 
+} /* extern "C" */
+
+#endif
+
diff -urN linux-2.6.9_orig/include/c++/exception linux-2.6.9/include/c++/exception
--- linux-2.6.9_orig/include/c++/exception	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/c++/exception	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,120 @@
+// Exception Handling support header for -*- C++ -*-
+
+// Copyright (C) 1995, 1996, 1997, 1998, 2000, 2001, 2002
+// Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+// 
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+/** @file exception
+ *  This header defines several types and functions relating to the
+ *  handling of exceptions in a C++ program.
+ */
+
+#ifndef __EXCEPTION__
+#define __EXCEPTION__
+
+extern "C++" {
+
+namespace std 
+{
+  /**
+   *  @brief Base class for all library exceptions.
+   *
+   *  This is the base class for all exceptions thrown by the standard
+   *  library, and by certain language expressions.  You are free to derive
+   *  your own %exception classes, or use a different hierarchy, or to
+   *  throw non-class data (e.g., fundamental types).
+   */
+  class exception 
+  {
+  public:
+    exception() throw() { }
+    virtual ~exception() throw();
+    /** Returns a C-style character string describing the general cause
+     *  of the current error.  */
+    virtual const char* what() const throw();
+  };
+
+  /** If an %exception is thrown which is not listed in a function's
+   *  %exception specification, one of these may be thrown.  */
+  class bad_exception : public exception 
+  {
+  public:
+    bad_exception() throw() { }
+    // This declaration is not useless:
+    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
+    virtual ~bad_exception() throw();
+  };
+
+  /// If you write a replacement %terminate handler, it must be of this type.
+  typedef void (*terminate_handler) ();
+  /// If you write a replacement %unexpected handler, it must be of this type.
+  typedef void (*unexpected_handler) ();
+
+  /// Takes a new handler function as an argument, returns the old function.
+  terminate_handler set_terminate(terminate_handler) throw();
+  /** The runtime will call this function if %exception handling must be
+   *  abandoned for any reason.  It can also be called by the user.  */
+  void terminate() __attribute__ ((__noreturn__));
+
+  /// Takes a new handler function as an argument, returns the old function.
+  unexpected_handler set_unexpected(unexpected_handler) throw();
+  /** The runtime will call this function if an %exception is thrown which
+   *  violates the function's %exception specification.  */
+  void unexpected() __attribute__ ((__noreturn__));
+
+  /** [18.6.4]/1:  "Returns true after completing evaluation of a
+   *  throw-expression until either completing initialization of the
+   *  exception-declaration in the matching handler or entering @c unexpected()
+   *  due to the throw; or after entering @c terminate() for any reason
+   *  other than an explicit call to @c terminate().  [Note: This includes
+   *  stack unwinding [15.2].  end note]"
+   *
+   *  2:  "When @c uncaught_exception() is true, throwing an %exception can
+   *  result in a call of @c terminate() (15.5.1)."
+   */
+  bool uncaught_exception() throw();
+} // namespace std
+
+namespace __gnu_cxx
+{
+  /** A replacement for the standard terminate_handler which prints more
+      information about the terminating exception (if any) on stderr.  Call
+      @code
+        std::set_terminate (__gnu_cxx::__verbose_terminate_handler)
+      @endcode
+      to use.  For more info, see
+      http://gcc.gnu.org/onlinedocs/libstdc++/19_diagnostics/howto.html#4
+
+      In 3.4 and later, this is on by default.
+  */
+  void __verbose_terminate_handler ();
+} // namespace __gnu_cxx
+  
+} // extern "C++"
+
+#endif
diff -urN linux-2.6.9_orig/include/c++/exception_defines.h linux-2.6.9/include/c++/exception_defines.h
--- linux-2.6.9_orig/include/c++/exception_defines.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/c++/exception_defines.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,47 @@
+// -fno-exceptions Support -*- C++ -*-
+
+// Copyright (C) 2001, 2003 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+//
+// ISO C++ 14882: 19.1  Exception classes
+//
+
+#ifndef _EXCEPTION_DEFINES_H
+#define _EXCEPTION_DEFINES_H 1
+
+#ifndef __EXCEPTIONS
+// Iff -fno-exceptions, transform error handling code to work without it.
+# define try      if (true)
+# define catch(X) if (false)
+# define __throw_exception_again
+#else
+// Else proceed normally.
+# define __throw_exception_again throw
+#endif
+
+#endif
diff -urN linux-2.6.9_orig/include/c++/new linux-2.6.9/include/c++/new
--- linux-2.6.9_orig/include/c++/new	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/c++/new	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,101 @@
+// The -*- C++ -*- dynamic memory management header.
+
+// Copyright (C) 1994, 1996, 1997, 1998, 2000, 2001, 2002
+// Free Software Foundation
+
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+// 
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+/** @file new
+ *  The header @c new defines several functions to manage dynamic memory and
+ *  handling memory allocation errors; see
+ *  http://gcc.gnu.org/onlinedocs/libstdc++/18_support/howto.html#4 for more.
+ */
+
+#ifndef _NEW
+#define _NEW
+
+#include <cstddef>
+#include <exception>
+
+extern "C++" {
+
+namespace std 
+{
+  /**
+   *  @brief  Exception possibly thrown by @c new.
+   *
+   *  @c bad_alloc (or classes derived from it) is used to report allocation
+   *  errors from the throwing forms of @c new.  */
+  class bad_alloc : public exception 
+  {
+  public:
+    bad_alloc() throw() { }
+    // This declaration is not useless:
+    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
+    virtual ~bad_alloc() throw();
+  };
+
+  struct nothrow_t { };
+  extern const nothrow_t nothrow;
+  /** If you write your own error handler to be called by @c new, it must
+   *  be of this type.  */
+  typedef void (*new_handler)();
+  /// Takes a replacement handler as the argument, returns the previous handler.
+  new_handler set_new_handler(new_handler) throw();
+} // namespace std
+
+//@{
+/** These are replaceable signatures:
+ *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
+ *  - normal array new and delete (same)
+ *  - @c nothrow single new and delete (take a @c nothrow argument, return
+ *    @c NULL on error)
+ *  - @c nothrow array new and delete (same)
+ *
+ *  Placement new and delete signatures (take a memory address argument,
+ *  does nothing) may not be replaced by a user's program.
+*/
+void* operator new(std::size_t) throw (std::bad_alloc);
+void* operator new[](std::size_t) throw (std::bad_alloc);
+void operator delete(void*) throw();
+void operator delete[](void*) throw();
+void* operator new(std::size_t, const std::nothrow_t&) throw();
+void* operator new[](std::size_t, const std::nothrow_t&) throw();
+void operator delete(void*, const std::nothrow_t&) throw();
+void operator delete[](void*, const std::nothrow_t&) throw();
+
+// Default placement versions of operator new.
+inline void* operator new(std::size_t, void* __p) throw() { return __p; }
+inline void* operator new[](std::size_t, void* __p) throw() { return __p; }
+
+// Default placement versions of operator delete.
+inline void  operator delete  (void*, void*) throw() { }
+inline void  operator delete[](void*, void*) throw() { }
+//@}
+} // extern "C++"
+
+#endif
diff -urN linux-2.6.9_orig/include/c++/typeinfo linux-2.6.9/include/c++/typeinfo
--- linux-2.6.9_orig/include/c++/typeinfo	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/c++/typeinfo	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,157 @@
+// RTTI support for -*- C++ -*-
+// Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002
+// Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+// 
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+/** @file typeinfo
+ *  This header provides RTTI support.
+ */
+
+#ifndef _TYPEINFO
+#define _TYPEINFO
+
+#include <exception>
+
+extern "C++" {
+
+namespace __cxxabiv1
+{
+  class __class_type_info;
+} // namespace __cxxabiv1
+
+// Even though the compiler supports weak symbols on linux, the module
+// loader doesn't merge symbols from modules with symbols from the kernel
+// or other modules, so use strcmp for typeinfo comparisons.
+#if !__GXX_WEAK__
+  // If weak symbols are not supported, typeinfo names are not merged.
+  #define __GXX_MERGED_TYPEINFO_NAMES 0
+#else
+  // On platforms that support weak symbols, typeinfo names are merged.
+  #define __GXX_MERGED_TYPEINFO_NAMES 1
+#endif
+
+namespace std 
+{
+  /**
+   *  @brief  Part of RTTI.
+   *
+   *  The @c type_info class describes type information generated by
+   *  an implementation.
+  */
+  class type_info 
+  {
+  public:
+    /** Destructor. Being the first non-inline virtual function, this
+     *  controls in which translation unit the vtable is emitted. The
+     *  compiler makes use of that information to know where to emit
+     *  the runtime-mandated type_info structures in the new-abi.  */
+    virtual ~type_info();
+
+  private:
+    /// Assigning type_info is not supported.  Made private.
+    type_info& operator=(const type_info&);
+    type_info(const type_info&);
+    
+  protected:
+    const char *__name;
+    
+  protected:
+    explicit type_info(const char *__n): __name(__n) { }
+    
+  public:
+    // the public interface
+    /** Returns an @e implementation-defined byte string; this is not
+     *  portable between compilers!  */
+    const char* name() const
+    { return __name; }
+
+#if !__GXX_MERGED_TYPEINFO_NAMES
+    bool before(const type_info& __arg) const;
+    // In old abi, or when weak symbols are not supported, there can
+    // be multiple instances of a type_info object for one
+    // type. Uniqueness must use the _name value, not object address.
+    bool operator==(const type_info& __arg) const;
+#else
+    /** Returns true if @c *this precedes @c __arg in the implementation's
+     *  collation order.  */
+    // In new abi we can rely on type_info's NTBS being unique,
+    // and therefore address comparisons are sufficient.
+    bool before(const type_info& __arg) const;
+    bool operator==(const type_info& __arg) const;
+#endif
+    bool operator!=(const type_info& __arg) const
+    { return !operator==(__arg); }
+    
+    // the internal interface
+  public:
+    // return true if this is a pointer type of some kind
+    virtual bool __is_pointer_p() const;
+    // return true if this is a function type
+    virtual bool __is_function_p() const;
+
+    // Try and catch a thrown type. Store an adjusted pointer to the
+    // caught type in THR_OBJ. If THR_TYPE is not a pointer type, then
+    // THR_OBJ points to the thrown object. If THR_TYPE is a pointer
+    // type, then THR_OBJ is the pointer itself. OUTER indicates the
+    // number of outer pointers, and whether they were const
+    // qualified.
+    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
+			    unsigned __outer) const;
+
+    // internally used during catch matching
+    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
+			     void **__obj_ptr) const;
+  };
+
+  /**
+   *  @brief  Thrown during incorrect typecasting.
+   *
+   *  If you attempt an invalid @c dynamic_cast expression, an instance of
+   *  this class (or something derived from this class) is thrown.  */
+  class bad_cast : public exception 
+  {
+  public:
+    bad_cast() throw() { }
+    // This declaration is not useless:
+    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
+    virtual ~bad_cast() throw();
+  };
+  
+  /** If you use a NULL pointer in a @c typeid expression, this is thrown.  */
+  class bad_typeid : public exception 
+  {
+  public:
+    bad_typeid () throw() { }
+    // This declaration is not useless:
+    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
+    virtual ~bad_typeid() throw();
+  };
+} // namespace std
+
+} // extern "C++"
+#endif
diff -urN linux-2.6.9_orig/include/linux/customhash.h linux-2.6.9/include/linux/customhash.h
--- linux-2.6.9_orig/include/linux/customhash.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/include/linux/customhash.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,137 @@
+#ifndef _HASH_H
+#define _HASH_H
+
+/*
+ * hash.h
+ *
+ * Copyright (C) 1999, 2000 Richard Guenther
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+/* Static hashtable generator, use like
+ *   struct node {
+ *       struct node **pprev_node_hash;
+ *       struct node *next_node_hash;
+ *       int id;
+ *       ...
+ *   };
+ *   HASH(node, struct node, 8,
+ *        (node->id == id),
+ *        (id),
+ *        (node->id),
+ *        int id)
+ * to have a struct node hash with id as the hash key and a
+ * 1<<8 sized hashtable. The following functions are created:
+ *   hash_add_node(struct node *)
+ *   hash_remove_node(struct node *)
+ *   hash_find_node(int id)
+ *   hash_find_next_node(int id, struct node *)
+ *   hash_next_node(struct node *)
+ *   hash_init_node(struct node *)
+ *   is_hashed_node(struct node *)
+ *   hash_getslot_node(int slot)
+ * 
+ * So the HASH macro would have the following prototype:
+ * HASH(symbol name, type recordtype, int hashbits, expr comparison,
+ *      expr hash(...), expr hash(recordtype), hash arguments...)
+ */
+
+
+
+#define HASH(FOOBAR, FOOBARtype, HASH_BITS, HASH_COMPARE, HASH_HASHFN_FROM_PARAMS, HASH_HASHFN_FROM_TYPE, params...) \
+\
+static FOOBARtype *FOOBAR##_hash_table[1<<HASH_BITS]; \
+\
+static inline FOOBARtype *hash_getslot_##FOOBAR(int slot) \
+{ \
+    return FOOBAR##_hash_table[slot&((1<<HASH_BITS)-1)]; \
+} \
+\
+static inline FOOBARtype *hash_find_##FOOBAR(params) \
+{ \
+  FOOBARtype *FOOBAR = FOOBAR##_hash_table[(HASH_HASHFN_FROM_PARAMS)&((1<<HASH_BITS)-1)]; \
+  goto inside; \
+\
+  for (;;) { \
+    FOOBAR = FOOBAR->next_##FOOBAR##_hash; \
+inside: \
+    if (!FOOBAR) \
+      break; \
+    if (HASH_COMPARE) \
+      break; \
+  } \
+  return FOOBAR; \
+} \
+\
+static inline FOOBARtype *hash_find_next_##FOOBAR(params, FOOBARtype *FOOBAR) \
+{ \
+  if (!FOOBAR) { \
+    FOOBAR = FOOBAR##_hash_table[(HASH_HASHFN_FROM_PARAMS)&((1<<HASH_BITS)-1)]; \
+    goto inside; \
+  } \
+\
+  for (;;) { \
+    FOOBAR = FOOBAR->next_##FOOBAR##_hash; \
+inside: \
+    if (!FOOBAR) \
+      break; \
+    if (HASH_COMPARE) \
+      break; \
+  } \
+  return FOOBAR; \
+} \
+\
+static inline FOOBARtype *hash_next_##FOOBAR(FOOBARtype *FOOBAR) \
+{ \
+        return (FOOBAR)->next_##FOOBAR##_hash; \
+} \
+\
+static inline void hash_add_##FOOBAR(FOOBARtype *FOOBAR) \
+{ \
+        FOOBARtype **tt = &FOOBAR##_hash_table[(HASH_HASHFN_FROM_TYPE)&((1<<HASH_BITS)-1)]; \
+	if (((FOOBAR)->next_##FOOBAR##_hash = *(tt)) != NULL) \
+		(*(tt))->pprev_##FOOBAR##_hash = &(FOOBAR)->next_##FOOBAR##_hash; \
+	*(tt) = (FOOBAR); \
+	(FOOBAR)->pprev_##FOOBAR##_hash = (tt); \
+} \
+\
+static inline void hash_remove_##FOOBAR(FOOBARtype *t) \
+{ \
+	if (!t->pprev_##FOOBAR##_hash) \
+		return; \
+	if (t->next_##FOOBAR##_hash) \
+		t->next_##FOOBAR##_hash->pprev_##FOOBAR##_hash = t->pprev_##FOOBAR##_hash; \
+	*t->pprev_##FOOBAR##_hash = t->next_##FOOBAR##_hash; \
+	t->pprev_##FOOBAR##_hash = NULL; \
+} \
+\
+static inline void hash_init_##FOOBAR(FOOBARtype *t) \
+{ \
+	t->pprev_##FOOBAR##_hash = NULL; \
+} \
+\
+static inline int is_hashed_##FOOBAR(FOOBARtype *t) \
+{ \
+	return t->pprev_##FOOBAR##_hash != NULL; \
+}
+
+
+#endif
diff -urN linux-2.6.9_orig/include/linux/init.h linux-2.6.9/include/linux/init.h
--- linux-2.6.9_orig/include/linux/init.h	2004-10-26 13:20:36.000000000 +0000
+++ linux-2.6.9/include/linux/init.h	2004-10-26 13:26:04.000000000 +0000
@@ -180,6 +180,28 @@
 
 #define security_initcall(fn)		module_init(fn)
 
+#if defined(CONFIG_CXX_RUNTIME) && defined(__cplusplus)
+/* These are defined in lib/gcc/crtstuff.c */
+extern void begin_init(void);
+extern void end_init(void);
+extern void begin_fini(void);
+
+#define module_init(initfn)					\
+	int init_module(void)					\
+	{							\
+		begin_init();					\
+		end_init();					\
+		return initfn();				\
+	}
+
+#define module_exit(exitfn)					\
+	void cleanup_module(void)				\
+	{							\
+		exitfn();					\
+		begin_fini();					\
+	}
+
+#else /* !CONFIG_CXX_RUNTIME || !__cplusplus */
 /* These macros create a dummy inline: gcc 2.9x does not count alias
  as usage, hence the `unused function' warning when __init functions
  are declared static. We use the dummy __*_module_inline functions
@@ -197,6 +219,7 @@
 	static inline exitcall_t __exittest(void)		\
 	{ return exitfn; }					\
 	void cleanup_module(void) __attribute__((alias(#exitfn)));
+#endif /* !CONFIG_CXX_RUNTIME || !__cplusplus */
 
 #define __setup_param(str, unique_id, fn)	/* nothing */
 #define __setup_null_param(str, unique_id) 	/* nothing */
diff -urN linux-2.6.9_orig/include/linux/module.h linux-2.6.9/include/linux/module.h
--- linux-2.6.9_orig/include/linux/module.h	2004-10-26 13:20:36.000000000 +0000
+++ linux-2.6.9/include/linux/module.h	2004-10-26 13:26:04.000000000 +0000
@@ -207,6 +207,14 @@
 	MODULE_STATE_COMING,
 	MODULE_STATE_GOING,
 };
+#ifdef CONFIG_CXX_RUNTIME	
+struct weak_symbol
+{
+	 unsigned long value;
+     char *name;
+     struct weak_symbol* next;
+};
+#endif
 
 /* sysfs stuff */
 struct module_attribute
@@ -268,7 +276,7 @@
 	unsigned int num_exentries;
 	const struct exception_table_entry *extable;
 
-	/* Startup function. */
+	/* Startup function.*/
 	int (*init)(void);
 
 	/* If this is non-NULL, vfree after init() returns */
@@ -325,6 +333,10 @@
 	/* The command line arguments (may be mangled).  People like
 	   keeping pointers to this stuff */
 	char *args;
+#ifdef CONFIG_CXX_RUNTIME	
+	//weak symbols
+	struct weak_symbol* weak_symbols;
+#endif
 };
 
 /* FIXME: It'd be nice to isolate modules during init, too, so they
diff -urN linux-2.6.9_orig/include/linux/sched.h linux-2.6.9/include/linux/sched.h
--- linux-2.6.9_orig/include/linux/sched.h	2004-10-26 13:20:36.000000000 +0000
+++ linux-2.6.9/include/linux/sched.h	2004-10-26 13:42:06.000000000 +0000
@@ -584,6 +584,14 @@
   	struct mempolicy *mempolicy;
   	short il_next;		/* could be shared with used_math */
 #endif
+ 
+ #ifdef CONFIG_CXX_RUNTIME
+ 	/* Copied from unwind-cxx.h */
+ 	struct {
+ 		void *caughtExceptions;
+ 		unsigned int uncaughtExceptions;
+ 	} cxa_eh_globals;
+ #endif
 };
 
 static inline pid_t process_group(struct task_struct *tsk)
diff -urN linux-2.6.9_orig/include/linux/spinlock.h linux-2.6.9/include/linux/spinlock.h
--- linux-2.6.9_orig/include/linux/spinlock.h	2004-10-26 13:20:36.000000000 +0000
+++ linux-2.6.9/include/linux/spinlock.h	2004-10-26 13:26:04.000000000 +0000
@@ -177,13 +177,12 @@
 	} while (0)
 #else
 /*
- * gcc versions before ~2.95 have a nasty bug with empty initializers.
+ * Differences in initializers and handling of empty structs in C and C++.
  */
-#if (__GNUC__ > 2)
-  typedef struct { } spinlock_t;
-  #define SPIN_LOCK_UNLOCKED (spinlock_t) { }
+typedef struct { int not_used; } spinlock_t;
+#ifdef __cplusplus
+  #define SPIN_LOCK_UNLOCKED spinlock_t()
 #else
-  typedef struct { int gcc_is_buggy; } spinlock_t;
   #define SPIN_LOCK_UNLOCKED (spinlock_t) { 0 }
 #endif
 
@@ -200,11 +199,10 @@
 
 /* RW spinlocks: No debug version */
 
-#if (__GNUC__ > 2)
-  typedef struct { } rwlock_t;
-  #define RW_LOCK_UNLOCKED (rwlock_t) { }
+typedef struct { int not_used; } rwlock_t;
+#ifdef __cplusplus
+  #define RW_LOCK_UNLOCKED rwlock_t()
 #else
-  typedef struct { int gcc_is_buggy; } rwlock_t;
   #define RW_LOCK_UNLOCKED (rwlock_t) { 0 }
 #endif
 
diff -urN linux-2.6.9_orig/include/linux/sysctl.h linux-2.6.9/include/linux/sysctl.h
--- linux-2.6.9_orig/include/linux/sysctl.h	2004-10-26 13:20:36.000000000 +0000
+++ linux-2.6.9/include/linux/sysctl.h	2004-10-26 13:26:04.000000000 +0000
@@ -857,6 +857,9 @@
 	int maxlen;
 	mode_t mode;
 	ctl_table *child;
+#ifdef __cplusplus
+	::
+#endif
 	proc_handler *proc_handler;	/* Callback for text formatting */
 	ctl_handler *strategy;		/* Callback function for all r/w */
 	struct proc_dir_entry *de;	/* /proc control block */
@@ -868,6 +871,9 @@
    ctl_table trees. */
 struct ctl_table_header
 {
+#ifdef __cplusplus
+	::
+#endif
 	ctl_table *ctl_table;
 	struct list_head ctl_entry;
 };
diff -urN linux-2.6.9_orig/init/Kconfig linux-2.6.9/init/Kconfig
--- linux-2.6.9_orig/init/Kconfig	2004-10-26 13:20:15.000000000 +0000
+++ linux-2.6.9/init/Kconfig	2004-10-26 13:26:04.000000000 +0000
@@ -303,6 +303,15 @@
 	  option replaces shmem and tmpfs with the much simpler ramfs code,
 	  which may be appropriate on small systems without swap.
 
+config CXX_RUNTIME
+	bool "C++ runtime support"
+	default y
+
+config CXX_RUNTIME_TEST
+	tristate "Tests for C++ runtime support"
+	depends CXX_RUNTIME
+	default m
+
 endmenu		# General setup
 
 config TINY_SHMEM
diff -urN linux-2.6.9_orig/kernel/module.c linux-2.6.9/kernel/module.c
--- linux-2.6.9_orig/kernel/module.c	2004-10-26 13:20:24.000000000 +0000
+++ linux-2.6.9/kernel/module.c	2004-10-26 13:26:04.000000000 +0000
@@ -172,6 +172,21 @@
 				}
 			}
 		}
+#ifdef CONFIG_CXX_RUNTIME		
+		//and now the weak symbols!
+		if(mod->weak_symbols)
+		{
+		    struct weak_symbol* it_weak_symbols= mod->weak_symbols;
+		    while(it_weak_symbols)
+		    {
+		        if (strcmp(it_weak_symbols->name, name) == 0) 
+		        {				
+				   return it_weak_symbols->value;
+		        }
+		        it_weak_symbols = it_weak_symbols->next;
+			}
+		}
+#endif		
 	}
 	DEBUGP("Failed to find symbol %s\n", name);
  	return 0;
@@ -1164,6 +1179,9 @@
 /* Free a module, remove from lists, etc (must hold module mutex). */
 static void free_module(struct module *mod)
 {
+#ifdef CONFIG_CXX_RUNTIME	
+	 struct weak_symbol* weak_symbol;
+#endif
 	/* Delete from various lists */
 	spin_lock_irq(&modlist_lock);
 	list_del(&mod->list);
@@ -1174,7 +1192,18 @@
 
 	/* Arch-specific cleanup. */
 	module_arch_cleanup(mod);
-
+#ifdef CONFIG_CXX_RUNTIME	
+    /* free the weak symbol stuff*/
+   weak_symbol = mod->weak_symbols;
+   while(weak_symbol!=0)
+   {
+   	 struct weak_symbol* next = weak_symbol->next;
+   	 //now delete the stuff
+   	 kfree(weak_symbol->name);
+   	 kfree(weak_symbol);
+   	 weak_symbol = next;
+   }
+#endif    
 	/* Module unload stuff */
 	module_unload_free(mod);
 
@@ -1213,6 +1242,11 @@
 			    struct module *mod)
 {
 	Elf_Sym *sym = (void *)sechdrs[symindex].sh_addr;
+#ifdef CONFIG_CXX_RUNTIME	
+	Elf32_Addr	st_value=0;
+	struct weak_symbol* weak_symbol;
+    const char* weak_symbol_name;
+#endif
 	unsigned long secbase;
 	unsigned int i, n = sechdrs[symindex].sh_size / sizeof(Elf_Sym);
 	int ret = 0;
@@ -1257,7 +1291,38 @@
 				secbase = (unsigned long)mod->percpu;
 			else
 				secbase = sechdrs[sym[i].st_shndx].sh_addr;
-			sym[i].st_value += secbase;
+#ifdef CONFIG_CXX_RUNTIME				
+		    if (ELF_ST_BIND(sym[i].st_info) == STB_WEAK)
+			{
+				//printk("Weak symbol: %s\n", strtab + sym[i].st_name);
+				st_value = resolve_symbol(sechdrs, versindex,
+					   strtab + sym[i].st_name, mod);
+    			//printk("Resolved symbol: %x\n",st_value);
+			    if(st_value==0)
+			    {
+			    	sym[i].st_value += secbase;
+			    	//printk("Putting default value of: %x into weak symbol map\n",sym[i].st_value );
+			    	//now insert to weak symbols linked list
+			    	weak_symbol = kmalloc(sizeof(struct weak_symbol), GFP_KERNEL);
+			    	weak_symbol->value=sym[i].st_value;
+			    	weak_symbol_name= strtab + sym[i].st_name;
+			    	weak_symbol->name = kmalloc(strlen(weak_symbol_name),GFP_KERNEL);
+			    	strcpy(weak_symbol->name,weak_symbol_name);
+			    	weak_symbol->next = mod->weak_symbols;
+			    	mod->weak_symbols = weak_symbol;
+			    }
+			    else
+			    {
+			        sym[i].st_value = st_value;
+			    }
+			}			
+			else
+			{
+			   sym[i].st_value += secbase;
+			}
+#else
+            sym[i].st_value += secbase;
+#endif			
 			break;
 		}
 	}
diff -urN linux-2.6.9_orig/lib/cxa_atexit.c linux-2.6.9/lib/cxa_atexit.c
--- linux-2.6.9_orig/lib/cxa_atexit.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/cxa_atexit.c	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,94 @@
+/*  cxa_atexit.c
+ *
+ *  Copyright (C) - Reykjavik University 2004
+ *  Authors:            Petur Runolfsson
+ *  E-mail:     pronto@ru.is
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/bug.h>
+
+/*  This code is loosely based on cxa_atexit.c and cxa_finalize.c in
+ *  glibc-2.3. */
+
+/* A registered destructor function */
+struct atexit_fn {
+   void (*func) (void *);
+   void *arg;
+   void *d;
+   struct atexit_fn *next;
+};
+
+/* Linked list of registered destructors, protected by callbacks_lock */
+static struct atexit_fn *callbacks;
+static spinlock_t callbacks_lock = SPIN_LOCK_UNLOCKED;
+
+/* This function is called by code injected by the compiler, when constructors
+ * of static objects are run. The last argument is the __dso_handle of the
+ * module from which the call is made. */
+int
+__cxa_atexit (void (*func) (void *), void *arg, void *d)
+{
+   struct atexit_fn *afn;
+
+   /* Since the kernel never exits, static objects defined within the
+    * kernel image will dever be destroyed. Hence no need to register */
+   if (!d)
+      return 0;
+
+   afn = kmalloc(sizeof(struct atexit_fn), GFP_KERNEL);
+   if (!afn) {
+      printk(KERN_ERR "Failed to alloc atexit_fn\n");
+      return -1;
+   }
+
+   afn->func = func;
+   afn->arg = arg;
+   afn->d = d;
+
+   spin_lock_irq(&callbacks_lock);
+   afn->next = callbacks;
+   callbacks = afn;
+   spin_unlock_irq(&callbacks_lock);
+
+   return 0;
+}
+EXPORT_SYMBOL(__cxa_atexit);
+
+/* This is called from crtbeginM.o during module unloading. The argument d
+ * is the __dso_handle of the module being unloaded. This calls destructors
+ * of static objects defined in the module. */
+void
+__cxa_finalize (void *d)
+{
+   struct atexit_fn **p;
+
+   /* See comment in __cxa_atexit */
+   BUG_ON(d == NULL);
+
+   spin_lock_irq(&callbacks_lock);
+   p = &callbacks;
+   while (*p) {
+      struct atexit_fn *afn = *p;
+
+      if (afn->d == d) {
+         *p = afn->next;
+         /* Need to unlock while the destructor is called
+          * because the destructor may do funky things */
+         spin_unlock_irq(&callbacks_lock);
+
+         (afn->func)(afn->arg);
+         kfree(afn);
+
+         spin_lock_irq(&callbacks_lock);
+      } else {
+         p = &afn->next;
+      }
+   }
+   spin_unlock_irq(&callbacks_lock);
+}
+EXPORT_SYMBOL(__cxa_finalize);
diff -urN linux-2.6.9_orig/lib/gcc/ansidecl.h linux-2.6.9/lib/gcc/ansidecl.h
--- linux-2.6.9_orig/lib/gcc/ansidecl.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/ansidecl.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,315 @@
+/* ANSI and traditional C compatability macros
+   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* ANSI and traditional C compatibility macros
+
+   ANSI C is assumed if __STDC__ is #defined.
+
+   Macro		ANSI C definition	Traditional C definition
+   -----		---- - ----------	----------- - ----------
+   ANSI_PROTOTYPES	1			not defined
+   PTR			`void *'		`char *'
+   PTRCONST		`void *const'		`char *'
+   LONG_DOUBLE		`long double'		`double'
+   const		not defined		`'
+   volatile		not defined		`'
+   signed		not defined		`'
+   VA_START(ap, var)	va_start(ap, var)	va_start(ap)
+
+   Note that it is safe to write "void foo();" indicating a function
+   with no return value, in all K+R compilers we have been able to test.
+
+   For declaring functions with prototypes, we also provide these:
+
+   PARAMS ((prototype))
+   -- for functions which take a fixed number of arguments.  Use this
+   when declaring the function.  When defining the function, write a
+   K+R style argument list.  For example:
+
+	char *strcpy PARAMS ((char *dest, char *source));
+	...
+	char *
+	strcpy (dest, source)
+	     char *dest;
+	     char *source;
+	{ ... }
+
+
+   VPARAMS ((prototype, ...))
+   -- for functions which take a variable number of arguments.  Use
+   PARAMS to declare the function, VPARAMS to define it.  For example:
+
+	int printf PARAMS ((const char *format, ...));
+	...
+	int
+	printf VPARAMS ((const char *format, ...))
+	{
+	   ...
+	}
+
+   For writing functions which take variable numbers of arguments, we
+   also provide the VA_OPEN, VA_CLOSE, and VA_FIXEDARG macros.  These
+   hide the differences between K+R <varargs.h> and C89 <stdarg.h> more
+   thoroughly than the simple VA_START() macro mentioned above.
+
+   VA_OPEN and VA_CLOSE are used *instead of* va_start and va_end.
+   Immediately after VA_OPEN, put a sequence of VA_FIXEDARG calls
+   corresponding to the list of fixed arguments.  Then use va_arg
+   normally to get the variable arguments, or pass your va_list object
+   around.  You do not declare the va_list yourself; VA_OPEN does it
+   for you.
+
+   Here is a complete example:
+
+	int
+	printf VPARAMS ((const char *format, ...))
+	{
+	   int result;
+
+	   VA_OPEN (ap, format);
+	   VA_FIXEDARG (ap, const char *, format);
+
+	   result = vfprintf (stdout, format, ap);
+	   VA_CLOSE (ap);
+
+	   return result;
+	}
+
+
+   You can declare variables either before or after the VA_OPEN,
+   VA_FIXEDARG sequence.  Also, VA_OPEN and VA_CLOSE are the beginning
+   and end of a block.  They must appear at the same nesting level,
+   and any variables declared after VA_OPEN go out of scope at
+   VA_CLOSE.  Unfortunately, with a K+R compiler, that includes the
+   argument list.  You can have multiple instances of VA_OPEN/VA_CLOSE
+   pairs in a single function in case you need to traverse the
+   argument list more than once.
+
+   For ease of writing code which uses GCC extensions but needs to be
+   portable to other compilers, we provide the GCC_VERSION macro that
+   simplifies testing __GNUC__ and __GNUC_MINOR__ together, and various
+   wrappers around __attribute__.  Also, __extension__ will be #defined
+   to nothing if it doesn't work.  See below.
+
+   This header also defines a lot of obsolete macros:
+   CONST, VOLATILE, SIGNED, PROTO, EXFUN, DEFUN, DEFUN_VOID,
+   AND, DOTS, NOARGS.  Don't use them.  */
+
+#ifndef	_ANSIDECL_H
+#define _ANSIDECL_H	1
+
+/* Every source file includes this file,
+   so they will all get the switch for lint.  */
+/* LINTLIBRARY */
+
+/* Using MACRO(x,y) in cpp #if conditionals does not work with some
+   older preprocessors.  Thus we can't define something like this:
+
+#define HAVE_GCC_VERSION(MAJOR, MINOR) \
+  (__GNUC__ > (MAJOR) || (__GNUC__ == (MAJOR) && __GNUC_MINOR__ >= (MINOR)))
+
+and then test "#if HAVE_GCC_VERSION(2,7)".
+
+So instead we use the macro below and test it against specific values.  */
+
+/* This macro simplifies testing whether we are using gcc, and if it
+   is of a particular minimum version. (Both major & minor numbers are
+   significant.)  This macro will evaluate to 0 if we are not using
+   gcc at all.  */
+#ifndef GCC_VERSION
+#define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)
+#endif /* GCC_VERSION */
+
+#if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32) || (defined(__alpha) && defined(__cplusplus))
+/* All known AIX compilers implement these things (but don't always
+   define __STDC__).  The RISC/OS MIPS compiler defines these things
+   in SVR4 mode, but does not define __STDC__.  */
+/* eraxxon@alumni.rice.edu: The Compaq C++ compiler, unlike many other
+   C++ compilers, does not define __STDC__, though it acts as if this
+   was so. (Verified versions: 5.7, 6.2, 6.3, 6.5) */
+
+#define ANSI_PROTOTYPES	1
+#define PTR		void *
+#define PTRCONST	void *const
+#define LONG_DOUBLE	long double
+
+#define PARAMS(ARGS)		ARGS
+#define VPARAMS(ARGS)		ARGS
+#define VA_START(VA_LIST, VAR)	va_start(VA_LIST, VAR)
+
+/* variadic function helper macros */
+/* "struct Qdmy" swallows the semicolon after VA_OPEN/VA_FIXEDARG's
+   use without inhibiting further decls and without declaring an
+   actual variable.  */
+#define VA_OPEN(AP, VAR)	{ va_list AP; va_start(AP, VAR); { struct Qdmy
+#define VA_CLOSE(AP)		} va_end(AP); }
+#define VA_FIXEDARG(AP, T, N)	struct Qdmy
+ 
+#undef const
+#undef volatile
+#undef signed
+
+/* inline requires special treatment; it's in C99, and GCC >=2.7 supports
+   it too, but it's not in C89.  */
+#undef inline
+#if __STDC_VERSION__ > 199901L
+/* it's a keyword */
+#else
+# if GCC_VERSION >= 2007
+#  define inline __inline__   /* __inline__ prevents -pedantic warnings */
+# else
+#  define inline  /* nothing */
+# endif
+#endif
+
+/* These are obsolete.  Do not use.  */
+#ifndef IN_GCC
+#define CONST		const
+#define VOLATILE	volatile
+#define SIGNED		signed
+
+#define PROTO(type, name, arglist)	type name arglist
+#define EXFUN(name, proto)		name proto
+#define DEFUN(name, arglist, args)	name(args)
+#define DEFUN_VOID(name)		name(void)
+#define AND		,
+#define DOTS		, ...
+#define NOARGS		void
+#endif /* ! IN_GCC */
+
+#else	/* Not ANSI C.  */
+
+#undef  ANSI_PROTOTYPES
+#define PTR		char *
+#define PTRCONST	PTR
+#define LONG_DOUBLE	double
+
+#define PARAMS(args)		()
+#define VPARAMS(args)		(va_alist) va_dcl
+#define VA_START(va_list, var)	va_start(va_list)
+
+#define VA_OPEN(AP, VAR)		{ va_list AP; va_start(AP); { struct Qdmy
+#define VA_CLOSE(AP)			} va_end(AP); }
+#define VA_FIXEDARG(AP, TYPE, NAME)	TYPE NAME = va_arg(AP, TYPE)
+
+/* some systems define these in header files for non-ansi mode */
+#undef const
+#undef volatile
+#undef signed
+#undef inline
+#define const
+#define volatile
+#define signed
+#define inline
+
+#ifndef IN_GCC
+#define CONST
+#define VOLATILE
+#define SIGNED
+
+#define PROTO(type, name, arglist)	type name ()
+#define EXFUN(name, proto)		name()
+#define DEFUN(name, arglist, args)	name arglist args;
+#define DEFUN_VOID(name)		name()
+#define AND		;
+#define DOTS
+#define NOARGS
+#endif /* ! IN_GCC */
+
+#endif	/* ANSI C.  */
+
+/* Define macros for some gcc attributes.  This permits us to use the
+   macros freely, and know that they will come into play for the
+   version of gcc in which they are supported.  */
+
+#if (GCC_VERSION < 2007)
+# define __attribute__(x)
+#endif
+
+/* Attribute __malloc__ on functions was valid as of gcc 2.96. */
+#ifndef ATTRIBUTE_MALLOC
+# if (GCC_VERSION >= 2096)
+#  define ATTRIBUTE_MALLOC __attribute__ ((__malloc__))
+# else
+#  define ATTRIBUTE_MALLOC
+# endif /* GNUC >= 2.96 */
+#endif /* ATTRIBUTE_MALLOC */
+
+/* Attributes on labels were valid as of gcc 2.93. */
+#ifndef ATTRIBUTE_UNUSED_LABEL
+# if (GCC_VERSION >= 2093)
+#  define ATTRIBUTE_UNUSED_LABEL ATTRIBUTE_UNUSED
+# else
+#  define ATTRIBUTE_UNUSED_LABEL
+# endif /* GNUC >= 2.93 */
+#endif /* ATTRIBUTE_UNUSED_LABEL */
+
+#ifndef ATTRIBUTE_UNUSED
+#define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+#endif /* ATTRIBUTE_UNUSED */
+
+#ifndef ATTRIBUTE_NORETURN
+#define ATTRIBUTE_NORETURN __attribute__ ((__noreturn__))
+#endif /* ATTRIBUTE_NORETURN */
+
+/* Attribute `nonnull' was valid as of gcc 3.3.  */
+#ifndef ATTRIBUTE_NONNULL
+# if (GCC_VERSION >= 3003)
+#  define ATTRIBUTE_NONNULL(m) __attribute__ ((__nonnull__ (m)))
+# else
+#  define ATTRIBUTE_NONNULL(m)
+# endif /* GNUC >= 3.3 */
+#endif /* ATTRIBUTE_NONNULL */
+
+/* Use ATTRIBUTE_PRINTF when the format specifier must not be NULL.
+   This was the case for the `printf' format attribute by itself
+   before GCC 3.3, but as of 3.3 we need to add the `nonnull'
+   attribute to retain this behavior.  */
+#ifndef ATTRIBUTE_PRINTF
+#define ATTRIBUTE_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n))) ATTRIBUTE_NONNULL(m)
+#define ATTRIBUTE_PRINTF_1 ATTRIBUTE_PRINTF(1, 2)
+#define ATTRIBUTE_PRINTF_2 ATTRIBUTE_PRINTF(2, 3)
+#define ATTRIBUTE_PRINTF_3 ATTRIBUTE_PRINTF(3, 4)
+#define ATTRIBUTE_PRINTF_4 ATTRIBUTE_PRINTF(4, 5)
+#define ATTRIBUTE_PRINTF_5 ATTRIBUTE_PRINTF(5, 6)
+#endif /* ATTRIBUTE_PRINTF */
+
+/* Use ATTRIBUTE_NULL_PRINTF when the format specifier may be NULL.  A
+   NULL format specifier was allowed as of gcc 3.3.  */
+#ifndef ATTRIBUTE_NULL_PRINTF
+# if (GCC_VERSION >= 3003)
+#  define ATTRIBUTE_NULL_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n)))
+# else
+#  define ATTRIBUTE_NULL_PRINTF(m, n)
+# endif /* GNUC >= 3.3 */
+# define ATTRIBUTE_NULL_PRINTF_1 ATTRIBUTE_NULL_PRINTF(1, 2)
+# define ATTRIBUTE_NULL_PRINTF_2 ATTRIBUTE_NULL_PRINTF(2, 3)
+# define ATTRIBUTE_NULL_PRINTF_3 ATTRIBUTE_NULL_PRINTF(3, 4)
+# define ATTRIBUTE_NULL_PRINTF_4 ATTRIBUTE_NULL_PRINTF(4, 5)
+# define ATTRIBUTE_NULL_PRINTF_5 ATTRIBUTE_NULL_PRINTF(5, 6)
+#endif /* ATTRIBUTE_NULL_PRINTF */
+
+/* We use __extension__ in some places to suppress -pedantic warnings
+   about GCC extensions.  This feature didn't work properly before
+   gcc 2.8.  */
+#if GCC_VERSION < 2008
+#define __extension__
+#endif
+
+#endif	/* ansidecl.h	*/
diff -urN linux-2.6.9_orig/lib/gcc/config/dbxelf.h linux-2.6.9/lib/gcc/config/dbxelf.h
--- linux-2.6.9_orig/lib/gcc/config/dbxelf.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/config/dbxelf.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,84 @@
+/* Definitions needed when using stabs embedded in ELF sections.
+   Copyright (C) 1999 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* This file may be included by any ELF target which wishes to
+   support -gstabs generating stabs in sections, as produced by gas
+   and understood by gdb.  */
+
+#ifndef GCC_DBX_ELF_H
+#define GCC_DBX_ELF_H
+
+/* Output DBX (stabs) debugging information if doing -gstabs.  */
+
+#define DBX_DEBUGGING_INFO 1
+
+/* Make LBRAC and RBRAC addresses relative to the start of the
+   function.  The native Solaris stabs debugging format works this
+   way, gdb expects it, and it reduces the number of relocation
+   entries...  */
+
+#undef  DBX_BLOCKS_FUNCTION_RELATIVE
+#define DBX_BLOCKS_FUNCTION_RELATIVE 1
+
+/* ... but, to make this work, functions must appear prior to line info.  */
+
+#undef  DBX_FUNCTION_FIRST
+#define DBX_FUNCTION_FIRST
+
+/* When generating stabs debugging, use N_BINCL entries.  */
+
+#undef  DBX_USE_BINCL
+#define DBX_USE_BINCL
+
+/* There is no limit to the length of stabs strings.  */
+
+#ifndef DBX_CONTIN_LENGTH
+#define DBX_CONTIN_LENGTH 0
+#endif
+
+/* Like block addresses, stabs line numbers are relative to the
+   current function.  */
+
+#undef  ASM_OUTPUT_SOURCE_LINE
+#define ASM_OUTPUT_SOURCE_LINE(FILE, LINE, COUNTER)			\
+do									\
+  {									\
+    char temp[256];							\
+    ASM_GENERATE_INTERNAL_LABEL (temp, "LM", COUNTER);			\
+    fprintf (FILE, "\t.stabn 68,0,%d,", LINE);				\
+    assemble_name (FILE, temp);						\
+    putc ('-', FILE);							\
+    assemble_name (FILE,						\
+		   XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\
+    putc ('\n', FILE);							\
+    (*targetm.asm_out.internal_label) (FILE, "LM", COUNTER);		\
+  }									\
+while (0)
+
+/* Generate a blank trailing N_SO to mark the end of the .o file, since
+   we can't depend upon the linker to mark .o file boundaries with
+   embedded stabs.  */
+
+#undef  DBX_OUTPUT_MAIN_SOURCE_FILE_END
+#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)			\
+  asm_fprintf (FILE,							\
+	       "\t.text\n\t.stabs \"\",%d,0,0,%LLetext\n%LLetext:\n", N_SO)
+
+#endif /* ! GCC_DBX_ELF_H */
diff -urN linux-2.6.9_orig/lib/gcc/config/elfos.h linux-2.6.9/lib/gcc/config/elfos.h
--- linux-2.6.9_orig/lib/gcc/config/elfos.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/config/elfos.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,493 @@
+/* elfos.h  --  operating system specific defines to be used when
+   targeting GCC for some generic ELF system
+   Copyright (C) 1991, 1994, 1995, 1999, 2000, 2001, 2002, 2003
+   Free Software Foundation, Inc.
+   Based on svr4.h contributed by Ron Guilmette (rfg@netcom.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#define TARGET_OBJFMT_CPP_BUILTINS()		\
+  do						\
+    {						\
+	builtin_define ("__ELF__");		\
+    }						\
+  while (0)
+
+/* Define a symbol indicating that we are using elfos.h.
+   Some CPU specific configuration files use this.  */
+#define USING_ELFOS_H
+
+/* The prefix to add to user-visible assembler symbols.
+
+   For ELF systems the convention is *not* to prepend a leading
+   underscore onto user-level symbol names.  */
+
+#undef  USER_LABEL_PREFIX
+#define USER_LABEL_PREFIX ""
+
+/* Biggest alignment supported by the object file format of this
+   machine.  Use this macro to limit the alignment which can be
+   specified using the `__attribute__ ((aligned (N)))' construct.  If
+   not defined, the default value is `BIGGEST_ALIGNMENT'.  */
+#ifndef MAX_OFILE_ALIGNMENT
+#define MAX_OFILE_ALIGNMENT (32768 * 8)
+#endif
+
+/* Use periods rather than dollar signs in special g++ assembler names.  */
+
+#define NO_DOLLAR_IN_LABEL
+
+/* Writing `int' for a bit-field forces int alignment for the structure.  */
+
+#ifndef PCC_BITFIELD_TYPE_MATTERS
+#define PCC_BITFIELD_TYPE_MATTERS 1
+#endif
+
+/* Implicit library calls should use memcpy, not bcopy, etc.  */
+
+#define TARGET_MEM_FUNCTIONS
+
+/* Handle #pragma weak and #pragma pack.  */
+
+#define HANDLE_SYSV_PRAGMA 1
+
+/* All ELF targets can support DWARF-2.  */
+
+#define DWARF2_DEBUGGING_INFO 1
+
+/* The GNU tools operate better with dwarf2, and it is required by some
+   psABI's.  Since we don't have any native tools to be compatible with,
+   default to dwarf2.  */
+
+#ifndef PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+#endif
+
+/* All SVR4 targets use the ELF object file format.  */
+#define OBJECT_FORMAT_ELF
+
+
+/* Output #ident as a .ident.  */
+
+#define ASM_OUTPUT_IDENT(FILE, NAME) \
+  fprintf (FILE, "%s\"%s\"\n", IDENT_ASM_OP, NAME);
+
+#define IDENT_ASM_OP "\t.ident\t"
+
+#undef  SET_ASM_OP
+#define SET_ASM_OP	"\t.set\t"
+
+/* Most svr4 assemblers want a .file directive at the beginning of
+   their input file.  */
+#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true
+
+/* This is how to allocate empty space in some section.  The .zero
+   pseudo-op is used for this on most svr4 assemblers.  */
+
+#define SKIP_ASM_OP	"\t.zero\t"
+
+#undef  ASM_OUTPUT_SKIP
+#define ASM_OUTPUT_SKIP(FILE, SIZE) \
+   fprintf ((FILE), "%s"HOST_WIDE_INT_PRINT_UNSIGNED"\n",\
+	    SKIP_ASM_OP, (SIZE))
+
+/* This is how to store into the string LABEL
+   the symbol_ref name of an internal numbered label where
+   PREFIX is the class of label and NUM is the number within the class.
+   This is suitable for output with `assemble_name'.
+
+   For most svr4 systems, the convention is that any symbol which begins
+   with a period is not put into the linker symbol table by the assembler.  */
+
+#undef  ASM_GENERATE_INTERNAL_LABEL
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)		\
+  do								\
+    {								\
+      sprintf (LABEL, "*.%s%u", PREFIX, (unsigned) (NUM));	\
+    }								\
+  while (0)
+
+/* Output the label which precedes a jumptable.  Note that for all svr4
+   systems where we actually generate jumptables (which is to say every
+   svr4 target except i386, where we use casesi instead) we put the jump-
+   tables into the .rodata section and since other stuff could have been
+   put into the .rodata section prior to any given jumptable, we have to
+   make sure that the location counter for the .rodata section gets pro-
+   perly re-aligned prior to the actual beginning of the jump table.  */
+
+#undef ALIGN_ASM_OP
+#define ALIGN_ASM_OP "\t.align\t"
+
+#ifndef ASM_OUTPUT_BEFORE_CASE_LABEL
+#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE, PREFIX, NUM, TABLE) \
+  ASM_OUTPUT_ALIGN ((FILE), 2);
+#endif
+
+#undef  ASM_OUTPUT_CASE_LABEL
+#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, JUMPTABLE)		\
+  do									\
+    {									\
+      ASM_OUTPUT_BEFORE_CASE_LABEL (FILE, PREFIX, NUM, JUMPTABLE)	\
+	(*targetm.asm_out.internal_label) (FILE, PREFIX, NUM);			\
+    }									\
+  while (0)
+
+/* The standard SVR4 assembler seems to require that certain builtin
+   library routines (e.g. .udiv) be explicitly declared as .globl
+   in each assembly file where they are referenced.  */
+
+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)	\
+  (*targetm.asm_out.globalize_label) (FILE, XSTR (FUN, 0))
+
+/* This says how to output assembler code to declare an
+   uninitialized external linkage data object.  Under SVR4,
+   the linker seems to want the alignment of data objects
+   to depend on their types.  We do exactly that here.  */
+
+#define COMMON_ASM_OP	"\t.comm\t"
+
+#undef  ASM_OUTPUT_ALIGNED_COMMON
+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)		\
+  do									\
+    {									\
+      fprintf ((FILE), "%s", COMMON_ASM_OP);				\
+      assemble_name ((FILE), (NAME));					\
+      fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%u\n",		\
+	       (SIZE), (ALIGN) / BITS_PER_UNIT);			\
+    }									\
+  while (0)
+
+/* This says how to output assembler code to declare an
+   uninitialized internal linkage data object.  Under SVR4,
+   the linker seems to want the alignment of data objects
+   to depend on their types.  We do exactly that here.  */
+
+#define LOCAL_ASM_OP	"\t.local\t"
+
+#undef  ASM_OUTPUT_ALIGNED_LOCAL
+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)	\
+  do								\
+    {								\
+      fprintf ((FILE), "%s", LOCAL_ASM_OP);			\
+      assemble_name ((FILE), (NAME));				\
+      fprintf ((FILE), "\n");					\
+      ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);	\
+    }								\
+  while (0)
+
+/* This is the pseudo-op used to generate a contiguous sequence of byte
+   values from a double-quoted string WITHOUT HAVING A TERMINATING NUL
+   AUTOMATICALLY APPENDED.  This is the same for most svr4 assemblers.  */
+
+#undef  ASCII_DATA_ASM_OP
+#define ASCII_DATA_ASM_OP	"\t.ascii\t"
+
+/* Support a read-only data section.  */
+#define READONLY_DATA_SECTION_ASM_OP	"\t.section\t.rodata"
+
+/* On svr4, we *do* have support for the .init and .fini sections, and we
+   can put stuff in there to be executed before and after `main'.  We let
+   crtstuff.c and other files know this by defining the following symbols.
+   The definitions say how to change sections to the .init and .fini
+   sections.  This is the same for all known svr4 assemblers.  */
+
+#define INIT_SECTION_ASM_OP	"\t.section\t.init"
+#define FINI_SECTION_ASM_OP	"\t.section\t.fini"
+
+/* Output assembly directive to move to the beginning of current section.  */
+#ifdef HAVE_GAS_SUBSECTION_ORDERING
+# define ASM_SECTION_START_OP	"\t.subsection\t-1"
+# define ASM_OUTPUT_SECTION_START(FILE)	\
+  fprintf ((FILE), "%s\n", ASM_SECTION_START_OP)
+#endif
+
+#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)
+
+/* Switch into a generic section.  */
+#define TARGET_ASM_NAMED_SECTION  default_elf_asm_named_section
+
+#undef  TARGET_ASM_SELECT_RTX_SECTION
+#define TARGET_ASM_SELECT_RTX_SECTION default_elf_select_rtx_section
+#undef	TARGET_ASM_SELECT_SECTION
+#define TARGET_ASM_SELECT_SECTION default_elf_select_section
+
+/* Define the strings used for the special svr4 .type and .size directives.
+   These strings generally do not vary from one system running svr4 to
+   another, but if a given system (e.g. m88k running svr) needs to use
+   different pseudo-op names for these, they may be overridden in the
+   file which includes this one.  */
+
+#define TYPE_ASM_OP	"\t.type\t"
+#define SIZE_ASM_OP	"\t.size\t"
+
+/* This is how we tell the assembler that a symbol is weak.  */
+
+#define ASM_WEAKEN_LABEL(FILE, NAME)	\
+  do					\
+    {					\
+      fputs ("\t.weak\t", (FILE));	\
+      assemble_name ((FILE), (NAME));	\
+      fputc ('\n', (FILE));		\
+    }					\
+  while (0)
+
+/* The following macro defines the format used to output the second
+   operand of the .type assembler directive.  Different svr4 assemblers
+   expect various different forms for this operand.  The one given here
+   is just a default.  You may need to override it in your machine-
+   specific tm.h file (depending upon the particulars of your assembler).  */
+
+#define TYPE_OPERAND_FMT	"@%s"
+
+/* Write the extra assembler code needed to declare a function's result.
+   Most svr4 assemblers don't require any special declaration of the
+   result value, but there are exceptions.  */
+
+#ifndef ASM_DECLARE_RESULT
+#define ASM_DECLARE_RESULT(FILE, RESULT)
+#endif
+
+/* These macros generate the special .type and .size directives which
+   are used to set the corresponding fields of the linker symbol table
+   entries in an ELF object file under SVR4.  These macros also output
+   the starting labels for the relevant functions/objects.  */
+
+/* Write the extra assembler code needed to declare a function properly.
+   Some svr4 assemblers need to also have something extra said about the
+   function's return value.  We allow for that here.  */
+
+#ifndef ASM_DECLARE_FUNCTION_NAME
+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)		\
+  do								\
+    {								\
+      ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "function");	\
+      ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));		\
+      ASM_OUTPUT_LABEL (FILE, NAME);				\
+    }								\
+  while (0)
+#endif
+
+/* Write the extra assembler code needed to declare an object properly.  */
+
+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)		\
+  do								\
+    {								\
+      HOST_WIDE_INT size;					\
+								\
+      ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "object");		\
+								\
+      size_directive_output = 0;				\
+      if (!flag_inhibit_size_directive				\
+	  && (DECL) && DECL_SIZE (DECL))			\
+	{							\
+	  size_directive_output = 1;				\
+	  size = int_size_in_bytes (TREE_TYPE (DECL));		\
+	  ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, size);		\
+	}							\
+								\
+      ASM_OUTPUT_LABEL (FILE, NAME);				\
+    }								\
+  while (0)
+
+/* Output the size directive for a decl in rest_of_decl_compilation
+   in the case where we did not do so before the initializer.
+   Once we find the error_mark_node, we know that the value of
+   size_directive_output was set
+   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */
+
+#undef ASM_FINISH_DECLARE_OBJECT
+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\
+  do								\
+    {								\
+      const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);	\
+      HOST_WIDE_INT size;					\
+								\
+      if (!flag_inhibit_size_directive				\
+	  && DECL_SIZE (DECL)					\
+	  && ! AT_END && TOP_LEVEL				\
+	  && DECL_INITIAL (DECL) == error_mark_node		\
+	  && !size_directive_output)				\
+	{							\
+	  size_directive_output = 1;				\
+	  size = int_size_in_bytes (TREE_TYPE (DECL));		\
+	  ASM_OUTPUT_SIZE_DIRECTIVE (FILE, name, size);		\
+	}							\
+    }								\
+  while (0)
+
+/* This is how to declare the size of a function.  */
+#ifndef ASM_DECLARE_FUNCTION_SIZE
+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)		\
+  do								\
+    {								\
+      if (!flag_inhibit_size_directive)				\
+	ASM_OUTPUT_MEASURED_SIZE (FILE, FNAME);			\
+    }								\
+  while (0)
+#endif
+
+/* A table of bytes codes used by the ASM_OUTPUT_ASCII and
+   ASM_OUTPUT_LIMITED_STRING macros.  Each byte in the table
+   corresponds to a particular byte value [0..255].  For any
+   given byte value, if the value in the corresponding table
+   position is zero, the given character can be output directly.
+   If the table value is 1, the byte must be output as a \ooo
+   octal escape.  If the tables value is anything else, then the
+   byte value should be output as a \ followed by the value
+   in the table.  Note that we can use standard UN*X escape
+   sequences for many control characters, but we don't use
+   \a to represent BEL because some svr4 assemblers (e.g. on
+   the i386) don't know about that.  Also, we don't use \v
+   since some versions of gas, such as 2.2 did not accept it.  */
+
+#define ESCAPES \
+"\1\1\1\1\1\1\1\1btn\1fr\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
+\0\0\"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\0\0\
+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\
+\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
+\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
+\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
+\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1"
+
+/* Some svr4 assemblers have a limit on the number of characters which
+   can appear in the operand of a .string directive.  If your assembler
+   has such a limitation, you should define STRING_LIMIT to reflect that
+   limit.  Note that at least some svr4 assemblers have a limit on the
+   actual number of bytes in the double-quoted string, and that they
+   count each character in an escape sequence as one byte.  Thus, an
+   escape sequence like \377 would count as four bytes.
+
+   If your target assembler doesn't support the .string directive, you
+   should define this to zero.
+*/
+
+#define STRING_LIMIT	((unsigned) 256)
+
+#define STRING_ASM_OP	"\t.string\t"
+
+/* The routine used to output NUL terminated strings.  We use a special
+   version of this for most svr4 targets because doing so makes the
+   generated assembly code more compact (and thus faster to assemble)
+   as well as more readable, especially for targets like the i386
+   (where the only alternative is to output character sequences as
+   comma separated lists of numbers).  */
+
+#define ASM_OUTPUT_LIMITED_STRING(FILE, STR)		\
+  do							\
+    {							\
+      register const unsigned char *_limited_str =	\
+	(const unsigned char *) (STR);			\
+      register unsigned ch;				\
+							\
+      fprintf ((FILE), "%s\"", STRING_ASM_OP);		\
+							\
+      for (; (ch = *_limited_str); _limited_str++)	\
+        {						\
+	  register int escape;				\
+							\
+	  switch (escape = ESCAPES[ch])			\
+	    {						\
+	    case 0:					\
+	      putc (ch, (FILE));			\
+	      break;					\
+	    case 1:					\
+	      fprintf ((FILE), "\\%03o", ch);		\
+	      break;					\
+	    default:					\
+	      putc ('\\', (FILE));			\
+	      putc (escape, (FILE));			\
+	      break;					\
+	    }						\
+        }						\
+							\
+      fprintf ((FILE), "\"\n");				\
+    }							\
+  while (0)
+
+/* The routine used to output sequences of byte values.  We use a special
+   version of this for most svr4 targets because doing so makes the
+   generated assembly code more compact (and thus faster to assemble)
+   as well as more readable.  Note that if we find subparts of the
+   character sequence which end with NUL (and which are shorter than
+   STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */
+
+#undef  ASM_OUTPUT_ASCII
+#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)				\
+  do									\
+    {									\
+      register const unsigned char *_ascii_bytes =			\
+	(const unsigned char *) (STR);					\
+      register const unsigned char *limit = _ascii_bytes + (LENGTH);	\
+      register unsigned bytes_in_chunk = 0;				\
+									\
+      for (; _ascii_bytes < limit; _ascii_bytes++)			\
+        {								\
+	  register const unsigned char *p;				\
+									\
+	  if (bytes_in_chunk >= 60)					\
+	    {								\
+	      fprintf ((FILE), "\"\n");					\
+	      bytes_in_chunk = 0;					\
+	    }								\
+									\
+	  for (p = _ascii_bytes; p < limit && *p != '\0'; p++)		\
+	    continue;							\
+									\
+	  if (p < limit && (p - _ascii_bytes) <= (long)STRING_LIMIT)	\
+	    {								\
+	      if (bytes_in_chunk > 0)					\
+		{							\
+		  fprintf ((FILE), "\"\n");				\
+		  bytes_in_chunk = 0;					\
+		}							\
+									\
+	      ASM_OUTPUT_LIMITED_STRING ((FILE), _ascii_bytes);		\
+	      _ascii_bytes = p;						\
+	    }								\
+	  else								\
+	    {								\
+	      register int escape;					\
+	      register unsigned ch;					\
+									\
+	      if (bytes_in_chunk == 0)					\
+		fprintf ((FILE), "%s\"", ASCII_DATA_ASM_OP);		\
+									\
+	      switch (escape = ESCAPES[ch = *_ascii_bytes])		\
+		{							\
+		case 0:							\
+		  putc (ch, (FILE));					\
+		  bytes_in_chunk++;					\
+		  break;						\
+		case 1:							\
+		  fprintf ((FILE), "\\%03o", ch);			\
+		  bytes_in_chunk += 4;					\
+		  break;						\
+		default:						\
+		  putc ('\\', (FILE));					\
+		  putc (escape, (FILE));				\
+		  bytes_in_chunk += 2;					\
+		  break;						\
+		}							\
+	    }								\
+	}								\
+									\
+      if (bytes_in_chunk > 0)						\
+        fprintf ((FILE), "\"\n");					\
+    }									\
+  while (0)
diff -urN linux-2.6.9_orig/lib/gcc/config/i386/att.h linux-2.6.9/lib/gcc/config/i386/att.h
--- linux-2.6.9_orig/lib/gcc/config/i386/att.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/config/i386/att.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,85 @@
+/* Definitions for AT&T assembler syntax for the Intel 80386.
+   Copyright (C) 1988, 1996, 2000, 2001, 2002
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+
+/* Define the syntax of instructions and addresses.  */
+
+/* Prefix for internally generated assembler labels.  */
+#define LPREFIX ".L"
+
+/* Assembler pseudos to introduce constants of various size.  */
+
+#define ASM_SHORT "\t.value\t"
+#define ASM_LONG "\t.long\t"
+#define ASM_QUAD "\t.quad\t"  /* Should not be used for 32bit compilation.  */
+
+/* How to output an ASCII string constant.  */
+
+#define ASM_OUTPUT_ASCII(FILE, PTR, SIZE)			\
+do								\
+{ size_t i = 0, limit = (SIZE); 				\
+  while (i < limit)						\
+    { if (i%10 == 0) { if (i!=0) fprintf ((FILE), "\n");	\
+		       fputs ("\t.byte\t", (FILE)); }		\
+      else fprintf ((FILE), ",");				\
+	fprintf ((FILE), "0x%x", ((PTR)[i++] & 0377)) ;}	\
+      fprintf ((FILE), "\n");					\
+} while (0)
+
+/* Output at beginning of assembler file.  */
+#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true
+
+/* This is how to output an assembler line
+   that says to advance the location counter
+   to a multiple of 2**LOG bytes.  */
+
+#define ASM_OUTPUT_ALIGN(FILE,LOG)	\
+    if ((LOG)!=0) fprintf ((FILE), "\t.align %d\n", 1<<(LOG))
+
+/* This is how to output an assembler line
+   that says to advance the location counter by SIZE bytes.  */
+
+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \
+  fprintf ((FILE), "\t.set .,.+%u\n", (int)(SIZE))
+
+/* Can't use ASM_OUTPUT_SKIP in text section; it doesn't leave 0s.  */
+
+#define ASM_NO_SKIP_IN_TEXT 1
+
+/* Define the syntax of labels and symbol definitions/declarations.  */
+
+/* The prefix to add for compiler private assembler symbols.  */
+#undef LOCAL_LABEL_PREFIX
+#define LOCAL_LABEL_PREFIX "."
+
+/* This is how to store into the string BUF
+   the symbol_ref name of an internal numbered label where
+   PREFIX is the class of label and NUM is the number within the class.
+   This is suitable for output with `assemble_name'.  */
+
+#undef ASM_GENERATE_INTERNAL_LABEL
+#define ASM_GENERATE_INTERNAL_LABEL(BUF,PREFIX,NUMBER)	\
+  sprintf ((BUF), "%s%s%ld", LOCAL_LABEL_PREFIX, (PREFIX), (long)(NUMBER))
+
+/* The prefix to add to user-visible assembler symbols.  */
+
+#undef USER_LABEL_PREFIX
+#define USER_LABEL_PREFIX ""
diff -urN linux-2.6.9_orig/lib/gcc/config/i386/i386.h linux-2.6.9/lib/gcc/config/i386/i386.h
--- linux-2.6.9_orig/lib/gcc/config/i386/i386.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/config/i386/i386.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,3188 @@
+/* Definitions of target machine for GCC for IA-32.
+   Copyright (C) 1988, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
+   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* The purpose of this file is to define the characteristics of the i386,
+   independent of assembler syntax or operating system.
+
+   Three other files build on this one to describe a specific assembler syntax:
+   bsd386.h, att386.h, and sun386.h.
+
+   The actual tm.h file for a particular system should include
+   this file, and then the file for the appropriate assembler syntax.
+
+   Many macros that specify assembler syntax are omitted entirely from
+   this file because they really belong in the files for particular
+   assemblers.  These include RP, IP, LPREFIX, PUT_OP_SIZE, USE_STAR,
+   ADDR_BEG, ADDR_END, PRINT_IREG, PRINT_SCALE, PRINT_B_I_S, and many
+   that start with ASM_ or end in ASM_OP.  */
+
+/* Define the specific costs for a given cpu */
+
+struct processor_costs {
+  const int add;		/* cost of an add instruction */
+  const int lea;		/* cost of a lea instruction */
+  const int shift_var;		/* variable shift costs */
+  const int shift_const;	/* constant shift costs */
+  const int mult_init[5];	/* cost of starting a multiply 
+				   in QImode, HImode, SImode, DImode, TImode*/
+  const int mult_bit;		/* cost of multiply per each bit set */
+  const int divide[5];		/* cost of a divide/mod 
+				   in QImode, HImode, SImode, DImode, TImode*/
+  int movsx;			/* The cost of movsx operation.  */
+  int movzx;			/* The cost of movzx operation.  */
+  const int large_insn;		/* insns larger than this cost more */
+  const int move_ratio;		/* The threshold of number of scalar
+				   memory-to-memory move insns.  */
+  const int movzbl_load;	/* cost of loading using movzbl */
+  const int int_load[3];	/* cost of loading integer registers
+				   in QImode, HImode and SImode relative
+				   to reg-reg move (2).  */
+  const int int_store[3];	/* cost of storing integer register
+				   in QImode, HImode and SImode */
+  const int fp_move;		/* cost of reg,reg fld/fst */
+  const int fp_load[3];		/* cost of loading FP register
+				   in SFmode, DFmode and XFmode */
+  const int fp_store[3];	/* cost of storing FP register
+				   in SFmode, DFmode and XFmode */
+  const int mmx_move;		/* cost of moving MMX register.  */
+  const int mmx_load[2];	/* cost of loading MMX register
+				   in SImode and DImode */
+  const int mmx_store[2];	/* cost of storing MMX register
+				   in SImode and DImode */
+  const int sse_move;		/* cost of moving SSE register.  */
+  const int sse_load[3];	/* cost of loading SSE register
+				   in SImode, DImode and TImode*/
+  const int sse_store[3];	/* cost of storing SSE register
+				   in SImode, DImode and TImode*/
+  const int mmxsse_to_integer;	/* cost of moving mmxsse register to
+				   integer and vice versa.  */
+  const int prefetch_block;	/* bytes moved to cache for prefetch.  */
+  const int simultaneous_prefetches; /* number of parallel prefetch
+				   operations.  */
+  const int branch_cost;	/* Default value for BRANCH_COST.  */
+  const int fadd;		/* cost of FADD and FSUB instructions.  */
+  const int fmul;		/* cost of FMUL instruction.  */
+  const int fdiv;		/* cost of FDIV instruction.  */
+  const int fabs;		/* cost of FABS instruction.  */
+  const int fchs;		/* cost of FCHS instruction.  */
+  const int fsqrt;		/* cost of FSQRT instruction.  */
+};
+
+extern const struct processor_costs *ix86_cost;
+
+/* Run-time compilation parameters selecting different hardware subsets.  */
+
+extern int target_flags;
+
+/* Macros used in the machine description to test the flags.  */
+
+/* configure can arrange to make this 2, to force a 486.  */
+
+#ifndef TARGET_CPU_DEFAULT
+#ifdef TARGET_64BIT_DEFAULT
+#define TARGET_CPU_DEFAULT TARGET_CPU_DEFAULT_k8
+#else
+#define TARGET_CPU_DEFAULT 0
+#endif
+#endif
+
+/* Masks for the -m switches */
+#define MASK_80387		0x00000001	/* Hardware floating point */
+#define MASK_RTD		0x00000002	/* Use ret that pops args */
+#define MASK_ALIGN_DOUBLE	0x00000004	/* align doubles to 2 word boundary */
+#define MASK_SVR3_SHLIB		0x00000008	/* Uninit locals into bss */
+#define MASK_IEEE_FP		0x00000010	/* IEEE fp comparisons */
+#define MASK_FLOAT_RETURNS	0x00000020	/* Return float in st(0) */
+#define MASK_NO_FANCY_MATH_387	0x00000040	/* Disable sin, cos, sqrt */
+#define MASK_OMIT_LEAF_FRAME_POINTER 0x080      /* omit leaf frame pointers */
+#define MASK_STACK_PROBE	0x00000100	/* Enable stack probing */
+#define MASK_NO_ALIGN_STROPS	0x00000200	/* Enable aligning of string ops.  */
+#define MASK_INLINE_ALL_STROPS	0x00000400	/* Inline stringops in all cases */
+#define MASK_NO_PUSH_ARGS	0x00000800	/* Use push instructions */
+#define MASK_ACCUMULATE_OUTGOING_ARGS 0x00001000/* Accumulate outgoing args */
+#define MASK_MMX		0x00002000	/* Support MMX regs/builtins */
+#define MASK_SSE		0x00004000	/* Support SSE regs/builtins */
+#define MASK_SSE2		0x00008000	/* Support SSE2 regs/builtins */
+#define MASK_SSE3		0x00010000	/* Support SSE3 regs/builtins */
+#define MASK_3DNOW		0x00020000	/* Support 3Dnow builtins */
+#define MASK_3DNOW_A		0x00040000	/* Support Athlon 3Dnow builtins */
+#define MASK_128BIT_LONG_DOUBLE 0x00080000	/* long double size is 128bit */
+#define MASK_64BIT		0x00100000	/* Produce 64bit code */
+#define MASK_MS_BITFIELD_LAYOUT 0x00200000	/* Use native (MS) bitfield layout */
+#define MASK_TLS_DIRECT_SEG_REFS 0x00400000	/* Avoid adding %gs:0  */
+
+/* Unused:			0x03e0000	*/
+
+/* ... overlap with subtarget options starts by 0x04000000.  */
+#define MASK_NO_RED_ZONE	0x04000000	/* Do not use red zone */
+
+/* Use the floating point instructions */
+#define TARGET_80387 (target_flags & MASK_80387)
+
+/* Compile using ret insn that pops args.
+   This will not work unless you use prototypes at least
+   for all functions that can take varying numbers of args.  */
+#define TARGET_RTD (target_flags & MASK_RTD)
+
+/* Align doubles to a two word boundary.  This breaks compatibility with
+   the published ABI's for structures containing doubles, but produces
+   faster code on the pentium.  */
+#define TARGET_ALIGN_DOUBLE (target_flags & MASK_ALIGN_DOUBLE)
+
+/* Use push instructions to save outgoing args.  */
+#define TARGET_PUSH_ARGS (!(target_flags & MASK_NO_PUSH_ARGS))
+
+/* Accumulate stack adjustments to prologue/epilogue.  */
+#define TARGET_ACCUMULATE_OUTGOING_ARGS \
+ (target_flags & MASK_ACCUMULATE_OUTGOING_ARGS)
+
+/* Put uninitialized locals into bss, not data.
+   Meaningful only on svr3.  */
+#define TARGET_SVR3_SHLIB (target_flags & MASK_SVR3_SHLIB)
+
+/* Use IEEE floating point comparisons.  These handle correctly the cases
+   where the result of a comparison is unordered.  Normally SIGFPE is
+   generated in such cases, in which case this isn't needed.  */
+#define TARGET_IEEE_FP (target_flags & MASK_IEEE_FP)
+
+/* Functions that return a floating point value may return that value
+   in the 387 FPU or in 386 integer registers.  If set, this flag causes
+   the 387 to be used, which is compatible with most calling conventions.  */
+#define TARGET_FLOAT_RETURNS_IN_80387 (target_flags & MASK_FLOAT_RETURNS)
+
+/* Long double is 128bit instead of 96bit, even when only 80bits are used.
+   This mode wastes cache, but avoid misaligned data accesses and simplifies
+   address calculations.  */
+#define TARGET_128BIT_LONG_DOUBLE (target_flags & MASK_128BIT_LONG_DOUBLE)
+
+/* Disable generation of FP sin, cos and sqrt operations for 387.
+   This is because FreeBSD lacks these in the math-emulator-code */
+#define TARGET_NO_FANCY_MATH_387 (target_flags & MASK_NO_FANCY_MATH_387)
+
+/* Don't create frame pointers for leaf functions */
+#define TARGET_OMIT_LEAF_FRAME_POINTER \
+  (target_flags & MASK_OMIT_LEAF_FRAME_POINTER)
+
+/* Debug GO_IF_LEGITIMATE_ADDRESS */
+#define TARGET_DEBUG_ADDR (ix86_debug_addr_string != 0)
+
+/* Debug FUNCTION_ARG macros */
+#define TARGET_DEBUG_ARG (ix86_debug_arg_string != 0)
+
+/* 64bit Sledgehammer mode.  For libgcc2 we make sure this is a
+   compile-time constant.  */
+#ifdef IN_LIBGCC2
+#ifdef __x86_64__
+#define TARGET_64BIT 1
+#else
+#define TARGET_64BIT 0
+#endif
+#else
+#ifdef TARGET_BI_ARCH
+#define TARGET_64BIT (target_flags & MASK_64BIT)
+#else
+#if TARGET_64BIT_DEFAULT
+#define TARGET_64BIT 1
+#else
+#define TARGET_64BIT 0
+#endif
+#endif
+#endif
+
+/* Avoid adding %gs:0 in TLS references; use %gs:address directly.  */
+#define TARGET_TLS_DIRECT_SEG_REFS (target_flags & MASK_TLS_DIRECT_SEG_REFS)
+
+#define TARGET_386 (ix86_tune == PROCESSOR_I386)
+#define TARGET_486 (ix86_tune == PROCESSOR_I486)
+#define TARGET_PENTIUM (ix86_tune == PROCESSOR_PENTIUM)
+#define TARGET_PENTIUMPRO (ix86_tune == PROCESSOR_PENTIUMPRO)
+#define TARGET_K6 (ix86_tune == PROCESSOR_K6)
+#define TARGET_ATHLON (ix86_tune == PROCESSOR_ATHLON)
+#define TARGET_PENTIUM4 (ix86_tune == PROCESSOR_PENTIUM4)
+#define TARGET_K8 (ix86_tune == PROCESSOR_K8)
+#define TARGET_ATHLON_K8 (TARGET_K8 || TARGET_ATHLON)
+
+#define TUNEMASK (1 << ix86_tune)
+extern const int x86_use_leave, x86_push_memory, x86_zero_extend_with_and;
+extern const int x86_use_bit_test, x86_cmove, x86_deep_branch;
+extern const int x86_branch_hints, x86_unroll_strlen;
+extern const int x86_double_with_add, x86_partial_reg_stall, x86_movx;
+extern const int x86_use_loop, x86_use_fiop, x86_use_mov0;
+extern const int x86_use_cltd, x86_read_modify_write;
+extern const int x86_read_modify, x86_split_long_moves;
+extern const int x86_promote_QImode, x86_single_stringop, x86_fast_prefix;
+extern const int x86_himode_math, x86_qimode_math, x86_promote_qi_regs;
+extern const int x86_promote_hi_regs, x86_integer_DFmode_moves;
+extern const int x86_add_esp_4, x86_add_esp_8, x86_sub_esp_4, x86_sub_esp_8;
+extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;
+extern const int x86_accumulate_outgoing_args, x86_prologue_using_move;
+extern const int x86_epilogue_using_move, x86_decompose_lea;
+extern const int x86_arch_always_fancy_math_387, x86_shift1;
+extern const int x86_sse_partial_reg_dependency, x86_sse_partial_regs;
+extern const int x86_sse_typeless_stores, x86_sse_load0_by_pxor;
+extern const int x86_use_ffreep, x86_sse_partial_regs_for_cvtsd2ss;
+extern const int x86_inter_unit_moves;
+extern int x86_prefetch_sse;
+
+#define TARGET_USE_LEAVE (x86_use_leave & TUNEMASK)
+#define TARGET_PUSH_MEMORY (x86_push_memory & TUNEMASK)
+#define TARGET_ZERO_EXTEND_WITH_AND (x86_zero_extend_with_and & TUNEMASK)
+#define TARGET_USE_BIT_TEST (x86_use_bit_test & TUNEMASK)
+#define TARGET_UNROLL_STRLEN (x86_unroll_strlen & TUNEMASK)
+/* For sane SSE instruction set generation we need fcomi instruction.  It is
+   safe to enable all CMOVE instructions.  */
+#define TARGET_CMOVE ((x86_cmove & (1 << ix86_arch)) || TARGET_SSE)
+#define TARGET_DEEP_BRANCH_PREDICTION (x86_deep_branch & TUNEMASK)
+#define TARGET_BRANCH_PREDICTION_HINTS (x86_branch_hints & TUNEMASK)
+#define TARGET_DOUBLE_WITH_ADD (x86_double_with_add & TUNEMASK)
+#define TARGET_USE_SAHF ((x86_use_sahf & TUNEMASK) && !TARGET_64BIT)
+#define TARGET_MOVX (x86_movx & TUNEMASK)
+#define TARGET_PARTIAL_REG_STALL (x86_partial_reg_stall & TUNEMASK)
+#define TARGET_USE_LOOP (x86_use_loop & TUNEMASK)
+#define TARGET_USE_FIOP (x86_use_fiop & TUNEMASK)
+#define TARGET_USE_MOV0 (x86_use_mov0 & TUNEMASK)
+#define TARGET_USE_CLTD (x86_use_cltd & TUNEMASK)
+#define TARGET_SPLIT_LONG_MOVES (x86_split_long_moves & TUNEMASK)
+#define TARGET_READ_MODIFY_WRITE (x86_read_modify_write & TUNEMASK)
+#define TARGET_READ_MODIFY (x86_read_modify & TUNEMASK)
+#define TARGET_PROMOTE_QImode (x86_promote_QImode & TUNEMASK)
+#define TARGET_FAST_PREFIX (x86_fast_prefix & TUNEMASK)
+#define TARGET_SINGLE_STRINGOP (x86_single_stringop & TUNEMASK)
+#define TARGET_QIMODE_MATH (x86_qimode_math & TUNEMASK)
+#define TARGET_HIMODE_MATH (x86_himode_math & TUNEMASK)
+#define TARGET_PROMOTE_QI_REGS (x86_promote_qi_regs & TUNEMASK)
+#define TARGET_PROMOTE_HI_REGS (x86_promote_hi_regs & TUNEMASK)
+#define TARGET_ADD_ESP_4 (x86_add_esp_4 & TUNEMASK)
+#define TARGET_ADD_ESP_8 (x86_add_esp_8 & TUNEMASK)
+#define TARGET_SUB_ESP_4 (x86_sub_esp_4 & TUNEMASK)
+#define TARGET_SUB_ESP_8 (x86_sub_esp_8 & TUNEMASK)
+#define TARGET_INTEGER_DFMODE_MOVES (x86_integer_DFmode_moves & TUNEMASK)
+#define TARGET_PARTIAL_REG_DEPENDENCY (x86_partial_reg_dependency & TUNEMASK)
+#define TARGET_SSE_PARTIAL_REG_DEPENDENCY \
+				      (x86_sse_partial_reg_dependency & TUNEMASK)
+#define TARGET_SSE_PARTIAL_REGS (x86_sse_partial_regs & TUNEMASK)
+#define TARGET_SSE_PARTIAL_REGS_FOR_CVTSD2SS \
+				(x86_sse_partial_regs_for_cvtsd2ss & TUNEMASK)
+#define TARGET_SSE_TYPELESS_STORES (x86_sse_typeless_stores & TUNEMASK)
+#define TARGET_SSE_TYPELESS_LOAD0 (x86_sse_typeless_load0 & TUNEMASK)
+#define TARGET_SSE_LOAD0_BY_PXOR (x86_sse_load0_by_pxor & TUNEMASK)
+#define TARGET_MEMORY_MISMATCH_STALL (x86_memory_mismatch_stall & TUNEMASK)
+#define TARGET_PROLOGUE_USING_MOVE (x86_prologue_using_move & TUNEMASK)
+#define TARGET_EPILOGUE_USING_MOVE (x86_epilogue_using_move & TUNEMASK)
+#define TARGET_DECOMPOSE_LEA (x86_decompose_lea & TUNEMASK)
+#define TARGET_PREFETCH_SSE (x86_prefetch_sse)
+#define TARGET_SHIFT1 (x86_shift1 & TUNEMASK)
+#define TARGET_USE_FFREEP (x86_use_ffreep & TUNEMASK)
+#define TARGET_REP_MOVL_OPTIMAL (x86_rep_movl_optimal & TUNEMASK)
+#define TARGET_INTER_UNIT_MOVES (x86_inter_unit_moves & TUNEMASK)
+
+#define TARGET_STACK_PROBE (target_flags & MASK_STACK_PROBE)
+
+#define TARGET_ALIGN_STRINGOPS (!(target_flags & MASK_NO_ALIGN_STROPS))
+#define TARGET_INLINE_ALL_STRINGOPS (target_flags & MASK_INLINE_ALL_STROPS)
+
+#define ASSEMBLER_DIALECT (ix86_asm_dialect)
+
+#define TARGET_SSE ((target_flags & MASK_SSE) != 0)
+#define TARGET_SSE2 ((target_flags & MASK_SSE2) != 0)
+#define TARGET_SSE3 ((target_flags & MASK_SSE3) != 0)
+#define TARGET_SSE_MATH ((ix86_fpmath & FPMATH_SSE) != 0)
+#define TARGET_MIX_SSE_I387 ((ix86_fpmath & FPMATH_SSE) \
+			     && (ix86_fpmath & FPMATH_387))
+#define TARGET_MMX ((target_flags & MASK_MMX) != 0)
+#define TARGET_3DNOW ((target_flags & MASK_3DNOW) != 0)
+#define TARGET_3DNOW_A ((target_flags & MASK_3DNOW_A) != 0)
+
+#define TARGET_RED_ZONE (!(target_flags & MASK_NO_RED_ZONE))
+
+#define TARGET_USE_MS_BITFIELD_LAYOUT  (target_flags & MASK_MS_BITFIELD_LAYOUT)
+
+#define TARGET_GNU_TLS (ix86_tls_dialect == TLS_DIALECT_GNU)
+#define TARGET_SUN_TLS (ix86_tls_dialect == TLS_DIALECT_SUN)
+
+/* WARNING: Do not mark empty strings for translation, as calling
+            gettext on an empty string does NOT return an empty
+            string.  */
+
+
+#define TARGET_SWITCHES							      \
+{ { "80387",			 MASK_80387, N_("Use hardware fp") },	      \
+  { "no-80387",			-MASK_80387, N_("Do not use hardware fp") },  \
+  { "hard-float",		 MASK_80387, N_("Use hardware fp") },	      \
+  { "soft-float",		-MASK_80387, N_("Do not use hardware fp") },  \
+  { "no-soft-float",		 MASK_80387, N_("Use hardware fp") },	      \
+  { "386",			 0, "" /*Deprecated.*/},		      \
+  { "486",			 0, "" /*Deprecated.*/},		      \
+  { "pentium",			 0, "" /*Deprecated.*/},		      \
+  { "pentiumpro",		 0, "" /*Deprecated.*/},		      \
+  { "pni",			 0, "" /*Deprecated.*/},		      \
+  { "no-pni",			 0, "" /*Deprecated.*/},		      \
+  { "intel-syntax",		 0, "" /*Deprecated.*/},	 	      \
+  { "no-intel-syntax",		 0, "" /*Deprecated.*/},	 	      \
+  { "rtd",			 MASK_RTD,				      \
+    N_("Alternate calling convention") },				      \
+  { "no-rtd",			-MASK_RTD,				      \
+    N_("Use normal calling convention") },				      \
+  { "align-double",		 MASK_ALIGN_DOUBLE,			      \
+    N_("Align some doubles on dword boundary") },			      \
+  { "no-align-double",		-MASK_ALIGN_DOUBLE,			      \
+    N_("Align doubles on word boundary") },				      \
+  { "svr3-shlib",		 MASK_SVR3_SHLIB,			      \
+    N_("Uninitialized locals in .bss")  },				      \
+  { "no-svr3-shlib",		-MASK_SVR3_SHLIB,			      \
+    N_("Uninitialized locals in .data") },				      \
+  { "ieee-fp",			 MASK_IEEE_FP,				      \
+    N_("Use IEEE math for fp comparisons") },				      \
+  { "no-ieee-fp",		-MASK_IEEE_FP,				      \
+    N_("Do not use IEEE math for fp comparisons") },			      \
+  { "fp-ret-in-387",		 MASK_FLOAT_RETURNS,			      \
+    N_("Return values of functions in FPU registers") },		      \
+  { "no-fp-ret-in-387",		-MASK_FLOAT_RETURNS ,			      \
+    N_("Do not return values of functions in FPU registers")},		      \
+  { "no-fancy-math-387",	 MASK_NO_FANCY_MATH_387,		      \
+    N_("Do not generate sin, cos, sqrt for FPU") },			      \
+  { "fancy-math-387",		-MASK_NO_FANCY_MATH_387,		      \
+     N_("Generate sin, cos, sqrt for FPU")},				      \
+  { "omit-leaf-frame-pointer",	 MASK_OMIT_LEAF_FRAME_POINTER,		      \
+    N_("Omit the frame pointer in leaf functions") },			      \
+  { "no-omit-leaf-frame-pointer",-MASK_OMIT_LEAF_FRAME_POINTER, "" },	      \
+  { "stack-arg-probe",		 MASK_STACK_PROBE,			      \
+    N_("Enable stack probing") },					      \
+  { "no-stack-arg-probe",	-MASK_STACK_PROBE, "" },		      \
+  { "windows",			0, 0 /* undocumented */ },		      \
+  { "dll",			0,  0 /* undocumented */ },		      \
+  { "align-stringops",		-MASK_NO_ALIGN_STROPS,			      \
+    N_("Align destination of the string operations") },			      \
+  { "no-align-stringops",	 MASK_NO_ALIGN_STROPS,			      \
+    N_("Do not align destination of the string operations") },		      \
+  { "inline-all-stringops",	 MASK_INLINE_ALL_STROPS,		      \
+    N_("Inline all known string operations") },				      \
+  { "no-inline-all-stringops",	-MASK_INLINE_ALL_STROPS,		      \
+    N_("Do not inline all known string operations") },			      \
+  { "push-args",		-MASK_NO_PUSH_ARGS,			      \
+    N_("Use push instructions to save outgoing arguments") },		      \
+  { "no-push-args",		MASK_NO_PUSH_ARGS,			      \
+    N_("Do not use push instructions to save outgoing arguments") },	      \
+  { "accumulate-outgoing-args",	MASK_ACCUMULATE_OUTGOING_ARGS,		      \
+    N_("Use push instructions to save outgoing arguments") },		      \
+  { "no-accumulate-outgoing-args",-MASK_ACCUMULATE_OUTGOING_ARGS,	      \
+    N_("Do not use push instructions to save outgoing arguments") },	      \
+  { "mmx",			 MASK_MMX,				      \
+    N_("Support MMX built-in functions") },				      \
+  { "no-mmx",			 -MASK_MMX,				      \
+    N_("Do not support MMX built-in functions") },			      \
+  { "3dnow",                     MASK_3DNOW,				      \
+    N_("Support 3DNow! built-in functions") },				      \
+  { "no-3dnow",                  -MASK_3DNOW,				      \
+    N_("Do not support 3DNow! built-in functions") },			      \
+  { "sse",			 MASK_SSE,				      \
+    N_("Support MMX and SSE built-in functions and code generation") },	      \
+  { "no-sse",			 -MASK_SSE,				      \
+    N_("Do not support MMX and SSE built-in functions and code generation") },\
+  { "sse2",			 MASK_SSE2,				      \
+    N_("Support MMX, SSE and SSE2 built-in functions and code generation") }, \
+  { "no-sse2",			 -MASK_SSE2,				      \
+    N_("Do not support MMX, SSE and SSE2 built-in functions and code generation") },    \
+  { "sse3",			 MASK_SSE3,				      \
+    N_("Support MMX, SSE, SSE2 and SSE3 built-in functions and code generation") },\
+  { "no-sse3",			 -MASK_SSE3,				      \
+    N_("Do not support MMX, SSE, SSE2 and SSE3 built-in functions and code generation") },\
+  { "128bit-long-double",	 MASK_128BIT_LONG_DOUBLE,		      \
+    N_("sizeof(long double) is 16") },					      \
+  { "96bit-long-double",	-MASK_128BIT_LONG_DOUBLE,		      \
+    N_("sizeof(long double) is 12") },					      \
+  { "64",			MASK_64BIT,				      \
+    N_("Generate 64bit x86-64 code") },					      \
+  { "32",			-MASK_64BIT,				      \
+    N_("Generate 32bit i386 code") },					      \
+  { "ms-bitfields",		MASK_MS_BITFIELD_LAYOUT,		      \
+    N_("Use native (MS) bitfield layout") },				      \
+  { "no-ms-bitfields",		-MASK_MS_BITFIELD_LAYOUT,		      \
+    N_("Use gcc default bitfield layout") },				      \
+  { "red-zone",			-MASK_NO_RED_ZONE,			      \
+    N_("Use red-zone in the x86-64 code") },				      \
+  { "no-red-zone",		MASK_NO_RED_ZONE,			      \
+    N_("Do not use red-zone in the x86-64 code") },			      \
+  { "tls-direct-seg-refs",	MASK_TLS_DIRECT_SEG_REFS,		      \
+    N_("Use direct references against %gs when accessing tls data") },	      \
+  { "no-tls-direct-seg-refs",	-MASK_TLS_DIRECT_SEG_REFS,		      \
+    N_("Do not use direct references against %gs when accessing tls data") }, \
+  SUBTARGET_SWITCHES							      \
+  { "",									      \
+    TARGET_DEFAULT | TARGET_64BIT_DEFAULT | TARGET_SUBTARGET_DEFAULT	      \
+    | TARGET_TLS_DIRECT_SEG_REFS_DEFAULT, 0 }}
+
+#ifndef TARGET_64BIT_DEFAULT
+#define TARGET_64BIT_DEFAULT 0
+#endif
+#ifndef TARGET_TLS_DIRECT_SEG_REFS_DEFAULT
+#define TARGET_TLS_DIRECT_SEG_REFS_DEFAULT 0
+#endif
+
+/* Once GDB has been enhanced to deal with functions without frame
+   pointers, we can change this to allow for elimination of
+   the frame pointer in leaf functions.  */
+#define TARGET_DEFAULT 0
+
+/* This is not really a target flag, but is done this way so that
+   it's analogous to similar code for Mach-O on PowerPC.  darwin.h
+   redefines this to 1.  */
+#define TARGET_MACHO 0
+
+/* This macro is similar to `TARGET_SWITCHES' but defines names of
+   command options that have values.  Its definition is an
+   initializer with a subgrouping for each command option.
+
+   Each subgrouping contains a string constant, that defines the
+   fixed part of the option name, and the address of a variable.  The
+   variable, type `char *', is set to the variable part of the given
+   option if the fixed part matches.  The actual option name is made
+   by appending `-m' to the specified name.  */
+#define TARGET_OPTIONS						\
+{ { "tune=",		&ix86_tune_string,			\
+    N_("Schedule code for given CPU"), 0},			\
+  { "fpmath=",		&ix86_fpmath_string,			\
+    N_("Generate floating point mathematics using given instruction set"), 0},\
+  { "arch=",		&ix86_arch_string,			\
+    N_("Generate code for given CPU"), 0},			\
+  { "regparm=",		&ix86_regparm_string,			\
+    N_("Number of registers used to pass integer arguments"), 0},\
+  { "align-loops=",	&ix86_align_loops_string,		\
+    N_("Loop code aligned to this power of 2"), 0},		\
+  { "align-jumps=",	&ix86_align_jumps_string,		\
+    N_("Jump targets are aligned to this power of 2"), 0},	\
+  { "align-functions=",	&ix86_align_funcs_string,		\
+    N_("Function starts are aligned to this power of 2"), 0},	\
+  { "preferred-stack-boundary=",				\
+    &ix86_preferred_stack_boundary_string,			\
+    N_("Attempt to keep stack aligned to this power of 2"), 0},	\
+  { "branch-cost=",	&ix86_branch_cost_string,		\
+    N_("Branches are this expensive (1-5, arbitrary units)"), 0},\
+  { "cmodel=", &ix86_cmodel_string,				\
+    N_("Use given x86-64 code model"), 0},			\
+  { "debug-arg", &ix86_debug_arg_string,			\
+    "" /* Undocumented.  */, 0},				\
+  { "debug-addr", &ix86_debug_addr_string,			\
+    "" /* Undocumented.  */, 0},				\
+  { "asm=", &ix86_asm_string,					\
+    N_("Use given assembler dialect"), 0},			\
+  { "tls-dialect=", &ix86_tls_dialect_string,			\
+    N_("Use given thread-local storage dialect"), 0},		\
+  SUBTARGET_OPTIONS						\
+}
+
+/* Sometimes certain combinations of command options do not make
+   sense on a particular target machine.  You can define a macro
+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if
+   defined, is executed once just after all the command options have
+   been parsed.
+
+   Don't use this macro to turn on various extra optimizations for
+   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */
+
+#define OVERRIDE_OPTIONS override_options ()
+
+/* These are meant to be redefined in the host dependent files */
+#define SUBTARGET_SWITCHES
+#define SUBTARGET_OPTIONS
+
+/* Define this to change the optimizations performed by default.  */
+#define OPTIMIZATION_OPTIONS(LEVEL, SIZE) \
+  optimization_options ((LEVEL), (SIZE))
+
+/* Support for configure-time defaults of some command line options.  */
+#define OPTION_DEFAULT_SPECS \
+  {"arch", "%{!march=*:-march=%(VALUE)}"}, \
+  {"tune", "%{!mtune=*:%{!mcpu=*:%{!march=*:-mtune=%(VALUE)}}}" }, \
+  {"cpu", "%{!mtune=*:%{!mcpu=*:%{!march=*:-mtune=%(VALUE)}}}" }
+
+/* Specs for the compiler proper */
+
+#ifndef CC1_CPU_SPEC
+#define CC1_CPU_SPEC "\
+%{!mtune*: \
+%{m386:mtune=i386 \
+%n`-m386' is deprecated. Use `-march=i386' or `-mtune=i386' instead.\n} \
+%{m486:-mtune=i486 \
+%n`-m486' is deprecated. Use `-march=i486' or `-mtune=i486' instead.\n} \
+%{mpentium:-mtune=pentium \
+%n`-mpentium' is deprecated. Use `-march=pentium' or `-mtune=pentium' instead.\n} \
+%{mpentiumpro:-mtune=pentiumpro \
+%n`-mpentiumpro' is deprecated. Use `-march=pentiumpro' or `-mtune=pentiumpro' instead.\n} \
+%{mcpu=*:-mtune=%* \
+%n`-mcpu=' is deprecated. Use `-mtune=' or '-march=' instead.\n}} \
+%<mcpu=* \
+%{mpni:-msse3 \
+%n`-mpni' is deprecated. Use `-msse3' instead.\n} \
+%{mno-pni:-mno-sse3 \
+%n`-mno-pni' is deprecated. Use `-mno-sse3' instead.\n} \
+%{mintel-syntax:-masm=intel \
+%n`-mintel-syntax' is deprecated. Use `-masm=intel' instead.\n} \
+%{mno-intel-syntax:-masm=att \
+%n`-mno-intel-syntax' is deprecated. Use `-masm=att' instead.\n}"
+#endif
+
+/* Target CPU builtins.  */
+#define TARGET_CPU_CPP_BUILTINS()				\
+  do								\
+    {								\
+      size_t arch_len = strlen (ix86_arch_string);		\
+      size_t tune_len = strlen (ix86_tune_string);		\
+      int last_arch_char = ix86_arch_string[arch_len - 1];	\
+      int last_tune_char = ix86_tune_string[tune_len - 1];		\
+								\
+      if (TARGET_64BIT)						\
+	{							\
+	  builtin_assert ("cpu=x86_64");			\
+	  builtin_assert ("machine=x86_64");			\
+	  builtin_define ("__amd64");				\
+	  builtin_define ("__amd64__");				\
+	  builtin_define ("__x86_64");				\
+	  builtin_define ("__x86_64__");			\
+	}							\
+      else							\
+	{							\
+	  builtin_assert ("cpu=i386");				\
+	  builtin_assert ("machine=i386");			\
+	  builtin_define_std ("i386");				\
+	}							\
+								\
+      /* Built-ins based on -mtune= (or -march= if no		\
+	 -mtune= given).  */					\
+      if (TARGET_386)						\
+	builtin_define ("__tune_i386__");			\
+      else if (TARGET_486)					\
+	builtin_define ("__tune_i486__");			\
+      else if (TARGET_PENTIUM)					\
+	{							\
+	  builtin_define ("__tune_i586__");			\
+	  builtin_define ("__tune_pentium__");			\
+	  if (last_tune_char == 'x')				\
+	    builtin_define ("__tune_pentium_mmx__");		\
+	}							\
+      else if (TARGET_PENTIUMPRO)				\
+	{							\
+	  builtin_define ("__tune_i686__");			\
+	  builtin_define ("__tune_pentiumpro__");		\
+	  switch (last_tune_char)				\
+	    {							\
+	    case '3':						\
+	      builtin_define ("__tune_pentium3__");		\
+	      /* FALLTHRU */					\
+	    case '2':						\
+	      builtin_define ("__tune_pentium2__");		\
+	      break;						\
+	    }							\
+	}							\
+      else if (TARGET_K6)					\
+	{							\
+	  builtin_define ("__tune_k6__");			\
+	  if (last_tune_char == '2')				\
+	    builtin_define ("__tune_k6_2__");			\
+	  else if (last_tune_char == '3')			\
+	    builtin_define ("__tune_k6_3__");			\
+	}							\
+      else if (TARGET_ATHLON)					\
+	{							\
+	  builtin_define ("__tune_athlon__");			\
+	  /* Only plain "athlon" lacks SSE.  */			\
+	  if (last_tune_char != 'n')				\
+	    builtin_define ("__tune_athlon_sse__");		\
+	}							\
+      else if (TARGET_K8)					\
+	builtin_define ("__tune_k8__");				\
+      else if (TARGET_PENTIUM4)					\
+	builtin_define ("__tune_pentium4__");			\
+								\
+      if (TARGET_MMX)						\
+	builtin_define ("__MMX__");				\
+      if (TARGET_3DNOW)						\
+	builtin_define ("__3dNOW__");				\
+      if (TARGET_3DNOW_A)					\
+	builtin_define ("__3dNOW_A__");				\
+      if (TARGET_SSE)						\
+	builtin_define ("__SSE__");				\
+      if (TARGET_SSE2)						\
+	builtin_define ("__SSE2__");				\
+      if (TARGET_SSE3)						\
+	{							\
+	  builtin_define ("__SSE3__");				\
+	  builtin_define ("__PNI__");				\
+	}							\
+      if (TARGET_SSE_MATH && TARGET_SSE)			\
+	builtin_define ("__SSE_MATH__");			\
+      if (TARGET_SSE_MATH && TARGET_SSE2)			\
+	builtin_define ("__SSE2_MATH__");			\
+								\
+      /* Built-ins based on -march=.  */			\
+      if (ix86_arch == PROCESSOR_I486)				\
+	{							\
+	  builtin_define ("__i486");				\
+	  builtin_define ("__i486__");				\
+	}							\
+      else if (ix86_arch == PROCESSOR_PENTIUM)			\
+	{							\
+	  builtin_define ("__i586");				\
+	  builtin_define ("__i586__");				\
+	  builtin_define ("__pentium");				\
+	  builtin_define ("__pentium__");			\
+	  if (last_arch_char == 'x')				\
+	    builtin_define ("__pentium_mmx__");			\
+	}							\
+      else if (ix86_arch == PROCESSOR_PENTIUMPRO)		\
+	{							\
+	  builtin_define ("__i686");				\
+	  builtin_define ("__i686__");				\
+	  builtin_define ("__pentiumpro");			\
+	  builtin_define ("__pentiumpro__");			\
+	}							\
+      else if (ix86_arch == PROCESSOR_K6)			\
+	{							\
+								\
+	  builtin_define ("__k6");				\
+	  builtin_define ("__k6__");				\
+	  if (last_arch_char == '2')				\
+	    builtin_define ("__k6_2__");			\
+	  else if (last_arch_char == '3')			\
+	    builtin_define ("__k6_3__");			\
+	}							\
+      else if (ix86_arch == PROCESSOR_ATHLON)			\
+	{							\
+	  builtin_define ("__athlon");				\
+	  builtin_define ("__athlon__");			\
+	  /* Only plain "athlon" lacks SSE.  */			\
+	  if (last_arch_char != 'n')				\
+	    builtin_define ("__athlon_sse__");			\
+	}							\
+      else if (ix86_arch == PROCESSOR_K8)			\
+	{							\
+	  builtin_define ("__k8");				\
+	  builtin_define ("__k8__");				\
+	}							\
+      else if (ix86_arch == PROCESSOR_PENTIUM4)			\
+	{							\
+	  builtin_define ("__pentium4");			\
+	  builtin_define ("__pentium4__");			\
+	}							\
+    }								\
+  while (0)
+
+#define TARGET_CPU_DEFAULT_i386 0
+#define TARGET_CPU_DEFAULT_i486 1
+#define TARGET_CPU_DEFAULT_pentium 2
+#define TARGET_CPU_DEFAULT_pentium_mmx 3
+#define TARGET_CPU_DEFAULT_pentiumpro 4
+#define TARGET_CPU_DEFAULT_pentium2 5
+#define TARGET_CPU_DEFAULT_pentium3 6
+#define TARGET_CPU_DEFAULT_pentium4 7
+#define TARGET_CPU_DEFAULT_k6 8
+#define TARGET_CPU_DEFAULT_k6_2 9
+#define TARGET_CPU_DEFAULT_k6_3 10
+#define TARGET_CPU_DEFAULT_athlon 11
+#define TARGET_CPU_DEFAULT_athlon_sse 12
+#define TARGET_CPU_DEFAULT_k8 13
+
+#define TARGET_CPU_DEFAULT_NAMES {"i386", "i486", "pentium", "pentium-mmx",\
+				  "pentiumpro", "pentium2", "pentium3", \
+				  "pentium4", "k6", "k6-2", "k6-3",\
+				  "athlon", "athlon-4", "k8"}
+
+#ifndef CC1_SPEC
+#define CC1_SPEC "%(cc1_cpu) "
+#endif
+
+/* This macro defines names of additional specifications to put in the
+   specs that can be used in various specifications like CC1_SPEC.  Its
+   definition is an initializer with a subgrouping for each command option.
+
+   Each subgrouping contains a string constant, that defines the
+   specification name, and a string constant that used by the GCC driver
+   program.
+
+   Do not define this macro if it does not need to do anything.  */
+
+#ifndef SUBTARGET_EXTRA_SPECS
+#define SUBTARGET_EXTRA_SPECS
+#endif
+
+#define EXTRA_SPECS							\
+  { "cc1_cpu",  CC1_CPU_SPEC },						\
+  SUBTARGET_EXTRA_SPECS
+
+/* target machine storage layout */
+
+#define LONG_DOUBLE_TYPE_SIZE 96
+
+/* Set the value of FLT_EVAL_METHOD in float.h.  When using only the
+   FPU, assume that the fpcw is set to extended precision; when using
+   only SSE, rounding is correct; when using both SSE and the FPU,
+   the rounding precision is indeterminate, since either may be chosen
+   apparently at random.  */
+#define TARGET_FLT_EVAL_METHOD \
+  (TARGET_MIX_SSE_I387 ? -1 : TARGET_SSE_MATH ? 0 : 2)
+
+#define SHORT_TYPE_SIZE 16
+#define INT_TYPE_SIZE 32
+#define FLOAT_TYPE_SIZE 32
+#define LONG_TYPE_SIZE BITS_PER_WORD
+#define MAX_WCHAR_TYPE_SIZE 32
+#define DOUBLE_TYPE_SIZE 64
+#define LONG_LONG_TYPE_SIZE 64
+
+#if defined (TARGET_BI_ARCH) || TARGET_64BIT_DEFAULT
+#define MAX_BITS_PER_WORD 64
+#define MAX_LONG_TYPE_SIZE 64
+#else
+#define MAX_BITS_PER_WORD 32
+#define MAX_LONG_TYPE_SIZE 32
+#endif
+
+/* Define this if most significant byte of a word is the lowest numbered.  */
+/* That is true on the 80386.  */
+
+#define BITS_BIG_ENDIAN 0
+
+/* Define this if most significant byte of a word is the lowest numbered.  */
+/* That is not true on the 80386.  */
+#define BYTES_BIG_ENDIAN 0
+
+/* Define this if most significant word of a multiword number is the lowest
+   numbered.  */
+/* Not true for 80386 */
+#define WORDS_BIG_ENDIAN 0
+
+/* Width of a word, in units (bytes).  */
+#define UNITS_PER_WORD (TARGET_64BIT ? 8 : 4)
+#ifdef IN_LIBGCC2
+#define MIN_UNITS_PER_WORD	(TARGET_64BIT ? 8 : 4)
+#else
+#define MIN_UNITS_PER_WORD	4
+#endif
+
+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */
+#define PARM_BOUNDARY BITS_PER_WORD
+
+/* Boundary (in *bits*) on which stack pointer should be aligned.  */
+#define STACK_BOUNDARY BITS_PER_WORD
+
+/* Boundary (in *bits*) on which the stack pointer prefers to be
+   aligned; the compiler cannot rely on having this alignment.  */
+#define PREFERRED_STACK_BOUNDARY ix86_preferred_stack_boundary
+
+/* As of July 2001, many runtimes to not align the stack properly when
+   entering main.  This causes expand_main_function to forcibly align
+   the stack, which results in aligned frames for functions called from
+   main, though it does nothing for the alignment of main itself.  */
+#define FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN \
+  (ix86_preferred_stack_boundary > STACK_BOUNDARY && !TARGET_64BIT)
+
+/* Minimum allocation boundary for the code of a function.  */
+#define FUNCTION_BOUNDARY 8
+
+/* C++ stores the virtual bit in the lowest bit of function pointers.  */
+#define TARGET_PTRMEMFUNC_VBIT_LOCATION ptrmemfunc_vbit_in_pfn
+
+/* Alignment of field after `int : 0' in a structure.  */
+
+#define EMPTY_FIELD_BOUNDARY BITS_PER_WORD
+
+/* Minimum size in bits of the largest boundary to which any
+   and all fundamental data types supported by the hardware
+   might need to be aligned. No data type wants to be aligned
+   rounder than this.
+
+   Pentium+ prefers DFmode values to be aligned to 64 bit boundary
+   and Pentium Pro XFmode values at 128 bit boundaries.  */
+
+#define BIGGEST_ALIGNMENT 128
+
+/* Decide whether a variable of mode MODE should be 128 bit aligned.  */
+#define ALIGN_MODE_128(MODE) \
+ ((MODE) == XFmode || (MODE) == TFmode || SSE_REG_MODE_P (MODE))
+
+/* The published ABIs say that doubles should be aligned on word
+   boundaries, so lower the alignment for structure fields unless
+   -malign-double is set.  */
+
+/* ??? Blah -- this macro is used directly by libobjc.  Since it
+   supports no vector modes, cut out the complexity and fall back
+   on BIGGEST_FIELD_ALIGNMENT.  */
+#ifdef IN_TARGET_LIBS
+#ifdef __x86_64__
+#define BIGGEST_FIELD_ALIGNMENT 128
+#else
+#define BIGGEST_FIELD_ALIGNMENT 32
+#endif
+#else
+#define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \
+   x86_field_alignment (FIELD, COMPUTED)
+#endif
+
+/* If defined, a C expression to compute the alignment given to a
+   constant that is being placed in memory.  EXP is the constant
+   and ALIGN is the alignment that the object would ordinarily have.
+   The value of this macro is used instead of that alignment to align
+   the object.
+
+   If this macro is not defined, then ALIGN is used.
+
+   The typical use of this macro is to increase alignment for string
+   constants to be word aligned so that `strcpy' calls that copy
+   constants can be done inline.  */
+
+#define CONSTANT_ALIGNMENT(EXP, ALIGN) ix86_constant_alignment ((EXP), (ALIGN))
+
+/* If defined, a C expression to compute the alignment for a static
+   variable.  TYPE is the data type, and ALIGN is the alignment that
+   the object would ordinarily have.  The value of this macro is used
+   instead of that alignment to align the object.
+
+   If this macro is not defined, then ALIGN is used.
+
+   One use of this macro is to increase alignment of medium-size
+   data to make it all fit in fewer cache lines.  Another is to
+   cause character arrays to be word-aligned so that `strcpy' calls
+   that copy constants to character arrays can be done inline.  */
+
+#define DATA_ALIGNMENT(TYPE, ALIGN) ix86_data_alignment ((TYPE), (ALIGN))
+
+/* If defined, a C expression to compute the alignment for a local
+   variable.  TYPE is the data type, and ALIGN is the alignment that
+   the object would ordinarily have.  The value of this macro is used
+   instead of that alignment to align the object.
+
+   If this macro is not defined, then ALIGN is used.
+
+   One use of this macro is to increase alignment of medium-size
+   data to make it all fit in fewer cache lines.  */
+
+#define LOCAL_ALIGNMENT(TYPE, ALIGN) ix86_local_alignment ((TYPE), (ALIGN))
+
+/* If defined, a C expression that gives the alignment boundary, in
+   bits, of an argument with the specified mode and type.  If it is
+   not defined, `PARM_BOUNDARY' is used for all arguments.  */
+
+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \
+  ix86_function_arg_boundary ((MODE), (TYPE))
+
+/* Set this nonzero if move instructions will actually fail to work
+   when given unaligned data.  */
+#define STRICT_ALIGNMENT 0
+
+/* If bit field type is int, don't let it cross an int,
+   and give entire struct the alignment of an int.  */
+/* Required on the 386 since it doesn't have bit-field insns.  */
+#define PCC_BITFIELD_TYPE_MATTERS 1
+
+/* Standard register usage.  */
+
+/* This processor has special stack-like registers.  See reg-stack.c
+   for details.  */
+
+#define STACK_REGS
+#define IS_STACK_MODE(MODE)					\
+  ((MODE) == DFmode || (MODE) == SFmode || (MODE) == XFmode)	\
+
+/* Number of actual hardware registers.
+   The hardware registers are assigned numbers for the compiler
+   from 0 to just below FIRST_PSEUDO_REGISTER.
+   All registers that the compiler knows about must be given numbers,
+   even those that are not normally considered general registers.
+
+   In the 80386 we give the 8 general purpose registers the numbers 0-7.
+   We number the floating point registers 8-15.
+   Note that registers 0-7 can be accessed as a  short or int,
+   while only 0-3 may be used with byte `mov' instructions.
+
+   Reg 16 does not correspond to any hardware register, but instead
+   appears in the RTL as an argument pointer prior to reload, and is
+   eliminated during reloading in favor of either the stack or frame
+   pointer.  */
+
+#define FIRST_PSEUDO_REGISTER 53
+
+/* Number of hardware registers that go into the DWARF-2 unwind info.
+   If not defined, equals FIRST_PSEUDO_REGISTER.  */
+
+#define DWARF_FRAME_REGISTERS 17
+
+/* 1 for registers that have pervasive standard uses
+   and are not available for the register allocator.
+   On the 80386, the stack pointer is such, as is the arg pointer.
+
+   The value is a mask - bit 1 is set for fixed registers
+   for 32bit target, while 2 is set for fixed registers for 64bit.
+   Proper value is computed in the CONDITIONAL_REGISTER_USAGE.
+ */
+#define FIXED_REGISTERS						\
+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7*/	\
+{  0, 0, 0, 0, 0, 0, 0, 3, 0,  0,  0,  0,  0,  0,  0,  0,	\
+/*arg,flags,fpsr,dir,frame*/					\
+    3,    3,   3,  3,    3,					\
+/*xmm0,xmm1,xmm2,xmm3,xmm4,xmm5,xmm6,xmm7*/			\
+     0,   0,   0,   0,   0,   0,   0,   0,			\
+/*mmx0,mmx1,mmx2,mmx3,mmx4,mmx5,mmx6,mmx7*/			\
+     0,   0,   0,   0,   0,   0,   0,   0,			\
+/*  r8,  r9, r10, r11, r12, r13, r14, r15*/			\
+     1,   1,   1,   1,   1,   1,   1,   1,			\
+/*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/		\
+     1,   1,    1,    1,    1,    1,    1,    1}
+
+
+/* 1 for registers not available across function calls.
+   These must include the FIXED_REGISTERS and also any
+   registers that can be used without being saved.
+   The latter must include the registers where values are returned
+   and the register where structure-value addresses are passed.
+   Aside from that, you can include as many other registers as you like.
+
+   The value is a mask - bit 1 is set for call used
+   for 32bit target, while 2 is set for call used for 64bit.
+   Proper value is computed in the CONDITIONAL_REGISTER_USAGE.
+*/
+#define CALL_USED_REGISTERS					\
+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7*/	\
+{  3, 3, 3, 0, 2, 2, 0, 3, 3,  3,  3,  3,  3,  3,  3,  3,	\
+/*arg,flags,fpsr,dir,frame*/					\
+     3,   3,   3,  3,    3,					\
+/*xmm0,xmm1,xmm2,xmm3,xmm4,xmm5,xmm6,xmm7*/			\
+     3,   3,   3,   3,   3,  3,    3,   3,			\
+/*mmx0,mmx1,mmx2,mmx3,mmx4,mmx5,mmx6,mmx7*/			\
+     3,   3,   3,   3,   3,   3,   3,   3,			\
+/*  r8,  r9, r10, r11, r12, r13, r14, r15*/			\
+     3,   3,   3,   3,   1,   1,   1,   1,			\
+/*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/		\
+     3,   3,    3,    3,    3,    3,    3,    3}		\
+
+/* Order in which to allocate registers.  Each register must be
+   listed once, even those in FIXED_REGISTERS.  List frame pointer
+   late and fixed registers last.  Note that, in general, we prefer
+   registers listed in CALL_USED_REGISTERS, keeping the others
+   available for storage of persistent values.
+
+   The ORDER_REGS_FOR_LOCAL_ALLOC actually overwrite the order,
+   so this is just empty initializer for array.  */
+
+#define REG_ALLOC_ORDER 					\
+{  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,\
+   18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,	\
+   33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,  \
+   48, 49, 50, 51, 52 }
+
+/* ORDER_REGS_FOR_LOCAL_ALLOC is a macro which permits reg_alloc_order
+   to be rearranged based on a particular function.  When using sse math,
+   we want to allocate SSE before x87 registers and vice vera.  */
+
+#define ORDER_REGS_FOR_LOCAL_ALLOC x86_order_regs_for_local_alloc ()
+
+
+/* Macro to conditionally modify fixed_regs/call_used_regs.  */
+#define CONDITIONAL_REGISTER_USAGE					\
+do {									\
+    int i;								\
+    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)				\
+      {									\
+        fixed_regs[i] = (fixed_regs[i] & (TARGET_64BIT ? 2 : 1)) != 0;	\
+        call_used_regs[i] = (call_used_regs[i]				\
+			     & (TARGET_64BIT ? 2 : 1)) != 0;		\
+      }									\
+    if (PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)			\
+      {									\
+	fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;			\
+	call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;			\
+      }									\
+    if (! TARGET_MMX)							\
+      {									\
+	int i;								\
+        for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)			\
+          if (TEST_HARD_REG_BIT (reg_class_contents[(int)MMX_REGS], i))	\
+	    fixed_regs[i] = call_used_regs[i] = 1;		 	\
+      }									\
+    if (! TARGET_SSE)							\
+      {									\
+	int i;								\
+        for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)			\
+          if (TEST_HARD_REG_BIT (reg_class_contents[(int)SSE_REGS], i))	\
+	    fixed_regs[i] = call_used_regs[i] = 1;		 	\
+      }									\
+    if (! TARGET_80387 && ! TARGET_FLOAT_RETURNS_IN_80387)		\
+      {									\
+	int i;								\
+	HARD_REG_SET x;							\
+        COPY_HARD_REG_SET (x, reg_class_contents[(int)FLOAT_REGS]);	\
+        for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)			\
+          if (TEST_HARD_REG_BIT (x, i)) 				\
+	    fixed_regs[i] = call_used_regs[i] = 1;			\
+      }									\
+  } while (0)
+
+/* Return number of consecutive hard regs needed starting at reg REGNO
+   to hold something of mode MODE.
+   This is ordinarily the length in words of a value of mode MODE
+   but can be less for certain modes in special long registers.
+
+   Actually there are no two word move instructions for consecutive
+   registers.  And only registers 0-3 may have mov byte instructions
+   applied to them.
+   */
+
+#define HARD_REGNO_NREGS(REGNO, MODE)   \
+  (FP_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO)	\
+   ? (COMPLEX_MODE_P (MODE) ? 2 : 1)					\
+   : ((MODE) == XFmode							\
+      ? (TARGET_64BIT ? 2 : 3)						\
+      : (MODE) == XCmode						\
+      ? (TARGET_64BIT ? 4 : 6)						\
+      : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))
+
+#define VALID_SSE2_REG_MODE(MODE) \
+    ((MODE) == V16QImode || (MODE) == V8HImode || (MODE) == V2DFmode    \
+     || (MODE) == V2DImode)
+
+#define VALID_SSE_REG_MODE(MODE)					\
+    ((MODE) == TImode || (MODE) == V4SFmode || (MODE) == V4SImode	\
+     || (MODE) == SFmode || (MODE) == TFmode				\
+     /* Always accept SSE2 modes so that xmmintrin.h compiles.  */	\
+     || VALID_SSE2_REG_MODE (MODE)					\
+     || (TARGET_SSE2 && ((MODE) == DFmode || VALID_MMX_REG_MODE (MODE))))
+
+#define VALID_MMX_REG_MODE_3DNOW(MODE) \
+    ((MODE) == V2SFmode || (MODE) == SFmode)
+
+#define VALID_MMX_REG_MODE(MODE)					\
+    ((MODE) == DImode || (MODE) == V8QImode || (MODE) == V4HImode	\
+     || (MODE) == V2SImode || (MODE) == SImode)
+
+#define VECTOR_MODE_SUPPORTED_P(MODE)					\
+    (VALID_SSE_REG_MODE (MODE) && TARGET_SSE ? 1			\
+     : VALID_MMX_REG_MODE (MODE) && TARGET_MMX ? 1			\
+     : VALID_MMX_REG_MODE_3DNOW (MODE) && TARGET_3DNOW ? 1 : 0)
+
+#define VALID_FP_MODE_P(MODE)						\
+    ((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode		\
+     || (MODE) == SCmode || (MODE) == DCmode || (MODE) == XCmode)	\
+
+#define VALID_INT_MODE_P(MODE)						\
+    ((MODE) == QImode || (MODE) == HImode || (MODE) == SImode		\
+     || (MODE) == DImode						\
+     || (MODE) == CQImode || (MODE) == CHImode || (MODE) == CSImode	\
+     || (MODE) == CDImode						\
+     || (TARGET_64BIT && ((MODE) == TImode || (MODE) == CTImode		\
+         || (MODE) == TFmode || (MODE) == TCmode)))
+
+/* Return true for modes passed in SSE registers.  */
+#define SSE_REG_MODE_P(MODE) \
+ ((MODE) == TImode || (MODE) == V16QImode || (MODE) == TFmode		\
+   || (MODE) == V8HImode || (MODE) == V2DFmode || (MODE) == V2DImode	\
+   || (MODE) == V4SFmode || (MODE) == V4SImode)
+
+/* Return true for modes passed in MMX registers.  */
+#define MMX_REG_MODE_P(MODE) \
+ ((MODE) == V8QImode || (MODE) == V4HImode || (MODE) == V2SImode	\
+   || (MODE) == V2SFmode)
+
+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */
+
+#define HARD_REGNO_MODE_OK(REGNO, MODE)	\
+   ix86_hard_regno_mode_ok ((REGNO), (MODE))
+
+/* Value is 1 if it is a good idea to tie two pseudo registers
+   when one has mode MODE1 and one has mode MODE2.
+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,
+   for any hard reg, then this must be 0 for correct output.  */
+
+#define MODES_TIEABLE_P(MODE1, MODE2)				\
+  ((MODE1) == (MODE2)						\
+   || (((MODE1) == HImode || (MODE1) == SImode			\
+	|| ((MODE1) == QImode					\
+	    && (TARGET_64BIT || !TARGET_PARTIAL_REG_STALL))	\
+        || ((MODE1) == DImode && TARGET_64BIT))			\
+       && ((MODE2) == HImode || (MODE2) == SImode		\
+	   || ((MODE2) == QImode				\
+	       && (TARGET_64BIT || !TARGET_PARTIAL_REG_STALL))	\
+	   || ((MODE2) == DImode && TARGET_64BIT))))
+
+/* It is possible to write patterns to move flags; but until someone
+   does it,  */
+#define AVOID_CCMODE_COPIES
+
+/* Specify the modes required to caller save a given hard regno.
+   We do this on i386 to prevent flags from being saved at all.
+
+   Kill any attempts to combine saving of modes.  */
+
+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE)			\
+  (CC_REGNO_P (REGNO) ? VOIDmode					\
+   : (MODE) == VOIDmode && (NREGS) != 1 ? VOIDmode			\
+   : (MODE) == VOIDmode ? choose_hard_reg_mode ((REGNO), (NREGS), false)\
+   : (MODE) == HImode && !TARGET_PARTIAL_REG_STALL ? SImode		\
+   : (MODE) == QImode && (REGNO) >= 4 && !TARGET_64BIT ? SImode 	\
+   : (MODE))
+/* Specify the registers used for certain standard purposes.
+   The values of these macros are register numbers.  */
+
+/* on the 386 the pc register is %eip, and is not usable as a general
+   register.  The ordinary mov instructions won't work */
+/* #define PC_REGNUM  */
+
+/* Register to use for pushing function arguments.  */
+#define STACK_POINTER_REGNUM 7
+
+/* Base register for access to local variables of the function.  */
+#define HARD_FRAME_POINTER_REGNUM 6
+
+/* Base register for access to local variables of the function.  */
+#define FRAME_POINTER_REGNUM 20
+
+/* First floating point reg */
+#define FIRST_FLOAT_REG 8
+
+/* First & last stack-like regs */
+#define FIRST_STACK_REG FIRST_FLOAT_REG
+#define LAST_STACK_REG (FIRST_FLOAT_REG + 7)
+
+#define FLAGS_REG 17
+#define FPSR_REG 18
+#define DIRFLAG_REG 19
+
+#define FIRST_SSE_REG (FRAME_POINTER_REGNUM + 1)
+#define LAST_SSE_REG  (FIRST_SSE_REG + 7)
+
+#define FIRST_MMX_REG  (LAST_SSE_REG + 1)
+#define LAST_MMX_REG   (FIRST_MMX_REG + 7)
+
+#define FIRST_REX_INT_REG  (LAST_MMX_REG + 1)
+#define LAST_REX_INT_REG   (FIRST_REX_INT_REG + 7)
+
+#define FIRST_REX_SSE_REG  (LAST_REX_INT_REG + 1)
+#define LAST_REX_SSE_REG   (FIRST_REX_SSE_REG + 7)
+
+/* Value should be nonzero if functions must have frame pointers.
+   Zero means the frame pointer need not be set up (and parms
+   may be accessed via the stack pointer) in functions that seem suitable.
+   This is computed in `reload', in reload1.c.  */
+#define FRAME_POINTER_REQUIRED  ix86_frame_pointer_required ()
+
+/* Override this in other tm.h files to cope with various OS losage
+   requiring a frame pointer.  */
+#ifndef SUBTARGET_FRAME_POINTER_REQUIRED
+#define SUBTARGET_FRAME_POINTER_REQUIRED 0
+#endif
+
+/* Make sure we can access arbitrary call frames.  */
+#define SETUP_FRAME_ADDRESSES()  ix86_setup_frame_addresses ()
+
+/* Base register for access to arguments of the function.  */
+#define ARG_POINTER_REGNUM 16
+
+/* Register in which static-chain is passed to a function.
+   We do use ECX as static chain register for 32 bit ABI.  On the
+   64bit ABI, ECX is an argument register, so we use R10 instead.  */
+#define STATIC_CHAIN_REGNUM (TARGET_64BIT ? FIRST_REX_INT_REG + 10 - 8 : 2)
+
+/* Register to hold the addressing base for position independent
+   code access to data items.  We don't use PIC pointer for 64bit
+   mode.  Define the regnum to dummy value to prevent gcc from
+   pessimizing code dealing with EBX.
+
+   To avoid clobbering a call-saved register unnecessarily, we renumber
+   the pic register when possible.  The change is visible after the
+   prologue has been emitted.  */
+
+#define REAL_PIC_OFFSET_TABLE_REGNUM  3
+
+#define PIC_OFFSET_TABLE_REGNUM				\
+  (TARGET_64BIT || !flag_pic ? INVALID_REGNUM		\
+   : reload_completed ? REGNO (pic_offset_table_rtx)	\
+   : REAL_PIC_OFFSET_TABLE_REGNUM)
+
+#define GOT_SYMBOL_NAME "_GLOBAL_OFFSET_TABLE_"
+
+/* Register in which address to store a structure value
+   arrives in the function.  On the 386, the prologue
+   copies this from the stack to register %eax.  */
+#define STRUCT_VALUE_INCOMING 0
+
+/* Place in which caller passes the structure value address.
+   0 means push the value on the stack like an argument.  */
+#define STRUCT_VALUE 0
+
+/* A C expression which can inhibit the returning of certain function
+   values in registers, based on the type of value.  A nonzero value
+   says to return the function value in memory, just as large
+   structures are always returned.  Here TYPE will be a C expression
+   of type `tree', representing the data type of the value.
+
+   Note that values of mode `BLKmode' must be explicitly handled by
+   this macro.  Also, the option `-fpcc-struct-return' takes effect
+   regardless of this macro.  On most systems, it is possible to
+   leave the macro undefined; this causes a default definition to be
+   used, whose value is the constant 1 for `BLKmode' values, and 0
+   otherwise.
+
+   Do not use this macro to indicate that structures and unions
+   should always be returned in memory.  You should instead use
+   `DEFAULT_PCC_STRUCT_RETURN' to indicate this.  */
+
+#define RETURN_IN_MEMORY(TYPE) \
+  ix86_return_in_memory (TYPE)
+
+/* This is overridden by <cygwin.h>.  */
+#define MS_AGGREGATE_RETURN 0
+
+
+/* Define the classes of registers for register constraints in the
+   machine description.  Also define ranges of constants.
+
+   One of the classes must always be named ALL_REGS and include all hard regs.
+   If there is more than one class, another class must be named NO_REGS
+   and contain no registers.
+
+   The name GENERAL_REGS must be the name of a class (or an alias for
+   another name such as ALL_REGS).  This is the class of registers
+   that is allowed by "g" or "r" in a register constraint.
+   Also, registers outside this class are allocated only when
+   instructions express preferences for them.
+
+   The classes must be numbered in nondecreasing order; that is,
+   a larger-numbered class must never be contained completely
+   in a smaller-numbered class.
+
+   For any two classes, it is very desirable that there be another
+   class that represents their union.
+
+   It might seem that class BREG is unnecessary, since no useful 386
+   opcode needs reg %ebx.  But some systems pass args to the OS in ebx,
+   and the "b" register constraint is useful in asms for syscalls.
+
+   The flags and fpsr registers are in no class.  */
+
+enum reg_class
+{
+  NO_REGS,
+  AREG, DREG, CREG, BREG, SIREG, DIREG,
+  AD_REGS,			/* %eax/%edx for DImode */
+  Q_REGS,			/* %eax %ebx %ecx %edx */
+  NON_Q_REGS,			/* %esi %edi %ebp %esp */
+  INDEX_REGS,			/* %eax %ebx %ecx %edx %esi %edi %ebp */
+  LEGACY_REGS,			/* %eax %ebx %ecx %edx %esi %edi %ebp %esp */
+  GENERAL_REGS,			/* %eax %ebx %ecx %edx %esi %edi %ebp %esp %r8 - %r15*/
+  FP_TOP_REG, FP_SECOND_REG,	/* %st(0) %st(1) */
+  FLOAT_REGS,
+  SSE_REGS,
+  MMX_REGS,
+  FP_TOP_SSE_REGS,
+  FP_SECOND_SSE_REGS,
+  FLOAT_SSE_REGS,
+  FLOAT_INT_REGS,
+  INT_SSE_REGS,
+  FLOAT_INT_SSE_REGS,
+  ALL_REGS, LIM_REG_CLASSES
+};
+
+#define N_REG_CLASSES ((int) LIM_REG_CLASSES)
+
+#define INTEGER_CLASS_P(CLASS) \
+  reg_class_subset_p ((CLASS), GENERAL_REGS)
+#define FLOAT_CLASS_P(CLASS) \
+  reg_class_subset_p ((CLASS), FLOAT_REGS)
+#define SSE_CLASS_P(CLASS) \
+  reg_class_subset_p ((CLASS), SSE_REGS)
+#define MMX_CLASS_P(CLASS) \
+  reg_class_subset_p ((CLASS), MMX_REGS)
+#define MAYBE_INTEGER_CLASS_P(CLASS) \
+  reg_classes_intersect_p ((CLASS), GENERAL_REGS)
+#define MAYBE_FLOAT_CLASS_P(CLASS) \
+  reg_classes_intersect_p ((CLASS), FLOAT_REGS)
+#define MAYBE_SSE_CLASS_P(CLASS) \
+  reg_classes_intersect_p (SSE_REGS, (CLASS))
+#define MAYBE_MMX_CLASS_P(CLASS) \
+  reg_classes_intersect_p (MMX_REGS, (CLASS))
+
+#define Q_CLASS_P(CLASS) \
+  reg_class_subset_p ((CLASS), Q_REGS)
+
+/* Give names of register classes as strings for dump file.  */
+
+#define REG_CLASS_NAMES \
+{  "NO_REGS",				\
+   "AREG", "DREG", "CREG", "BREG",	\
+   "SIREG", "DIREG",			\
+   "AD_REGS",				\
+   "Q_REGS", "NON_Q_REGS",		\
+   "INDEX_REGS",			\
+   "LEGACY_REGS",			\
+   "GENERAL_REGS",			\
+   "FP_TOP_REG", "FP_SECOND_REG",	\
+   "FLOAT_REGS",			\
+   "SSE_REGS",				\
+   "MMX_REGS",				\
+   "FP_TOP_SSE_REGS",			\
+   "FP_SECOND_SSE_REGS",		\
+   "FLOAT_SSE_REGS",			\
+   "FLOAT_INT_REGS",			\
+   "INT_SSE_REGS",			\
+   "FLOAT_INT_SSE_REGS",		\
+   "ALL_REGS" }
+
+/* Define which registers fit in which classes.
+   This is an initializer for a vector of HARD_REG_SET
+   of length N_REG_CLASSES.  */
+
+#define REG_CLASS_CONTENTS						\
+{     { 0x00,     0x0 },						\
+      { 0x01,     0x0 }, { 0x02, 0x0 },	/* AREG, DREG */		\
+      { 0x04,     0x0 }, { 0x08, 0x0 },	/* CREG, BREG */		\
+      { 0x10,     0x0 }, { 0x20, 0x0 },	/* SIREG, DIREG */		\
+      { 0x03,     0x0 },		/* AD_REGS */			\
+      { 0x0f,     0x0 },		/* Q_REGS */			\
+  { 0x1100f0,  0x1fe0 },		/* NON_Q_REGS */		\
+      { 0x7f,  0x1fe0 },		/* INDEX_REGS */		\
+  { 0x1100ff,  0x0 },			/* LEGACY_REGS */		\
+  { 0x1100ff,  0x1fe0 },		/* GENERAL_REGS */		\
+     { 0x100,     0x0 }, { 0x0200, 0x0 },/* FP_TOP_REG, FP_SECOND_REG */\
+    { 0xff00,     0x0 },		/* FLOAT_REGS */		\
+{ 0x1fe00000,0x1fe000 },		/* SSE_REGS */			\
+{ 0xe0000000,    0x1f },		/* MMX_REGS */			\
+{ 0x1fe00100,0x1fe000 },		/* FP_TOP_SSE_REG */		\
+{ 0x1fe00200,0x1fe000 },		/* FP_SECOND_SSE_REG */		\
+{ 0x1fe0ff00,0x1fe000 },		/* FLOAT_SSE_REGS */		\
+   { 0x1ffff,  0x1fe0 },		/* FLOAT_INT_REGS */		\
+{ 0x1fe100ff,0x1fffe0 },		/* INT_SSE_REGS */		\
+{ 0x1fe1ffff,0x1fffe0 },		/* FLOAT_INT_SSE_REGS */	\
+{ 0xffffffff,0x1fffff }							\
+}
+
+/* The same information, inverted:
+   Return the class number of the smallest class containing
+   reg number REGNO.  This could be a conditional expression
+   or could index an array.  */
+
+#define REGNO_REG_CLASS(REGNO) (regclass_map[REGNO])
+
+/* When defined, the compiler allows registers explicitly used in the
+   rtl to be used as spill registers but prevents the compiler from
+   extending the lifetime of these registers.  */
+
+#define SMALL_REGISTER_CLASSES 1
+
+#define QI_REG_P(X) \
+  (REG_P (X) && REGNO (X) < 4)
+
+#define GENERAL_REGNO_P(N) \
+  ((N) < 8 || REX_INT_REGNO_P (N))
+
+#define GENERAL_REG_P(X) \
+  (REG_P (X) && GENERAL_REGNO_P (REGNO (X)))
+
+#define ANY_QI_REG_P(X) (TARGET_64BIT ? GENERAL_REG_P(X) : QI_REG_P (X))
+
+#define NON_QI_REG_P(X) \
+  (REG_P (X) && REGNO (X) >= 4 && REGNO (X) < FIRST_PSEUDO_REGISTER)
+
+#define REX_INT_REGNO_P(N) ((N) >= FIRST_REX_INT_REG && (N) <= LAST_REX_INT_REG)
+#define REX_INT_REG_P(X) (REG_P (X) && REX_INT_REGNO_P (REGNO (X)))
+
+#define FP_REG_P(X) (REG_P (X) && FP_REGNO_P (REGNO (X)))
+#define FP_REGNO_P(N) ((N) >= FIRST_STACK_REG && (N) <= LAST_STACK_REG)
+#define ANY_FP_REG_P(X) (REG_P (X) && ANY_FP_REGNO_P (REGNO (X)))
+#define ANY_FP_REGNO_P(N) (FP_REGNO_P (N) || SSE_REGNO_P (N))
+
+#define SSE_REGNO_P(N) \
+  (((N) >= FIRST_SSE_REG && (N) <= LAST_SSE_REG) \
+   || ((N) >= FIRST_REX_SSE_REG && (N) <= LAST_REX_SSE_REG))
+
+#define REX_SSE_REGNO_P(N) \
+   ((N) >= FIRST_REX_SSE_REG && (N) <= LAST_REX_SSE_REG)
+
+#define SSE_REGNO(N) \
+  ((N) < 8 ? FIRST_SSE_REG + (N) : FIRST_REX_SSE_REG + (N) - 8)
+#define SSE_REG_P(N) (REG_P (N) && SSE_REGNO_P (REGNO (N)))
+
+#define SSE_FLOAT_MODE_P(MODE) \
+  ((TARGET_SSE && (MODE) == SFmode) || (TARGET_SSE2 && (MODE) == DFmode))
+
+#define MMX_REGNO_P(N) ((N) >= FIRST_MMX_REG && (N) <= LAST_MMX_REG)
+#define MMX_REG_P(XOP) (REG_P (XOP) && MMX_REGNO_P (REGNO (XOP)))
+
+#define STACK_REG_P(XOP)		\
+  (REG_P (XOP) &&		       	\
+   REGNO (XOP) >= FIRST_STACK_REG &&	\
+   REGNO (XOP) <= LAST_STACK_REG)
+
+#define NON_STACK_REG_P(XOP) (REG_P (XOP) && ! STACK_REG_P (XOP))
+
+#define STACK_TOP_P(XOP) (REG_P (XOP) && REGNO (XOP) == FIRST_STACK_REG)
+
+#define CC_REG_P(X) (REG_P (X) && CC_REGNO_P (REGNO (X)))
+#define CC_REGNO_P(X) ((X) == FLAGS_REG || (X) == FPSR_REG)
+
+/* The class value for index registers, and the one for base regs.  */
+
+#define INDEX_REG_CLASS INDEX_REGS
+#define BASE_REG_CLASS GENERAL_REGS
+
+/* Get reg_class from a letter such as appears in the machine description.  */
+
+#define REG_CLASS_FROM_LETTER(C)	\
+  ((C) == 'r' ? GENERAL_REGS :					\
+   (C) == 'R' ? LEGACY_REGS :					\
+   (C) == 'q' ? TARGET_64BIT ? GENERAL_REGS : Q_REGS :		\
+   (C) == 'Q' ? Q_REGS :					\
+   (C) == 'f' ? (TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387	\
+		 ? FLOAT_REGS					\
+		 : NO_REGS) :					\
+   (C) == 't' ? (TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387	\
+		 ? FP_TOP_REG					\
+		 : NO_REGS) :					\
+   (C) == 'u' ? (TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387	\
+		 ? FP_SECOND_REG				\
+		 : NO_REGS) :					\
+   (C) == 'a' ? AREG :						\
+   (C) == 'b' ? BREG :						\
+   (C) == 'c' ? CREG :						\
+   (C) == 'd' ? DREG :						\
+   (C) == 'x' ? TARGET_SSE ? SSE_REGS : NO_REGS :		\
+   (C) == 'Y' ? TARGET_SSE2? SSE_REGS : NO_REGS :		\
+   (C) == 'y' ? TARGET_MMX ? MMX_REGS : NO_REGS :		\
+   (C) == 'A' ? AD_REGS :					\
+   (C) == 'D' ? DIREG :						\
+   (C) == 'S' ? SIREG : NO_REGS)
+
+/* The letters I, J, K, L and M in a register constraint string
+   can be used to stand for particular ranges of immediate operands.
+   This macro defines what the ranges are.
+   C is the letter, and VALUE is a constant value.
+   Return 1 if VALUE is in the range specified by C.
+
+   I is for non-DImode shifts.
+   J is for DImode shifts.
+   K is for signed imm8 operands.
+   L is for andsi as zero-extending move.
+   M is for shifts that can be executed by the "lea" opcode.
+   N is for immediate operands for out/in instructions (0-255)
+   */
+
+#define CONST_OK_FOR_LETTER_P(VALUE, C)				\
+  ((C) == 'I' ? (VALUE) >= 0 && (VALUE) <= 31			\
+   : (C) == 'J' ? (VALUE) >= 0 && (VALUE) <= 63			\
+   : (C) == 'K' ? (VALUE) >= -128 && (VALUE) <= 127		\
+   : (C) == 'L' ? (VALUE) == 0xff || (VALUE) == 0xffff		\
+   : (C) == 'M' ? (VALUE) >= 0 && (VALUE) <= 3			\
+   : (C) == 'N' ? (VALUE) >= 0 && (VALUE) <= 255		\
+   : 0)
+
+/* Similar, but for floating constants, and defining letters G and H.
+   Here VALUE is the CONST_DOUBLE rtx itself.  We allow constants even if
+   TARGET_387 isn't set, because the stack register converter may need to
+   load 0.0 into the function value register.  */
+
+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \
+  ((C) == 'G' ? standard_80387_constant_p (VALUE) \
+   : 0)
+
+/* A C expression that defines the optional machine-dependent
+   constraint letters that can be used to segregate specific types of
+   operands, usually memory references, for the target machine.  Any
+   letter that is not elsewhere defined and not matched by
+   `REG_CLASS_FROM_LETTER' may be used.  Normally this macro will not
+   be defined.
+
+   If it is required for a particular target machine, it should
+   return 1 if VALUE corresponds to the operand type represented by
+   the constraint letter C.  If C is not defined as an extra
+   constraint, the value returned should be 0 regardless of VALUE.  */
+
+#define EXTRA_CONSTRAINT(VALUE, D)				\
+  ((D) == 'e' ? x86_64_sign_extended_value (VALUE)		\
+   : (D) == 'Z' ? x86_64_zero_extended_value (VALUE)		\
+   : (D) == 'C' ? standard_sse_constant_p (VALUE)		\
+   : 0)
+
+/* Place additional restrictions on the register class to use when it
+   is necessary to be able to hold a value of mode MODE in a reload
+   register for which class CLASS would ordinarily be used.  */
+
+#define LIMIT_RELOAD_CLASS(MODE, CLASS) 			\
+  ((MODE) == QImode && !TARGET_64BIT				\
+   && ((CLASS) == ALL_REGS || (CLASS) == GENERAL_REGS		\
+       || (CLASS) == LEGACY_REGS || (CLASS) == INDEX_REGS)	\
+   ? Q_REGS : (CLASS))
+
+/* Given an rtx X being reloaded into a reg required to be
+   in class CLASS, return the class of reg to actually use.
+   In general this is just CLASS; but on some machines
+   in some cases it is preferable to use a more restrictive class.
+   On the 80386 series, we prevent floating constants from being
+   reloaded into floating registers (since no move-insn can do that)
+   and we ensure that QImodes aren't reloaded into the esi or edi reg.  */
+
+/* Put float CONST_DOUBLE in the constant pool instead of fp regs.
+   QImode must go into class Q_REGS.
+   Narrow ALL_REGS to GENERAL_REGS.  This supports allowing movsf and
+   movdf to do mem-to-mem moves through integer regs.  */
+
+#define PREFERRED_RELOAD_CLASS(X, CLASS) \
+   ix86_preferred_reload_class ((X), (CLASS))
+
+/* If we are copying between general and FP registers, we need a memory
+   location. The same is true for SSE and MMX registers.  */
+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \
+  ix86_secondary_memory_needed ((CLASS1), (CLASS2), (MODE), 1)
+
+/* QImode spills from non-QI registers need a scratch.  This does not
+   happen often -- the only example so far requires an uninitialized
+   pseudo.  */
+
+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, OUT)			\
+  (((CLASS) == GENERAL_REGS || (CLASS) == LEGACY_REGS			\
+    || (CLASS) == INDEX_REGS) && !TARGET_64BIT && (MODE) == QImode	\
+   ? Q_REGS : NO_REGS)
+
+/* Return the maximum number of consecutive registers
+   needed to represent mode MODE in a register of class CLASS.  */
+/* On the 80386, this is the size of MODE in words,
+   except in the FP regs, where a single reg is always enough.  */
+#define CLASS_MAX_NREGS(CLASS, MODE)					\
+ (!MAYBE_INTEGER_CLASS_P (CLASS)					\
+  ? (COMPLEX_MODE_P (MODE) ? 2 : 1)					\
+  : (((((MODE) == XFmode ? 12 : GET_MODE_SIZE (MODE)))			\
+      + UNITS_PER_WORD - 1) / UNITS_PER_WORD))
+
+/* A C expression whose value is nonzero if pseudos that have been
+   assigned to registers of class CLASS would likely be spilled
+   because registers of CLASS are needed for spill registers.
+
+   The default value of this macro returns 1 if CLASS has exactly one
+   register and zero otherwise.  On most machines, this default
+   should be used.  Only define this macro to some other expression
+   if pseudo allocated by `local-alloc.c' end up in memory because
+   their hard registers were needed for spill registers.  If this
+   macro returns nonzero for those classes, those pseudos will only
+   be allocated by `global.c', which knows how to reallocate the
+   pseudo to another register.  If there would not be another
+   register available for reallocation, you should not change the
+   definition of this macro since the only effect of such a
+   definition would be to slow down register allocation.  */
+
+#define CLASS_LIKELY_SPILLED_P(CLASS)					\
+  (((CLASS) == AREG)							\
+   || ((CLASS) == DREG)							\
+   || ((CLASS) == CREG)							\
+   || ((CLASS) == BREG)							\
+   || ((CLASS) == AD_REGS)						\
+   || ((CLASS) == SIREG)						\
+   || ((CLASS) == DIREG)						\
+   || ((CLASS) == FP_TOP_REG)						\
+   || ((CLASS) == FP_SECOND_REG))
+
+/* Return a class of registers that cannot change FROM mode to TO mode.
+  
+   x87 registers can't do subreg as all values are reformated to extended
+   precision.  XMM registers does not support with nonzero offsets equal
+   to 4, 8 and 12 otherwise valid for integer registers. Since we can't
+   determine these, prohibit all nonparadoxical subregs changing size.  */
+
+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)	\
+  (GET_MODE_SIZE (TO) < GET_MODE_SIZE (FROM)		\
+   ? reg_classes_intersect_p (FLOAT_SSE_REGS, (CLASS))	\
+     || MAYBE_MMX_CLASS_P (CLASS) 			\
+   : GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)		\
+   ? reg_classes_intersect_p (FLOAT_REGS, (CLASS)) : 0)
+
+/* A C statement that adds to CLOBBERS any hard regs the port wishes
+   to automatically clobber for all asms.
+
+   We do this in the new i386 backend to maintain source compatibility
+   with the old cc0-based compiler.  */
+
+#define MD_ASM_CLOBBERS(CLOBBERS)					\
+  do {									\
+    (CLOBBERS) = tree_cons (NULL_TREE, build_string (5, "flags"),	\
+			    (CLOBBERS));				\
+    (CLOBBERS) = tree_cons (NULL_TREE, build_string (4, "fpsr"),	\
+			    (CLOBBERS));				\
+    (CLOBBERS) = tree_cons (NULL_TREE, build_string (7, "dirflag"),	\
+			    (CLOBBERS));				\
+  } while (0)
+
+/* Stack layout; function entry, exit and calling.  */
+
+/* Define this if pushing a word on the stack
+   makes the stack pointer a smaller address.  */
+#define STACK_GROWS_DOWNWARD
+
+/* Define this if the nominal address of the stack frame
+   is at the high-address end of the local variables;
+   that is, each additional local variable allocated
+   goes at a more negative offset in the frame.  */
+#define FRAME_GROWS_DOWNWARD
+
+/* Offset within stack frame to start allocating local variables at.
+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the
+   first local allocated.  Otherwise, it is the offset to the BEGINNING
+   of the first local allocated.  */
+#define STARTING_FRAME_OFFSET 0
+
+/* If we generate an insn to push BYTES bytes,
+   this says how many the stack pointer really advances by.
+   On 386 pushw decrements by exactly 2 no matter what the position was.
+   On the 386 there is no pushb; we use pushw instead, and this
+   has the effect of rounding up to 2.
+
+   For 64bit ABI we round up to 8 bytes.
+ */
+
+#define PUSH_ROUNDING(BYTES) \
+  (TARGET_64BIT		     \
+   ? (((BYTES) + 7) & (-8))  \
+   : (((BYTES) + 1) & (-2)))
+
+/* If defined, the maximum amount of space required for outgoing arguments will
+   be computed and placed into the variable
+   `current_function_outgoing_args_size'.  No space will be pushed onto the
+   stack for each call; instead, the function prologue should increase the stack
+   frame size by this amount.  */
+
+#define ACCUMULATE_OUTGOING_ARGS TARGET_ACCUMULATE_OUTGOING_ARGS
+
+/* If defined, a C expression whose value is nonzero when we want to use PUSH
+   instructions to pass outgoing arguments.  */
+
+#define PUSH_ARGS (TARGET_PUSH_ARGS && !ACCUMULATE_OUTGOING_ARGS)
+
+/* We want the stack and args grow in opposite directions, even if
+   PUSH_ARGS is 0.  */
+#define PUSH_ARGS_REVERSED 1
+
+/* Offset of first parameter from the argument pointer register value.  */
+#define FIRST_PARM_OFFSET(FNDECL) 0
+
+/* Define this macro if functions should assume that stack space has been
+   allocated for arguments even when their values are passed in registers.
+
+   The value of this macro is the size, in bytes, of the area reserved for
+   arguments passed in registers for the function represented by FNDECL.
+
+   This space can be allocated by the caller, or be a part of the
+   machine-dependent stack frame: `OUTGOING_REG_PARM_STACK_SPACE' says
+   which.  */
+#define REG_PARM_STACK_SPACE(FNDECL) 0
+
+/* Define as a C expression that evaluates to nonzero if we do not know how
+   to pass TYPE solely in registers.  The file expr.h defines a
+   definition that is usually appropriate, refer to expr.h for additional
+   documentation. If `REG_PARM_STACK_SPACE' is defined, the argument will be
+   computed in the stack and then loaded into a register.  */
+#define MUST_PASS_IN_STACK(MODE, TYPE)  ix86_must_pass_in_stack ((MODE), (TYPE))
+
+/* Value is the number of bytes of arguments automatically
+   popped when returning from a subroutine call.
+   FUNDECL is the declaration node of the function (as a tree),
+   FUNTYPE is the data type of the function (as a tree),
+   or for a library call it is an identifier node for the subroutine name.
+   SIZE is the number of bytes of arguments passed on the stack.
+
+   On the 80386, the RTD insn may be used to pop them if the number
+     of args is fixed, but if the number is variable then the caller
+     must pop them all.  RTD can't be used for library calls now
+     because the library is compiled with the Unix compiler.
+   Use of RTD is a selectable option, since it is incompatible with
+   standard Unix calling sequences.  If the option is not selected,
+   the caller must always pop the args.
+
+   The attribute stdcall is equivalent to RTD on a per module basis.  */
+
+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, SIZE) \
+  ix86_return_pops_args ((FUNDECL), (FUNTYPE), (SIZE))
+
+/* Define how to find the value returned by a function.
+   VALTYPE is the data type of the value (as a tree).
+   If the precise function being called is known, FUNC is its FUNCTION_DECL;
+   otherwise, FUNC is 0.  */
+#define FUNCTION_VALUE(VALTYPE, FUNC)  \
+   ix86_function_value (VALTYPE)
+
+#define FUNCTION_VALUE_REGNO_P(N) \
+  ix86_function_value_regno_p (N)
+
+/* Define how to find the value returned by a library function
+   assuming the value has mode MODE.  */
+
+#define LIBCALL_VALUE(MODE) \
+  ix86_libcall_value (MODE)
+
+/* Define the size of the result block used for communication between
+   untyped_call and untyped_return.  The block contains a DImode value
+   followed by the block used by fnsave and frstor.  */
+
+#define APPLY_RESULT_SIZE (8+108)
+
+/* 1 if N is a possible register number for function argument passing.  */
+#define FUNCTION_ARG_REGNO_P(N) ix86_function_arg_regno_p (N)
+
+/* Define a data type for recording info about an argument list
+   during the scan of that argument list.  This data type should
+   hold all necessary information about the function itself
+   and about the args processed so far, enough to enable macros
+   such as FUNCTION_ARG to determine where the next arg should go.  */
+
+typedef struct ix86_args {
+  int words;			/* # words passed so far */
+  int nregs;			/* # registers available for passing */
+  int regno;			/* next available register number */
+  int fastcall;		/* fastcall calling convention is used */
+  int sse_words;		/* # sse words passed so far */
+  int sse_nregs;		/* # sse registers available for passing */
+  int warn_sse;			/* True when we want to warn about SSE ABI.  */
+  int warn_mmx;			/* True when we want to warn about MMX ABI.  */
+  int sse_regno;		/* next available sse register number */
+  int mmx_words;		/* # mmx words passed so far */
+  int mmx_nregs;		/* # mmx registers available for passing */
+  int mmx_regno;		/* next available mmx register number */
+  int maybe_vaarg;		/* true for calls to possibly vardic fncts.  */
+} CUMULATIVE_ARGS;
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is 0.  */
+
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \
+  init_cumulative_args (&(CUM), (FNTYPE), (LIBNAME), (FNDECL))
+
+/* Update the data in CUM to advance over an argument
+   of mode MODE and data type TYPE.
+   (TYPE is null for libcalls where that information may not be available.)  */
+
+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \
+  function_arg_advance (&(CUM), (MODE), (TYPE), (NAMED))
+
+/* Define where to put the arguments to a function.
+   Value is zero to push the argument on the stack,
+   or a hard register in which to store the argument.
+
+   MODE is the argument's machine mode.
+   TYPE is the data type of the argument (as a tree).
+    This is null for libcalls where that information may
+    not be available.
+   CUM is a variable of type CUMULATIVE_ARGS which gives info about
+    the preceding args and about the function being called.
+   NAMED is nonzero if this argument is a named parameter
+    (otherwise it is an extra parameter matching an ellipsis).  */
+
+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \
+  function_arg (&(CUM), (MODE), (TYPE), (NAMED))
+
+/* For an arg passed partly in registers and partly in memory,
+   this is the number of registers used.
+   For args passed entirely in registers or entirely in memory, zero.  */
+
+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0
+
+/* A C expression that indicates when an argument must be passed by
+   reference.  If nonzero for an argument, a copy of that argument is
+   made in memory and a pointer to the argument is passed instead of
+   the argument itself.  The pointer is passed in whatever way is
+   appropriate for passing a pointer to that type.  */
+ 
+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \
+  function_arg_pass_by_reference(&CUM, MODE, TYPE, NAMED)
+ 
+/* Perform any needed actions needed for a function that is receiving a
+   variable number of arguments.
+
+   CUM is as above.
+
+   MODE and TYPE are the mode and type of the current parameter.
+
+   PRETEND_SIZE is a variable that should be set to the amount of stack
+   that must be pushed by the prolog to pretend that our caller pushed
+   it.
+
+   Normally, this macro will push all remaining incoming registers on the
+   stack and set PRETEND_SIZE to the length of the registers pushed.  */
+
+#define SETUP_INCOMING_VARARGS(CUM, MODE, TYPE, PRETEND_SIZE, NO_RTL)	\
+  ix86_setup_incoming_varargs (&(CUM), (MODE), (TYPE), &(PRETEND_SIZE), \
+			       (NO_RTL))
+
+/* Implement `va_start' for varargs and stdarg.  */
+#define EXPAND_BUILTIN_VA_START(VALIST, NEXTARG) \
+  ix86_va_start (VALIST, NEXTARG)
+
+/* Implement `va_arg'.  */
+#define EXPAND_BUILTIN_VA_ARG(VALIST, TYPE) \
+  ix86_va_arg ((VALIST), (TYPE))
+
+#define TARGET_ASM_FILE_END ix86_file_end
+#define NEED_INDICATE_EXEC_STACK 0
+
+/* Output assembler code to FILE to increment profiler label # LABELNO
+   for profiling a function entry.  */
+
+#define FUNCTION_PROFILER(FILE, LABELNO) x86_function_profiler (FILE, LABELNO)
+
+#define MCOUNT_NAME "_mcount"
+
+#define PROFILE_COUNT_REGISTER "edx"
+
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
+   the stack pointer does not matter.  The value is tested only in
+   functions that have frame pointers.
+   No definition is equivalent to always zero.  */
+/* Note on the 386 it might be more efficient not to define this since
+   we have to restore it ourselves from the frame pointer, in order to
+   use pop */
+
+#define EXIT_IGNORE_STACK 1
+
+/* Output assembler code for a block containing the constant parts
+   of a trampoline, leaving space for the variable parts.  */
+
+/* On the 386, the trampoline contains two instructions:
+     mov #STATIC,ecx
+     jmp FUNCTION
+   The trampoline is generated entirely at runtime.  The operand of JMP
+   is the address of FUNCTION relative to the instruction following the
+   JMP (which is 5 bytes long).  */
+
+/* Length in units of the trampoline for entering a nested function.  */
+
+#define TRAMPOLINE_SIZE (TARGET_64BIT ? 23 : 10)
+
+/* Emit RTL insns to initialize the variable parts of a trampoline.
+   FNADDR is an RTX for the address of the function's pure code.
+   CXT is an RTX for the static chain value for the function.  */
+
+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \
+  x86_initialize_trampoline ((TRAMP), (FNADDR), (CXT))
+
+/* Definitions for register eliminations.
+
+   This is an array of structures.  Each structure initializes one pair
+   of eliminable registers.  The "from" register number is given first,
+   followed by "to".  Eliminations of the same "from" register are listed
+   in order of preference.
+
+   There are two registers that can always be eliminated on the i386.
+   The frame pointer and the arg pointer can be replaced by either the
+   hard frame pointer or to the stack pointer, depending upon the
+   circumstances.  The hard frame pointer is not used before reload and
+   so it is not eligible for elimination.  */
+
+#define ELIMINABLE_REGS					\
+{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},		\
+ { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},	\
+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},		\
+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}	\
+
+/* Given FROM and TO register numbers, say whether this elimination is
+   allowed.  Frame pointer elimination is automatically handled.
+
+   All other eliminations are valid.  */
+
+#define CAN_ELIMINATE(FROM, TO) \
+  ((TO) == STACK_POINTER_REGNUM ? ! frame_pointer_needed : 1)
+
+/* Define the offset between two registers, one to be eliminated, and the other
+   its replacement, at the start of a routine.  */
+
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \
+  ((OFFSET) = ix86_initial_elimination_offset ((FROM), (TO)))
+
+/* Addressing modes, and classification of registers for them.  */
+
+/* Macros to check register numbers against specific register classes.  */
+
+/* These assume that REGNO is a hard or pseudo reg number.
+   They give nonzero only if REGNO is a hard reg of the suitable class
+   or a pseudo reg currently allocated to a suitable hard reg.
+   Since they use reg_renumber, they are safe only once reg_renumber
+   has been allocated, which happens in local-alloc.c.  */
+
+#define REGNO_OK_FOR_INDEX_P(REGNO) 					\
+  ((REGNO) < STACK_POINTER_REGNUM 					\
+   || (REGNO >= FIRST_REX_INT_REG					\
+       && (REGNO) <= LAST_REX_INT_REG)					\
+   || ((unsigned) reg_renumber[(REGNO)] >= FIRST_REX_INT_REG		\
+       && (unsigned) reg_renumber[(REGNO)] <= LAST_REX_INT_REG)		\
+   || (unsigned) reg_renumber[(REGNO)] < STACK_POINTER_REGNUM)
+
+#define REGNO_OK_FOR_BASE_P(REGNO) 					\
+  ((REGNO) <= STACK_POINTER_REGNUM 					\
+   || (REGNO) == ARG_POINTER_REGNUM 					\
+   || (REGNO) == FRAME_POINTER_REGNUM 					\
+   || (REGNO >= FIRST_REX_INT_REG					\
+       && (REGNO) <= LAST_REX_INT_REG)					\
+   || ((unsigned) reg_renumber[(REGNO)] >= FIRST_REX_INT_REG		\
+       && (unsigned) reg_renumber[(REGNO)] <= LAST_REX_INT_REG)		\
+   || (unsigned) reg_renumber[(REGNO)] <= STACK_POINTER_REGNUM)
+
+#define REGNO_OK_FOR_SIREG_P(REGNO) \
+  ((REGNO) == 4 || reg_renumber[(REGNO)] == 4)
+#define REGNO_OK_FOR_DIREG_P(REGNO) \
+  ((REGNO) == 5 || reg_renumber[(REGNO)] == 5)
+
+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx
+   and check its validity for a certain class.
+   We have two alternate definitions for each of them.
+   The usual definition accepts all pseudo regs; the other rejects
+   them unless they have been allocated suitable hard regs.
+   The symbol REG_OK_STRICT causes the latter definition to be used.
+
+   Most source files want to accept pseudo regs in the hope that
+   they will get allocated to the class that the insn wants them to be in.
+   Source files for reload pass need to be strict.
+   After reload, it makes no difference, since pseudo regs have
+   been eliminated by then.  */
+
+
+/* Non strict versions, pseudos are ok */
+#define REG_OK_FOR_INDEX_NONSTRICT_P(X)					\
+  (REGNO (X) < STACK_POINTER_REGNUM					\
+   || (REGNO (X) >= FIRST_REX_INT_REG					\
+       && REGNO (X) <= LAST_REX_INT_REG)				\
+   || REGNO (X) >= FIRST_PSEUDO_REGISTER)
+
+#define REG_OK_FOR_BASE_NONSTRICT_P(X)					\
+  (REGNO (X) <= STACK_POINTER_REGNUM					\
+   || REGNO (X) == ARG_POINTER_REGNUM					\
+   || REGNO (X) == FRAME_POINTER_REGNUM 				\
+   || (REGNO (X) >= FIRST_REX_INT_REG					\
+       && REGNO (X) <= LAST_REX_INT_REG)				\
+   || REGNO (X) >= FIRST_PSEUDO_REGISTER)
+
+/* Strict versions, hard registers only */
+#define REG_OK_FOR_INDEX_STRICT_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))
+#define REG_OK_FOR_BASE_STRICT_P(X)  REGNO_OK_FOR_BASE_P (REGNO (X))
+
+#ifndef REG_OK_STRICT
+#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_NONSTRICT_P (X)
+#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_NONSTRICT_P (X)
+
+#else
+#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_STRICT_P (X)
+#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_STRICT_P (X)
+#endif
+
+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression
+   that is a valid memory address for an instruction.
+   The MODE argument is the machine mode for the MEM expression
+   that wants to use this address.
+
+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,
+   except for CONSTANT_ADDRESS_P which is usually machine-independent.
+
+   See legitimize_pic_address in i386.c for details as to what
+   constitutes a legitimate address when -fpic is used.  */
+
+#define MAX_REGS_PER_ADDRESS 2
+
+#define CONSTANT_ADDRESS_P(X)  constant_address_p (X)
+
+/* Nonzero if the constant value X is a legitimate general operand.
+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */
+
+#define LEGITIMATE_CONSTANT_P(X)  legitimate_constant_p (X)
+
+#ifdef REG_OK_STRICT
+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)				\
+do {									\
+  if (legitimate_address_p ((MODE), (X), 1))				\
+    goto ADDR;								\
+} while (0)
+
+#else
+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)				\
+do {									\
+  if (legitimate_address_p ((MODE), (X), 0))				\
+    goto ADDR;								\
+} while (0)
+
+#endif
+
+/* If defined, a C expression to determine the base term of address X.
+   This macro is used in only one place: `find_base_term' in alias.c.
+
+   It is always safe for this macro to not be defined.  It exists so
+   that alias analysis can understand machine-dependent addresses.
+
+   The typical use of this macro is to handle addresses containing
+   a label_ref or symbol_ref within an UNSPEC.  */
+
+#define FIND_BASE_TERM(X) ix86_find_base_term (X)
+
+/* Try machine-dependent ways of modifying an illegitimate address
+   to be legitimate.  If we find one, return the new, valid address.
+   This macro is used in only one place: `memory_address' in explow.c.
+
+   OLDX is the address as it was before break_out_memory_refs was called.
+   In some cases it is useful to look at this to decide what needs to be done.
+
+   MODE and WIN are passed so that this macro can use
+   GO_IF_LEGITIMATE_ADDRESS.
+
+   It is always safe for this macro to do nothing.  It exists to recognize
+   opportunities to optimize the output.
+
+   For the 80386, we handle X+REG by loading X into a register R and
+   using R+REG.  R will go in a general reg and indexing will be used.
+   However, if REG is a broken-out memory address or multiplication,
+   nothing needs to be done because REG can certainly go in a general reg.
+
+   When -fpic is used, special handling is needed for symbolic references.
+   See comments by legitimize_pic_address in i386.c for details.  */
+
+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)				\
+do {									\
+  (X) = legitimize_address ((X), (OLDX), (MODE));			\
+  if (memory_address_p ((MODE), (X)))					\
+    goto WIN;								\
+} while (0)
+
+#define REWRITE_ADDRESS(X) rewrite_address (X)
+
+/* Nonzero if the constant value X is a legitimate general operand
+   when generating PIC code.  It is given that flag_pic is on and
+   that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */
+
+#define LEGITIMATE_PIC_OPERAND_P(X) legitimate_pic_operand_p (X)
+
+#define SYMBOLIC_CONST(X)	\
+  (GET_CODE (X) == SYMBOL_REF						\
+   || GET_CODE (X) == LABEL_REF						\
+   || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))
+
+/* Go to LABEL if ADDR (a legitimate address expression)
+   has an effect that depends on the machine mode it is used for.
+   On the 80386, only postdecrement and postincrement address depend thus
+   (the amount of decrement or increment being the length of the operand).  */
+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)	\
+do {							\
+ if (GET_CODE (ADDR) == POST_INC			\
+     || GET_CODE (ADDR) == POST_DEC)			\
+   goto LABEL;						\
+} while (0)
+
+/* Codes for all the SSE/MMX builtins.  */
+enum ix86_builtins
+{
+  IX86_BUILTIN_ADDPS,
+  IX86_BUILTIN_ADDSS,
+  IX86_BUILTIN_DIVPS,
+  IX86_BUILTIN_DIVSS,
+  IX86_BUILTIN_MULPS,
+  IX86_BUILTIN_MULSS,
+  IX86_BUILTIN_SUBPS,
+  IX86_BUILTIN_SUBSS,
+
+  IX86_BUILTIN_CMPEQPS,
+  IX86_BUILTIN_CMPLTPS,
+  IX86_BUILTIN_CMPLEPS,
+  IX86_BUILTIN_CMPGTPS,
+  IX86_BUILTIN_CMPGEPS,
+  IX86_BUILTIN_CMPNEQPS,
+  IX86_BUILTIN_CMPNLTPS,
+  IX86_BUILTIN_CMPNLEPS,
+  IX86_BUILTIN_CMPNGTPS,
+  IX86_BUILTIN_CMPNGEPS,
+  IX86_BUILTIN_CMPORDPS,
+  IX86_BUILTIN_CMPUNORDPS,
+  IX86_BUILTIN_CMPNEPS,
+  IX86_BUILTIN_CMPEQSS,
+  IX86_BUILTIN_CMPLTSS,
+  IX86_BUILTIN_CMPLESS,
+  IX86_BUILTIN_CMPNEQSS,
+  IX86_BUILTIN_CMPNLTSS,
+  IX86_BUILTIN_CMPNLESS,
+  IX86_BUILTIN_CMPORDSS,
+  IX86_BUILTIN_CMPUNORDSS,
+  IX86_BUILTIN_CMPNESS,
+
+  IX86_BUILTIN_COMIEQSS,
+  IX86_BUILTIN_COMILTSS,
+  IX86_BUILTIN_COMILESS,
+  IX86_BUILTIN_COMIGTSS,
+  IX86_BUILTIN_COMIGESS,
+  IX86_BUILTIN_COMINEQSS,
+  IX86_BUILTIN_UCOMIEQSS,
+  IX86_BUILTIN_UCOMILTSS,
+  IX86_BUILTIN_UCOMILESS,
+  IX86_BUILTIN_UCOMIGTSS,
+  IX86_BUILTIN_UCOMIGESS,
+  IX86_BUILTIN_UCOMINEQSS,
+
+  IX86_BUILTIN_CVTPI2PS,
+  IX86_BUILTIN_CVTPS2PI,
+  IX86_BUILTIN_CVTSI2SS,
+  IX86_BUILTIN_CVTSI642SS,
+  IX86_BUILTIN_CVTSS2SI,
+  IX86_BUILTIN_CVTSS2SI64,
+  IX86_BUILTIN_CVTTPS2PI,
+  IX86_BUILTIN_CVTTSS2SI,
+  IX86_BUILTIN_CVTTSS2SI64,
+
+  IX86_BUILTIN_MAXPS,
+  IX86_BUILTIN_MAXSS,
+  IX86_BUILTIN_MINPS,
+  IX86_BUILTIN_MINSS,
+
+  IX86_BUILTIN_LOADAPS,
+  IX86_BUILTIN_LOADUPS,
+  IX86_BUILTIN_STOREAPS,
+  IX86_BUILTIN_STOREUPS,
+  IX86_BUILTIN_LOADSS,
+  IX86_BUILTIN_STORESS,
+  IX86_BUILTIN_MOVSS,
+
+  IX86_BUILTIN_MOVHLPS,
+  IX86_BUILTIN_MOVLHPS,
+  IX86_BUILTIN_LOADHPS,
+  IX86_BUILTIN_LOADLPS,
+  IX86_BUILTIN_STOREHPS,
+  IX86_BUILTIN_STORELPS,
+
+  IX86_BUILTIN_MASKMOVQ,
+  IX86_BUILTIN_MOVMSKPS,
+  IX86_BUILTIN_PMOVMSKB,
+
+  IX86_BUILTIN_MOVNTPS,
+  IX86_BUILTIN_MOVNTQ,
+
+  IX86_BUILTIN_LOADDQA,
+  IX86_BUILTIN_LOADDQU,
+  IX86_BUILTIN_STOREDQA,
+  IX86_BUILTIN_STOREDQU,
+  IX86_BUILTIN_MOVQ,
+  IX86_BUILTIN_LOADD,
+  IX86_BUILTIN_STORED,
+
+  IX86_BUILTIN_CLRTI,
+
+  IX86_BUILTIN_PACKSSWB,
+  IX86_BUILTIN_PACKSSDW,
+  IX86_BUILTIN_PACKUSWB,
+
+  IX86_BUILTIN_PADDB,
+  IX86_BUILTIN_PADDW,
+  IX86_BUILTIN_PADDD,
+  IX86_BUILTIN_PADDQ,
+  IX86_BUILTIN_PADDSB,
+  IX86_BUILTIN_PADDSW,
+  IX86_BUILTIN_PADDUSB,
+  IX86_BUILTIN_PADDUSW,
+  IX86_BUILTIN_PSUBB,
+  IX86_BUILTIN_PSUBW,
+  IX86_BUILTIN_PSUBD,
+  IX86_BUILTIN_PSUBQ,
+  IX86_BUILTIN_PSUBSB,
+  IX86_BUILTIN_PSUBSW,
+  IX86_BUILTIN_PSUBUSB,
+  IX86_BUILTIN_PSUBUSW,
+
+  IX86_BUILTIN_PAND,
+  IX86_BUILTIN_PANDN,
+  IX86_BUILTIN_POR,
+  IX86_BUILTIN_PXOR,
+
+  IX86_BUILTIN_PAVGB,
+  IX86_BUILTIN_PAVGW,
+
+  IX86_BUILTIN_PCMPEQB,
+  IX86_BUILTIN_PCMPEQW,
+  IX86_BUILTIN_PCMPEQD,
+  IX86_BUILTIN_PCMPGTB,
+  IX86_BUILTIN_PCMPGTW,
+  IX86_BUILTIN_PCMPGTD,
+
+  IX86_BUILTIN_PEXTRW,
+  IX86_BUILTIN_PINSRW,
+
+  IX86_BUILTIN_PMADDWD,
+
+  IX86_BUILTIN_PMAXSW,
+  IX86_BUILTIN_PMAXUB,
+  IX86_BUILTIN_PMINSW,
+  IX86_BUILTIN_PMINUB,
+
+  IX86_BUILTIN_PMULHUW,
+  IX86_BUILTIN_PMULHW,
+  IX86_BUILTIN_PMULLW,
+
+  IX86_BUILTIN_PSADBW,
+  IX86_BUILTIN_PSHUFW,
+
+  IX86_BUILTIN_PSLLW,
+  IX86_BUILTIN_PSLLD,
+  IX86_BUILTIN_PSLLQ,
+  IX86_BUILTIN_PSRAW,
+  IX86_BUILTIN_PSRAD,
+  IX86_BUILTIN_PSRLW,
+  IX86_BUILTIN_PSRLD,
+  IX86_BUILTIN_PSRLQ,
+  IX86_BUILTIN_PSLLWI,
+  IX86_BUILTIN_PSLLDI,
+  IX86_BUILTIN_PSLLQI,
+  IX86_BUILTIN_PSRAWI,
+  IX86_BUILTIN_PSRADI,
+  IX86_BUILTIN_PSRLWI,
+  IX86_BUILTIN_PSRLDI,
+  IX86_BUILTIN_PSRLQI,
+
+  IX86_BUILTIN_PUNPCKHBW,
+  IX86_BUILTIN_PUNPCKHWD,
+  IX86_BUILTIN_PUNPCKHDQ,
+  IX86_BUILTIN_PUNPCKLBW,
+  IX86_BUILTIN_PUNPCKLWD,
+  IX86_BUILTIN_PUNPCKLDQ,
+
+  IX86_BUILTIN_SHUFPS,
+
+  IX86_BUILTIN_RCPPS,
+  IX86_BUILTIN_RCPSS,
+  IX86_BUILTIN_RSQRTPS,
+  IX86_BUILTIN_RSQRTSS,
+  IX86_BUILTIN_SQRTPS,
+  IX86_BUILTIN_SQRTSS,
+
+  IX86_BUILTIN_UNPCKHPS,
+  IX86_BUILTIN_UNPCKLPS,
+
+  IX86_BUILTIN_ANDPS,
+  IX86_BUILTIN_ANDNPS,
+  IX86_BUILTIN_ORPS,
+  IX86_BUILTIN_XORPS,
+
+  IX86_BUILTIN_EMMS,
+  IX86_BUILTIN_LDMXCSR,
+  IX86_BUILTIN_STMXCSR,
+  IX86_BUILTIN_SFENCE,
+
+  /* 3DNow! Original */
+  IX86_BUILTIN_FEMMS,
+  IX86_BUILTIN_PAVGUSB,
+  IX86_BUILTIN_PF2ID,
+  IX86_BUILTIN_PFACC,
+  IX86_BUILTIN_PFADD,
+  IX86_BUILTIN_PFCMPEQ,
+  IX86_BUILTIN_PFCMPGE,
+  IX86_BUILTIN_PFCMPGT,
+  IX86_BUILTIN_PFMAX,
+  IX86_BUILTIN_PFMIN,
+  IX86_BUILTIN_PFMUL,
+  IX86_BUILTIN_PFRCP,
+  IX86_BUILTIN_PFRCPIT1,
+  IX86_BUILTIN_PFRCPIT2,
+  IX86_BUILTIN_PFRSQIT1,
+  IX86_BUILTIN_PFRSQRT,
+  IX86_BUILTIN_PFSUB,
+  IX86_BUILTIN_PFSUBR,
+  IX86_BUILTIN_PI2FD,
+  IX86_BUILTIN_PMULHRW,
+
+  /* 3DNow! Athlon Extensions */
+  IX86_BUILTIN_PF2IW,
+  IX86_BUILTIN_PFNACC,
+  IX86_BUILTIN_PFPNACC,
+  IX86_BUILTIN_PI2FW,
+  IX86_BUILTIN_PSWAPDSI,
+  IX86_BUILTIN_PSWAPDSF,
+
+  IX86_BUILTIN_SSE_ZERO,
+  IX86_BUILTIN_MMX_ZERO,
+
+  /* SSE2 */
+  IX86_BUILTIN_ADDPD,
+  IX86_BUILTIN_ADDSD,
+  IX86_BUILTIN_DIVPD,
+  IX86_BUILTIN_DIVSD,
+  IX86_BUILTIN_MULPD,
+  IX86_BUILTIN_MULSD,
+  IX86_BUILTIN_SUBPD,
+  IX86_BUILTIN_SUBSD,
+
+  IX86_BUILTIN_CMPEQPD,
+  IX86_BUILTIN_CMPLTPD,
+  IX86_BUILTIN_CMPLEPD,
+  IX86_BUILTIN_CMPGTPD,
+  IX86_BUILTIN_CMPGEPD,
+  IX86_BUILTIN_CMPNEQPD,
+  IX86_BUILTIN_CMPNLTPD,
+  IX86_BUILTIN_CMPNLEPD,
+  IX86_BUILTIN_CMPNGTPD,
+  IX86_BUILTIN_CMPNGEPD,
+  IX86_BUILTIN_CMPORDPD,
+  IX86_BUILTIN_CMPUNORDPD,
+  IX86_BUILTIN_CMPNEPD,
+  IX86_BUILTIN_CMPEQSD,
+  IX86_BUILTIN_CMPLTSD,
+  IX86_BUILTIN_CMPLESD,
+  IX86_BUILTIN_CMPNEQSD,
+  IX86_BUILTIN_CMPNLTSD,
+  IX86_BUILTIN_CMPNLESD,
+  IX86_BUILTIN_CMPORDSD,
+  IX86_BUILTIN_CMPUNORDSD,
+  IX86_BUILTIN_CMPNESD,
+
+  IX86_BUILTIN_COMIEQSD,
+  IX86_BUILTIN_COMILTSD,
+  IX86_BUILTIN_COMILESD,
+  IX86_BUILTIN_COMIGTSD,
+  IX86_BUILTIN_COMIGESD,
+  IX86_BUILTIN_COMINEQSD,
+  IX86_BUILTIN_UCOMIEQSD,
+  IX86_BUILTIN_UCOMILTSD,
+  IX86_BUILTIN_UCOMILESD,
+  IX86_BUILTIN_UCOMIGTSD,
+  IX86_BUILTIN_UCOMIGESD,
+  IX86_BUILTIN_UCOMINEQSD,
+
+  IX86_BUILTIN_MAXPD,
+  IX86_BUILTIN_MAXSD,
+  IX86_BUILTIN_MINPD,
+  IX86_BUILTIN_MINSD,
+
+  IX86_BUILTIN_ANDPD,
+  IX86_BUILTIN_ANDNPD,
+  IX86_BUILTIN_ORPD,
+  IX86_BUILTIN_XORPD,
+
+  IX86_BUILTIN_SQRTPD,
+  IX86_BUILTIN_SQRTSD,
+
+  IX86_BUILTIN_UNPCKHPD,
+  IX86_BUILTIN_UNPCKLPD,
+
+  IX86_BUILTIN_SHUFPD,
+
+  IX86_BUILTIN_LOADAPD,
+  IX86_BUILTIN_LOADUPD,
+  IX86_BUILTIN_STOREAPD,
+  IX86_BUILTIN_STOREUPD,
+  IX86_BUILTIN_LOADSD,
+  IX86_BUILTIN_STORESD,
+  IX86_BUILTIN_MOVSD,
+
+  IX86_BUILTIN_LOADHPD,
+  IX86_BUILTIN_LOADLPD,
+  IX86_BUILTIN_STOREHPD,
+  IX86_BUILTIN_STORELPD,
+
+  IX86_BUILTIN_CVTDQ2PD,
+  IX86_BUILTIN_CVTDQ2PS,
+
+  IX86_BUILTIN_CVTPD2DQ,
+  IX86_BUILTIN_CVTPD2PI,
+  IX86_BUILTIN_CVTPD2PS,
+  IX86_BUILTIN_CVTTPD2DQ,
+  IX86_BUILTIN_CVTTPD2PI,
+
+  IX86_BUILTIN_CVTPI2PD,
+  IX86_BUILTIN_CVTSI2SD,
+  IX86_BUILTIN_CVTSI642SD,
+
+  IX86_BUILTIN_CVTSD2SI,
+  IX86_BUILTIN_CVTSD2SI64,
+  IX86_BUILTIN_CVTSD2SS,
+  IX86_BUILTIN_CVTSS2SD,
+  IX86_BUILTIN_CVTTSD2SI,
+  IX86_BUILTIN_CVTTSD2SI64,
+
+  IX86_BUILTIN_CVTPS2DQ,
+  IX86_BUILTIN_CVTPS2PD,
+  IX86_BUILTIN_CVTTPS2DQ,
+
+  IX86_BUILTIN_MOVNTI,
+  IX86_BUILTIN_MOVNTPD,
+  IX86_BUILTIN_MOVNTDQ,
+
+  IX86_BUILTIN_SETPD1,
+  IX86_BUILTIN_SETPD,
+  IX86_BUILTIN_CLRPD,
+  IX86_BUILTIN_SETRPD,
+  IX86_BUILTIN_LOADPD1,
+  IX86_BUILTIN_LOADRPD,
+  IX86_BUILTIN_STOREPD1,
+  IX86_BUILTIN_STORERPD,
+
+  /* SSE2 MMX */
+  IX86_BUILTIN_MASKMOVDQU,
+  IX86_BUILTIN_MOVMSKPD,
+  IX86_BUILTIN_PMOVMSKB128,
+  IX86_BUILTIN_MOVQ2DQ,
+  IX86_BUILTIN_MOVDQ2Q,
+
+  IX86_BUILTIN_PACKSSWB128,
+  IX86_BUILTIN_PACKSSDW128,
+  IX86_BUILTIN_PACKUSWB128,
+
+  IX86_BUILTIN_PADDB128,
+  IX86_BUILTIN_PADDW128,
+  IX86_BUILTIN_PADDD128,
+  IX86_BUILTIN_PADDQ128,
+  IX86_BUILTIN_PADDSB128,
+  IX86_BUILTIN_PADDSW128,
+  IX86_BUILTIN_PADDUSB128,
+  IX86_BUILTIN_PADDUSW128,
+  IX86_BUILTIN_PSUBB128,
+  IX86_BUILTIN_PSUBW128,
+  IX86_BUILTIN_PSUBD128,
+  IX86_BUILTIN_PSUBQ128,
+  IX86_BUILTIN_PSUBSB128,
+  IX86_BUILTIN_PSUBSW128,
+  IX86_BUILTIN_PSUBUSB128,
+  IX86_BUILTIN_PSUBUSW128,
+
+  IX86_BUILTIN_PAND128,
+  IX86_BUILTIN_PANDN128,
+  IX86_BUILTIN_POR128,
+  IX86_BUILTIN_PXOR128,
+
+  IX86_BUILTIN_PAVGB128,
+  IX86_BUILTIN_PAVGW128,
+
+  IX86_BUILTIN_PCMPEQB128,
+  IX86_BUILTIN_PCMPEQW128,
+  IX86_BUILTIN_PCMPEQD128,
+  IX86_BUILTIN_PCMPGTB128,
+  IX86_BUILTIN_PCMPGTW128,
+  IX86_BUILTIN_PCMPGTD128,
+
+  IX86_BUILTIN_PEXTRW128,
+  IX86_BUILTIN_PINSRW128,
+
+  IX86_BUILTIN_PMADDWD128,
+
+  IX86_BUILTIN_PMAXSW128,
+  IX86_BUILTIN_PMAXUB128,
+  IX86_BUILTIN_PMINSW128,
+  IX86_BUILTIN_PMINUB128,
+
+  IX86_BUILTIN_PMULUDQ,
+  IX86_BUILTIN_PMULUDQ128,
+  IX86_BUILTIN_PMULHUW128,
+  IX86_BUILTIN_PMULHW128,
+  IX86_BUILTIN_PMULLW128,
+
+  IX86_BUILTIN_PSADBW128,
+  IX86_BUILTIN_PSHUFHW,
+  IX86_BUILTIN_PSHUFLW,
+  IX86_BUILTIN_PSHUFD,
+
+  IX86_BUILTIN_PSLLW128,
+  IX86_BUILTIN_PSLLD128,
+  IX86_BUILTIN_PSLLQ128,
+  IX86_BUILTIN_PSRAW128,
+  IX86_BUILTIN_PSRAD128,
+  IX86_BUILTIN_PSRLW128,
+  IX86_BUILTIN_PSRLD128,
+  IX86_BUILTIN_PSRLQ128,
+  IX86_BUILTIN_PSLLDQI128,
+  IX86_BUILTIN_PSLLWI128,
+  IX86_BUILTIN_PSLLDI128,
+  IX86_BUILTIN_PSLLQI128,
+  IX86_BUILTIN_PSRAWI128,
+  IX86_BUILTIN_PSRADI128,
+  IX86_BUILTIN_PSRLDQI128,
+  IX86_BUILTIN_PSRLWI128,
+  IX86_BUILTIN_PSRLDI128,
+  IX86_BUILTIN_PSRLQI128,
+
+  IX86_BUILTIN_PUNPCKHBW128,
+  IX86_BUILTIN_PUNPCKHWD128,
+  IX86_BUILTIN_PUNPCKHDQ128,
+  IX86_BUILTIN_PUNPCKHQDQ128,
+  IX86_BUILTIN_PUNPCKLBW128,
+  IX86_BUILTIN_PUNPCKLWD128,
+  IX86_BUILTIN_PUNPCKLDQ128,
+  IX86_BUILTIN_PUNPCKLQDQ128,
+
+  IX86_BUILTIN_CLFLUSH,
+  IX86_BUILTIN_MFENCE,
+  IX86_BUILTIN_LFENCE,
+
+  /* Prescott New Instructions.  */
+  IX86_BUILTIN_ADDSUBPS,
+  IX86_BUILTIN_HADDPS,
+  IX86_BUILTIN_HSUBPS,
+  IX86_BUILTIN_MOVSHDUP,
+  IX86_BUILTIN_MOVSLDUP,
+  IX86_BUILTIN_ADDSUBPD,
+  IX86_BUILTIN_HADDPD,
+  IX86_BUILTIN_HSUBPD,
+  IX86_BUILTIN_LOADDDUP,
+  IX86_BUILTIN_MOVDDUP,
+  IX86_BUILTIN_LDDQU,
+
+  IX86_BUILTIN_MONITOR,
+  IX86_BUILTIN_MWAIT,
+
+  IX86_BUILTIN_MAX
+};
+
+/* Max number of args passed in registers.  If this is more than 3, we will
+   have problems with ebx (register #4), since it is a caller save register and
+   is also used as the pic register in ELF.  So for now, don't allow more than
+   3 registers to be passed in registers.  */
+
+#define REGPARM_MAX (TARGET_64BIT ? 6 : 3)
+
+#define SSE_REGPARM_MAX (TARGET_64BIT ? 8 : (TARGET_SSE ? 3 : 0))
+
+#define MMX_REGPARM_MAX (TARGET_64BIT ? 0 : (TARGET_MMX ? 3 : 0))
+
+
+/* Specify the machine mode that this machine uses
+   for the index in the tablejump instruction.  */
+#define CASE_VECTOR_MODE (!TARGET_64BIT || flag_pic ? SImode : DImode)
+
+/* Define as C expression which evaluates to nonzero if the tablejump
+   instruction expects the table to contain offsets from the address of the
+   table.
+   Do not define this if the table should contain absolute addresses.  */
+/* #define CASE_VECTOR_PC_RELATIVE 1 */
+
+/* Define this as 1 if `char' should by default be signed; else as 0.  */
+#define DEFAULT_SIGNED_CHAR 1
+
+/* Number of bytes moved into a data cache for a single prefetch operation.  */
+#define PREFETCH_BLOCK ix86_cost->prefetch_block
+
+/* Number of prefetch operations that can be done in parallel.  */
+#define SIMULTANEOUS_PREFETCHES ix86_cost->simultaneous_prefetches
+
+/* Max number of bytes we can move from memory to memory
+   in one reasonably fast instruction.  */
+#define MOVE_MAX 16
+
+/* MOVE_MAX_PIECES is the number of bytes at a time which we can
+   move efficiently, as opposed to  MOVE_MAX which is the maximum
+   number of bytes we can move with a single instruction.  */
+#define MOVE_MAX_PIECES (TARGET_64BIT ? 8 : 4)
+
+/* If a memory-to-memory move would take MOVE_RATIO or more simple
+   move-instruction pairs, we will do a movstr or libcall instead.
+   Increasing the value will always make code faster, but eventually
+   incurs high cost in increased code size.
+
+   If you don't define this, a reasonable default is used.  */
+
+#define MOVE_RATIO (optimize_size ? 3 : ix86_cost->move_ratio)
+
+/* Define if shifts truncate the shift count
+   which implies one can omit a sign-extension or zero-extension
+   of a shift count.  */
+/* On i386, shifts do truncate the count.  But bit opcodes don't.  */
+
+/* #define SHIFT_COUNT_TRUNCATED */
+
+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits
+   is done just by pretending it is already truncated.  */
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1
+
+/* When a prototype says `char' or `short', really pass an `int'.
+   (The 386 can't easily push less than an int.)  */
+
+#define PROMOTE_PROTOTYPES 1
+
+/* A macro to update M and UNSIGNEDP when an object whose type is
+   TYPE and which has the specified mode and signedness is to be
+   stored in a register.  This macro is only called when TYPE is a
+   scalar type.
+
+   On i386 it is sometimes useful to promote HImode and QImode
+   quantities to SImode.  The choice depends on target type.  */
+
+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE) 		\
+do {							\
+  if (((MODE) == HImode && TARGET_PROMOTE_HI_REGS)	\
+      || ((MODE) == QImode && TARGET_PROMOTE_QI_REGS))	\
+    (MODE) = SImode;					\
+} while (0)
+
+/* Specify the machine mode that pointers have.
+   After generation of rtl, the compiler makes no further distinction
+   between pointers and any other objects of this machine mode.  */
+#define Pmode (TARGET_64BIT ? DImode : SImode)
+
+/* A function address in a call instruction
+   is a byte address (for indexing purposes)
+   so give the MEM rtx a byte's mode.  */
+#define FUNCTION_MODE QImode
+
+/* A C expression for the cost of moving data from a register in class FROM to
+   one in class TO.  The classes are expressed using the enumeration values
+   such as `GENERAL_REGS'.  A value of 2 is the default; other values are
+   interpreted relative to that.
+
+   It is not required that the cost always equal 2 when FROM is the same as TO;
+   on some machines it is expensive to move between registers if they are not
+   general registers.  */
+
+#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2) \
+   ix86_register_move_cost ((MODE), (CLASS1), (CLASS2))
+
+/* A C expression for the cost of moving data of mode M between a
+   register and memory.  A value of 2 is the default; this cost is
+   relative to those in `REGISTER_MOVE_COST'.
+
+   If moving between registers and memory is more expensive than
+   between two registers, you should define this macro to express the
+   relative cost.  */
+
+#define MEMORY_MOVE_COST(MODE, CLASS, IN)	\
+  ix86_memory_move_cost ((MODE), (CLASS), (IN))
+
+/* A C expression for the cost of a branch instruction.  A value of 1
+   is the default; other values are interpreted relative to that.  */
+
+#define BRANCH_COST ix86_branch_cost
+
+/* Define this macro as a C expression which is nonzero if accessing
+   less than a word of memory (i.e. a `char' or a `short') is no
+   faster than accessing a word of memory, i.e., if such access
+   require more than one instruction or if there is no difference in
+   cost between byte and (aligned) word loads.
+
+   When this macro is not defined, the compiler will access a field by
+   finding the smallest containing object; when it is defined, a
+   fullword load will be used if alignment permits.  Unless bytes
+   accesses are faster than word accesses, using word accesses is
+   preferable since it may eliminate subsequent memory access if
+   subsequent accesses occur to other fields in the same word of the
+   structure, but to different bytes.  */
+
+#define SLOW_BYTE_ACCESS 0
+
+/* Nonzero if access to memory by shorts is slow and undesirable.  */
+#define SLOW_SHORT_ACCESS 0
+
+/* Define this macro to be the value 1 if unaligned accesses have a
+   cost many times greater than aligned accesses, for example if they
+   are emulated in a trap handler.
+
+   When this macro is nonzero, the compiler will act as if
+   `STRICT_ALIGNMENT' were nonzero when generating code for block
+   moves.  This can cause significantly more instructions to be
+   produced.  Therefore, do not set this macro nonzero if unaligned
+   accesses only add a cycle or two to the time for a memory access.
+
+   If the value of this macro is always zero, it need not be defined.  */
+
+/* #define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 0 */
+
+/* Define this macro if it is as good or better to call a constant
+   function address than to call an address kept in a register.
+
+   Desirable on the 386 because a CALL with a constant address is
+   faster than one with a register address.  */
+
+#define NO_FUNCTION_CSE
+
+/* Define this macro if it is as good or better for a function to call
+   itself with an explicit address than to call an address kept in a
+   register.  */
+
+#define NO_RECURSIVE_FUNCTION_CSE
+
+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,
+   return the mode to be used for the comparison.
+
+   For floating-point equality comparisons, CCFPEQmode should be used.
+   VOIDmode should be used in all other cases.
+
+   For integer comparisons against zero, reduce to CCNOmode or CCZmode if
+   possible, to allow for more combinations.  */
+
+#define SELECT_CC_MODE(OP, X, Y) ix86_cc_mode ((OP), (X), (Y))
+
+/* Return nonzero if MODE implies a floating point inequality can be
+   reversed.  */
+
+#define REVERSIBLE_CC_MODE(MODE) 1
+
+/* A C expression whose value is reversed condition code of the CODE for
+   comparison done in CC_MODE mode.  */
+#define REVERSE_CONDITION(CODE, MODE) \
+  ((MODE) != CCFPmode && (MODE) != CCFPUmode ? reverse_condition (CODE) \
+   : reverse_condition_maybe_unordered (CODE))
+
+
+/* Control the assembler format that we output, to the extent
+   this does not vary between assemblers.  */
+
+/* How to refer to registers in assembler output.
+   This sequence is indexed by compiler's hard-register-number (see above).  */
+
+/* In order to refer to the first 8 regs as 32 bit regs prefix an "e"
+   For non floating point regs, the following are the HImode names.
+
+   For float regs, the stack top is sometimes referred to as "%st(0)"
+   instead of just "%st".  PRINT_OPERAND handles this with the "y" code.  */
+
+#define HI_REGISTER_NAMES						\
+{"ax","dx","cx","bx","si","di","bp","sp",				\
+ "st","st(1)","st(2)","st(3)","st(4)","st(5)","st(6)","st(7)",		\
+ "argp", "flags", "fpsr", "dirflag", "frame",				\
+ "xmm0","xmm1","xmm2","xmm3","xmm4","xmm5","xmm6","xmm7",		\
+ "mm0", "mm1", "mm2", "mm3", "mm4", "mm5", "mm6", "mm7"	,		\
+ "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",			\
+ "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14", "xmm15"}
+
+#define REGISTER_NAMES HI_REGISTER_NAMES
+
+/* Table of additional register names to use in user input.  */
+
+#define ADDITIONAL_REGISTER_NAMES \
+{ { "eax", 0 }, { "edx", 1 }, { "ecx", 2 }, { "ebx", 3 },	\
+  { "esi", 4 }, { "edi", 5 }, { "ebp", 6 }, { "esp", 7 },	\
+  { "rax", 0 }, { "rdx", 1 }, { "rcx", 2 }, { "rbx", 3 },	\
+  { "rsi", 4 }, { "rdi", 5 }, { "rbp", 6 }, { "rsp", 7 },	\
+  { "al", 0 }, { "dl", 1 }, { "cl", 2 }, { "bl", 3 },		\
+  { "ah", 0 }, { "dh", 1 }, { "ch", 2 }, { "bh", 3 },		\
+  { "mm0", 8},  { "mm1", 9},  { "mm2", 10}, { "mm3", 11},	\
+  { "mm4", 12}, { "mm5", 13}, { "mm6", 14}, { "mm7", 15} }
+
+/* Note we are omitting these since currently I don't know how
+to get gcc to use these, since they want the same but different
+number as al, and ax.
+*/
+
+#define QI_REGISTER_NAMES \
+{"al", "dl", "cl", "bl", "sil", "dil", "bpl", "spl",}
+
+/* These parallel the array above, and can be used to access bits 8:15
+   of regs 0 through 3.  */
+
+#define QI_HIGH_REGISTER_NAMES \
+{"ah", "dh", "ch", "bh", }
+
+/* How to renumber registers for dbx and gdb.  */
+
+#define DBX_REGISTER_NUMBER(N) \
+  (TARGET_64BIT ? dbx64_register_map[(N)] : dbx_register_map[(N)])
+
+extern int const dbx_register_map[FIRST_PSEUDO_REGISTER];
+extern int const dbx64_register_map[FIRST_PSEUDO_REGISTER];
+extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];
+
+/* Before the prologue, RA is at 0(%esp).  */
+#define INCOMING_RETURN_ADDR_RTX \
+  gen_rtx_MEM (VOIDmode, gen_rtx_REG (VOIDmode, STACK_POINTER_REGNUM))
+
+/* After the prologue, RA is at -4(AP) in the current frame.  */
+#define RETURN_ADDR_RTX(COUNT, FRAME)					   \
+  ((COUNT) == 0								   \
+   ? gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, -UNITS_PER_WORD)) \
+   : gen_rtx_MEM (Pmode, plus_constant (FRAME, UNITS_PER_WORD)))
+
+/* PC is dbx register 8; let's use that column for RA.  */
+#define DWARF_FRAME_RETURN_COLUMN 	(TARGET_64BIT ? 16 : 8)
+
+/* Before the prologue, the top of the frame is at 4(%esp).  */
+#define INCOMING_FRAME_SP_OFFSET UNITS_PER_WORD
+
+/* Describe how we implement __builtin_eh_return.  */
+#define EH_RETURN_DATA_REGNO(N)	((N) < 2 ? (N) : INVALID_REGNUM)
+#define EH_RETURN_STACKADJ_RTX	gen_rtx_REG (Pmode, 2)
+
+
+/* Select a format to encode pointers in exception handling data.  CODE
+   is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is
+   true if the symbol may be affected by dynamic relocations.
+
+   ??? All x86 object file formats are capable of representing this.
+   After all, the relocation needed is the same as for the call insn.
+   Whether or not a particular assembler allows us to enter such, I
+   guess we'll have to see.  */
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL)       		\
+  (flag_pic								\
+    ? ((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4\
+   : DW_EH_PE_absptr)
+
+/* This is how to output an insn to push a register on the stack.
+   It need not be very fast code.  */
+
+#define ASM_OUTPUT_REG_PUSH(FILE, REGNO)  \
+do {									\
+  if (TARGET_64BIT)							\
+    asm_fprintf ((FILE), "\tpush{q}\t%%r%s\n",				\
+		 reg_names[(REGNO)] + (REX_INT_REGNO_P (REGNO) != 0));	\
+  else									\
+    asm_fprintf ((FILE), "\tpush{l}\t%%e%s\n", reg_names[(REGNO)]);	\
+} while (0)
+
+/* This is how to output an insn to pop a register from the stack.
+   It need not be very fast code.  */
+
+#define ASM_OUTPUT_REG_POP(FILE, REGNO)  \
+do {									\
+  if (TARGET_64BIT)							\
+    asm_fprintf ((FILE), "\tpop{q}\t%%r%s\n",				\
+		 reg_names[(REGNO)] + (REX_INT_REGNO_P (REGNO) != 0));	\
+  else									\
+    asm_fprintf ((FILE), "\tpop{l}\t%%e%s\n", reg_names[(REGNO)]);	\
+} while (0)
+
+/* This is how to output an element of a case-vector that is absolute.  */
+
+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \
+  ix86_output_addr_vec_elt ((FILE), (VALUE))
+
+/* This is how to output an element of a case-vector that is relative.  */
+
+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \
+  ix86_output_addr_diff_elt ((FILE), (VALUE), (REL))
+
+/* Under some conditions we need jump tables in the text section, because
+   the assembler cannot handle label differences between sections.  */
+
+#define JUMP_TABLES_IN_TEXT_SECTION \
+  (!TARGET_64BIT && flag_pic && !HAVE_AS_GOTOFF_IN_DATA)
+
+/* A C statement that outputs an address constant appropriate to
+   for DWARF debugging.  */
+
+#define ASM_OUTPUT_DWARF_ADDR_CONST(FILE, X) \
+  i386_dwarf_output_addr_const ((FILE), (X))
+
+/* Emit a dtp-relative reference to a TLS variable.  */
+
+#ifdef HAVE_AS_TLS
+#define ASM_OUTPUT_DWARF_DTPREL(FILE, SIZE, X) \
+  i386_output_dwarf_dtprel (FILE, SIZE, X)
+#endif
+
+/* Switch to init or fini section via SECTION_OP, emit a call to FUNC,
+   and switch back.  For x86 we do this only to save a few bytes that
+   would otherwise be unused in the text section.  */
+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)	\
+   asm (SECTION_OP "\n\t"				\
+	"call " USER_LABEL_PREFIX #FUNC "\n"		\
+	TEXT_SECTION_ASM_OP);
+
+/* Print operand X (an rtx) in assembler syntax to file FILE.
+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.
+   Effect of various CODE letters is described in i386.c near
+   print_operand function.  */
+
+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) \
+  ((CODE) == '*' || (CODE) == '+' || (CODE) == '&')
+
+#define PRINT_OPERAND(FILE, X, CODE)  \
+  print_operand ((FILE), (X), (CODE))
+
+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \
+  print_operand_address ((FILE), (ADDR))
+
+#define OUTPUT_ADDR_CONST_EXTRA(FILE, X, FAIL)	\
+do {						\
+  if (! output_addr_const_extra (FILE, (X)))	\
+    goto FAIL;					\
+} while (0);
+
+/* a letter which is not needed by the normal asm syntax, which
+   we can use for operand syntax in the extended asm */
+
+#define ASM_OPERAND_LETTER '#'
+#define RET return ""
+#define AT_SP(MODE) (gen_rtx_MEM ((MODE), stack_pointer_rtx))
+
+/* Define the codes that are matched by predicates in i386.c.  */
+
+#define PREDICATE_CODES							\
+  {"x86_64_immediate_operand", {CONST_INT, SUBREG, REG,			\
+				SYMBOL_REF, LABEL_REF, CONST}},		\
+  {"x86_64_nonmemory_operand", {CONST_INT, SUBREG, REG,			\
+				SYMBOL_REF, LABEL_REF, CONST}},		\
+  {"x86_64_movabs_operand", {CONST_INT, SUBREG, REG,			\
+				SYMBOL_REF, LABEL_REF, CONST}},		\
+  {"x86_64_szext_nonmemory_operand", {CONST_INT, SUBREG, REG,		\
+				     SYMBOL_REF, LABEL_REF, CONST}},	\
+  {"x86_64_general_operand", {CONST_INT, SUBREG, REG, MEM,		\
+			      SYMBOL_REF, LABEL_REF, CONST}},		\
+  {"x86_64_szext_general_operand", {CONST_INT, SUBREG, REG, MEM,	\
+				   SYMBOL_REF, LABEL_REF, CONST}},	\
+  {"x86_64_zext_immediate_operand", {CONST_INT, CONST_DOUBLE, CONST,	\
+				       SYMBOL_REF, LABEL_REF}},		\
+  {"shiftdi_operand", {SUBREG, REG, MEM}},				\
+  {"const_int_1_31_operand", {CONST_INT}},				\
+  {"symbolic_operand", {SYMBOL_REF, LABEL_REF, CONST}},			\
+  {"aligned_operand", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,	\
+		       LABEL_REF, SUBREG, REG, MEM}},			\
+  {"pic_symbolic_operand", {CONST}},					\
+  {"call_insn_operand", {REG, SUBREG, MEM, SYMBOL_REF}},		\
+  {"sibcall_insn_operand", {REG, SUBREG, SYMBOL_REF}},			\
+  {"constant_call_address_operand", {SYMBOL_REF, CONST}},		\
+  {"const0_operand", {CONST_INT, CONST_DOUBLE}},			\
+  {"const1_operand", {CONST_INT}},					\
+  {"const248_operand", {CONST_INT}},					\
+  {"const_0_to_3_operand", {CONST_INT}},				\
+  {"const_0_to_7_operand", {CONST_INT}},				\
+  {"const_0_to_15_operand", {CONST_INT}},				\
+  {"const_0_to_255_operand", {CONST_INT}},				\
+  {"incdec_operand", {CONST_INT}},					\
+  {"mmx_reg_operand", {REG}},						\
+  {"reg_no_sp_operand", {SUBREG, REG}},					\
+  {"general_no_elim_operand", {CONST_INT, CONST_DOUBLE, CONST,		\
+			SYMBOL_REF, LABEL_REF, SUBREG, REG, MEM}},	\
+  {"nonmemory_no_elim_operand", {CONST_INT, REG, SUBREG}},		\
+  {"index_register_operand", {SUBREG, REG}},				\
+  {"flags_reg_operand", {REG}},						\
+  {"q_regs_operand", {SUBREG, REG}},					\
+  {"non_q_regs_operand", {SUBREG, REG}},				\
+  {"fcmov_comparison_operator", {EQ, NE, LTU, GTU, LEU, GEU, UNORDERED, \
+				 ORDERED, LT, UNLT, GT, UNGT, LE, UNLE,	\
+				 GE, UNGE, LTGT, UNEQ}},		\
+  {"sse_comparison_operator", {EQ, LT, LE, UNORDERED, NE, UNGE, UNGT,	\
+			       ORDERED, UNEQ, UNLT, UNLE, LTGT, GE, GT	\
+			       }},					\
+  {"ix86_comparison_operator", {EQ, NE, LE, LT, GE, GT, LEU, LTU, GEU,	\
+			       GTU, UNORDERED, ORDERED, UNLE, UNLT,	\
+			       UNGE, UNGT, LTGT, UNEQ }},		\
+  {"ix86_carry_flag_operator", {LTU, LT, UNLT, GT, UNGT, LE, UNLE,	\
+				 GE, UNGE, LTGT, UNEQ}},		\
+  {"cmp_fp_expander_operand", {CONST_DOUBLE, SUBREG, REG, MEM}},	\
+  {"ext_register_operand", {SUBREG, REG}},				\
+  {"binary_fp_operator", {PLUS, MINUS, MULT, DIV}},			\
+  {"mult_operator", {MULT}},						\
+  {"div_operator", {DIV}},						\
+  {"arith_or_logical_operator", {PLUS, MULT, AND, IOR, XOR, SMIN, SMAX, \
+				 UMIN, UMAX, COMPARE, MINUS, DIV, MOD,	\
+				 UDIV, UMOD, ASHIFT, ROTATE, ASHIFTRT,	\
+				 LSHIFTRT, ROTATERT}},			\
+  {"promotable_binary_operator", {PLUS, MULT, AND, IOR, XOR, ASHIFT}},	\
+  {"memory_displacement_operand", {MEM}},				\
+  {"cmpsi_operand", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,	\
+		     LABEL_REF, SUBREG, REG, MEM, AND}},		\
+  {"long_memory_operand", {MEM}},					\
+  {"tls_symbolic_operand", {SYMBOL_REF}},				\
+  {"global_dynamic_symbolic_operand", {SYMBOL_REF}},			\
+  {"local_dynamic_symbolic_operand", {SYMBOL_REF}},			\
+  {"initial_exec_symbolic_operand", {SYMBOL_REF}},			\
+  {"local_exec_symbolic_operand", {SYMBOL_REF}},			\
+  {"any_fp_register_operand", {REG}},					\
+  {"register_and_not_any_fp_reg_operand", {REG}},			\
+  {"fp_register_operand", {REG}},					\
+  {"register_and_not_fp_reg_operand", {REG}},				\
+  {"zero_extended_scalar_load_operand", {MEM}},				\
+  {"vector_move_operand", {CONST_VECTOR, SUBREG, REG, MEM}},		\
+  {"no_seg_address_operand", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF, \
+			      LABEL_REF, SUBREG, REG, MEM, PLUS, MULT}},
+
+/* A list of predicates that do special things with modes, and so
+   should not elicit warnings for VOIDmode match_operand.  */
+
+#define SPECIAL_MODE_PREDICATES \
+  "ext_register_operand",
+
+/* Which processor to schedule for. The cpu attribute defines a list that
+   mirrors this list, so changes to i386.md must be made at the same time.  */
+
+enum processor_type
+{
+  PROCESSOR_I386,			/* 80386 */
+  PROCESSOR_I486,			/* 80486DX, 80486SX, 80486DX[24] */
+  PROCESSOR_PENTIUM,
+  PROCESSOR_PENTIUMPRO,
+  PROCESSOR_K6,
+  PROCESSOR_ATHLON,
+  PROCESSOR_PENTIUM4,
+  PROCESSOR_K8,
+  PROCESSOR_max
+};
+
+extern enum processor_type ix86_tune;
+extern const char *ix86_tune_string;
+
+extern enum processor_type ix86_arch;
+extern const char *ix86_arch_string;
+
+enum fpmath_unit
+{
+  FPMATH_387 = 1,
+  FPMATH_SSE = 2
+};
+
+extern enum fpmath_unit ix86_fpmath;
+extern const char *ix86_fpmath_string;
+
+enum tls_dialect
+{
+  TLS_DIALECT_GNU,
+  TLS_DIALECT_SUN
+};
+
+extern enum tls_dialect ix86_tls_dialect;
+extern const char *ix86_tls_dialect_string;
+
+enum cmodel {
+  CM_32,	/* The traditional 32-bit ABI.  */
+  CM_SMALL,	/* Assumes all code and data fits in the low 31 bits.  */
+  CM_KERNEL,	/* Assumes all code and data fits in the high 31 bits.  */
+  CM_MEDIUM,	/* Assumes code fits in the low 31 bits; data unlimited.  */
+  CM_LARGE,	/* No assumptions.  */
+  CM_SMALL_PIC	/* Assumes code+data+got/plt fits in a 31 bit region.  */
+};
+
+extern enum cmodel ix86_cmodel;
+extern const char *ix86_cmodel_string;
+
+/* Size of the RED_ZONE area.  */
+#define RED_ZONE_SIZE 128
+/* Reserved area of the red zone for temporaries.  */
+#define RED_ZONE_RESERVE 8
+
+enum asm_dialect {
+  ASM_ATT,
+  ASM_INTEL
+};
+
+extern const char *ix86_asm_string;
+extern enum asm_dialect ix86_asm_dialect;
+
+extern int ix86_regparm;
+extern const char *ix86_regparm_string;
+
+extern int ix86_preferred_stack_boundary;
+extern const char *ix86_preferred_stack_boundary_string;
+
+extern int ix86_branch_cost;
+extern const char *ix86_branch_cost_string;
+
+extern const char *ix86_debug_arg_string;
+extern const char *ix86_debug_addr_string;
+
+/* Obsoleted by -f options.  Remove before 3.2 ships.  */
+extern const char *ix86_align_loops_string;
+extern const char *ix86_align_jumps_string;
+extern const char *ix86_align_funcs_string;
+
+/* Smallest class containing REGNO.  */
+extern enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER];
+
+extern rtx ix86_compare_op0;	/* operand 0 for comparisons */
+extern rtx ix86_compare_op1;	/* operand 1 for comparisons */
+
+/* To properly truncate FP values into integers, we need to set i387 control
+   word.  We can't emit proper mode switching code before reload, as spills
+   generated by reload may truncate values incorrectly, but we still can avoid
+   redundant computation of new control word by the mode switching pass.
+   The fldcw instructions are still emitted redundantly, but this is probably
+   not going to be noticeable problem, as most CPUs do have fast path for
+   the sequence.
+
+   The machinery is to emit simple truncation instructions and split them
+   before reload to instructions having USEs of two memory locations that
+   are filled by this code to old and new control word.
+
+   Post-reload pass may be later used to eliminate the redundant fildcw if
+   needed.  */
+
+enum fp_cw_mode {FP_CW_STORED, FP_CW_UNINITIALIZED, FP_CW_ANY};
+
+/* Define this macro if the port needs extra instructions inserted
+   for mode switching in an optimizing compilation.  */
+
+#define OPTIMIZE_MODE_SWITCHING(ENTITY) ix86_optimize_mode_switching
+
+/* If you define `OPTIMIZE_MODE_SWITCHING', you have to define this as
+   initializer for an array of integers.  Each initializer element N
+   refers to an entity that needs mode switching, and specifies the
+   number of different modes that might need to be set for this
+   entity.  The position of the initializer in the initializer -
+   starting counting at zero - determines the integer that is used to
+   refer to the mode-switched entity in question.  */
+
+#define NUM_MODES_FOR_MODE_SWITCHING { FP_CW_ANY }
+
+/* ENTITY is an integer specifying a mode-switched entity.  If
+   `OPTIMIZE_MODE_SWITCHING' is defined, you must define this macro to
+   return an integer value not larger than the corresponding element
+   in `NUM_MODES_FOR_MODE_SWITCHING', to denote the mode that ENTITY
+   must be switched into prior to the execution of INSN.  */
+
+#define MODE_NEEDED(ENTITY, I)						\
+  (GET_CODE (I) == CALL_INSN						\
+   || (GET_CODE (I) == INSN && (asm_noperands (PATTERN (I)) >= 0 	\
+				|| GET_CODE (PATTERN (I)) == ASM_INPUT))\
+   ? FP_CW_UNINITIALIZED						\
+   : recog_memoized (I) < 0 || get_attr_type (I) != TYPE_FISTP		\
+   ? FP_CW_ANY								\
+   : FP_CW_STORED)
+
+/* This macro specifies the order in which modes for ENTITY are
+   processed.  0 is the highest priority.  */
+
+#define MODE_PRIORITY_TO_MODE(ENTITY, N) (N)
+
+/* Generate one or more insns to set ENTITY to MODE.  HARD_REG_LIVE
+   is the set of hard registers live at the point where the insn(s)
+   are to be inserted.  */
+
+#define EMIT_MODE_SET(ENTITY, MODE, HARD_REGS_LIVE) 			\
+  ((MODE) == FP_CW_STORED						\
+   ? emit_i387_cw_initialization (assign_386_stack_local (HImode, 1),	\
+				  assign_386_stack_local (HImode, 2)), 0\
+   : 0)
+
+/* Avoid renaming of stack registers, as doing so in combination with
+   scheduling just increases amount of live registers at time and in
+   the turn amount of fxch instructions needed.
+
+   ??? Maybe Pentium chips benefits from renaming, someone can try....  */
+
+#define HARD_REGNO_RENAME_OK(SRC, TARGET)  \
+   ((SRC) < FIRST_STACK_REG || (SRC) > LAST_STACK_REG)
+
+
+#define DLL_IMPORT_EXPORT_PREFIX '#'
+
+#define FASTCALL_PREFIX '@'
+
+struct machine_function GTY(())
+{
+  struct stack_local_entry *stack_locals;
+  const char *some_ld_name;
+  int save_varrargs_registers;
+  int accesses_prev_frame;
+  int optimize_mode_switching;
+  /* Set by ix86_compute_frame_layout and used by prologue/epilogue expander to
+     determine the style used.  */
+  int use_fast_prologue_epilogue;
+  /* Number of saved registers USE_FAST_PROLOGUE_EPILOGUE has been computed
+     for.  */
+  int use_fast_prologue_epilogue_nregs;
+};
+
+#define ix86_stack_locals (cfun->machine->stack_locals)
+#define ix86_save_varrargs_registers (cfun->machine->save_varrargs_registers)
+#define ix86_optimize_mode_switching (cfun->machine->optimize_mode_switching)
+
+/* Control behavior of x86_file_start.  */
+#define X86_FILE_START_VERSION_DIRECTIVE false
+#define X86_FILE_START_FLTUSED false
+
+/*
+Local variables:
+version-control: t
+End:
+*/
diff -urN linux-2.6.9_orig/lib/gcc/config/i386/linux.h linux-2.6.9/lib/gcc/config/i386/linux.h
--- linux-2.6.9_orig/lib/gcc/config/i386/linux.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/config/i386/linux.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,279 @@
+/* Definitions for Intel 386 running Linux-based GNU systems with ELF format.
+   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002
+   Free Software Foundation, Inc.
+   Contributed by Eric Youngdale.
+   Modified for stabs-in-ELF by H.J. Lu.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Output at beginning of assembler file.  */
+/* The .file command should always begin the output.  */
+#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true
+
+#define TARGET_VERSION fprintf (stderr, " (i386 Linux/ELF)");
+
+/* The svr4 ABI for the i386 says that records and unions are returned
+   in memory.  */
+#undef DEFAULT_PCC_STRUCT_RETURN
+#define DEFAULT_PCC_STRUCT_RETURN 1
+
+/* We arrange for the whole %gs segment to map the tls area.  */
+#undef TARGET_TLS_DIRECT_SEG_REFS_DEFAULT
+#define TARGET_TLS_DIRECT_SEG_REFS_DEFAULT MASK_TLS_DIRECT_SEG_REFS
+
+#undef ASM_COMMENT_START
+#define ASM_COMMENT_START "#"
+
+#undef DBX_REGISTER_NUMBER
+#define DBX_REGISTER_NUMBER(n) \
+  (TARGET_64BIT ? dbx64_register_map[n] : svr4_dbx_register_map[n])
+
+/* Output assembler code to FILE to call the profiler.
+   To the best of my knowledge, no Linux libc has required the label
+   argument to mcount.  */
+
+#define NO_PROFILE_COUNTERS	1
+
+#undef MCOUNT_NAME
+#define MCOUNT_NAME "mcount"
+
+/* The GLIBC version of mcount for the x86 assumes that there is a
+   frame, so we cannot allow profiling without a frame pointer.  */
+
+#undef SUBTARGET_FRAME_POINTER_REQUIRED
+#define SUBTARGET_FRAME_POINTER_REQUIRED current_function_profile
+
+#undef SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+ 
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+  
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "long int"
+   
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE BITS_PER_WORD
+    
+#define TARGET_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+	LINUX_TARGET_OS_CPP_BUILTINS();		\
+	if (flag_pic)				\
+	  {					\
+	    builtin_define ("__PIC__");		\
+	    builtin_define ("__pic__");		\
+	  }					\
+    }						\
+  while (0)
+
+#undef CPP_SPEC
+#ifdef USE_GNULIBC_1
+#define CPP_SPEC "%{posix:-D_POSIX_SOURCE}"
+#else
+#define CPP_SPEC "%{posix:-D_POSIX_SOURCE} %{pthread:-D_REENTRANT}"
+#endif
+
+#undef CC1_SPEC
+#define CC1_SPEC "%(cc1_cpu) %{profile:-p}"
+
+/* Provide a LINK_SPEC appropriate for Linux.  Here we provide support
+   for the special GCC options -static and -shared, which allow us to
+   link things in one of these three modes by applying the appropriate
+   combinations of options at link-time. We like to support here for
+   as many of the other GNU linker options as possible. But I don't
+   have the time to search for those flags. I am sure how to add
+   support for -soname shared_object_name. H.J.
+
+   I took out %{v:%{!V:-V}}. It is too much :-(. They can use
+   -Wl,-V.
+
+   When the -shared link option is used a final link is not being
+   done.  */
+
+/* If ELF is the default format, we should not use /lib/elf.  */
+
+#undef	LINK_SPEC
+#ifdef USE_GNULIBC_1
+#define LINK_SPEC "-m elf_i386 %{shared:-shared} \
+  %{!shared: \
+    %{!ibcs: \
+      %{!static: \
+	%{rdynamic:-export-dynamic} \
+	%{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.1}} \
+	%{static:-static}}}"
+#else
+#define LINK_SPEC "-m elf_i386 %{shared:-shared} \
+  %{!shared: \
+    %{!ibcs: \
+      %{!static: \
+	%{rdynamic:-export-dynamic} \
+	%{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2}} \
+	%{static:-static}}}"
+#endif
+
+/* A C statement (sans semicolon) to output to the stdio stream
+   FILE the assembler definition of uninitialized global DECL named
+   NAME whose size is SIZE bytes and alignment is ALIGN bytes.
+   Try to use asm_output_aligned_bss to implement this macro.  */
+
+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
+  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)
+
+/* A C statement to output to the stdio stream FILE an assembler
+   command to advance the location counter to a multiple of 1<<LOG
+   bytes if it is within MAX_SKIP bytes.
+
+   This is used to align code labels according to Intel recommendations.  */
+
+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN
+#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP)			\
+  do {									\
+    if ((LOG) != 0) {							\
+      if ((MAX_SKIP) == 0) fprintf ((FILE), "\t.p2align %d\n", (LOG));	\
+      else fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP));	\
+    }									\
+  } while (0)
+#endif
+
+#if defined(__PIC__) && defined (USE_GNULIBC_1)
+/* This is a kludge. The i386 GNU/Linux dynamic linker needs ___brk_addr,
+   __environ and atexit.  We have to make sure they are in the .dynsym
+   section.  We do this by forcing the assembler to create undefined 
+   references to these symbols in the object file.  */
+#undef CRT_CALL_STATIC_FUNCTION
+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)	\
+   asm (SECTION_OP "\n\t"				\
+	"call " USER_LABEL_PREFIX #FUNC "\n"		\
+	TEXT_SECTION_ASM_OP "\n\t"			\
+	".extern ___brk_addr\n\t"			\
+	".type ___brk_addr,@object\n\t"			\
+	".extern __environ\n\t"				\
+	".type __environ,@object\n\t"			\
+	".extern atexit\n\t"				\
+	".type atexit,@function");
+#endif
+
+/* Handle special EH pointer encodings.  Absolute, pc-relative, and
+   indirect are handled automatically.  */
+#define ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX(FILE, ENCODING, SIZE, ADDR, DONE) \
+  do {									\
+    if ((SIZE) == 4 && ((ENCODING) & 0x70) == DW_EH_PE_datarel)		\
+      {									\
+        fputs (ASM_LONG, FILE);			\
+        assemble_name (FILE, XSTR (ADDR, 0));				\
+	fputs (((ENCODING) & DW_EH_PE_indirect ? "@GOT" : "@GOTOFF"), FILE); \
+        goto DONE;							\
+      }									\
+  } while (0)
+
+/* Used by crtstuff.c to initialize the base of data-relative relocations.
+   These are GOT relative on x86, so return the pic register.  */
+#ifdef __PIC__
+#define CRT_GET_RFIB_DATA(BASE)			\
+  {						\
+    register void *ebx_ __asm__("ebx");		\
+    BASE = ebx_;				\
+  }
+#else
+#define CRT_GET_RFIB_DATA(BASE)						\
+  __asm__ ("call\t.LPR%=\n"						\
+	   ".LPR%=:\n\t"						\
+	   "popl\t%0\n\t"						\
+	   /* Due to a GAS bug, this cannot use EAX.  That encodes	\
+	      smaller than the traditional EBX, which results in the	\
+	      offset being off by one.  */				\
+	   "addl\t$_GLOBAL_OFFSET_TABLE_+[.-.LPR%=],%0"			\
+	   : "=d"(BASE))
+#endif
+
+// if we are in the kernel we do not have any dynamic linking
+#ifdef __KERNEL__
+#undef CRT_GET_RFIB_DATA
+#endif
+
+#undef NEED_INDICATE_EXEC_STACK
+#define NEED_INDICATE_EXEC_STACK 1
+
+/* Do code reading to identify a signal frame, and set the frame
+   state data appropriately.  See unwind-dw2.c for the structs.  */
+
+#ifdef IN_LIBGCC2
+/* There's no sys/ucontext.h for some (all?) libc1, so no
+   signal-turned-exceptions for them.  There's also no configure-run for
+   the target, so we can't check on (e.g.) HAVE_SYS_UCONTEXT_H.  Using the
+   target libc1 macro should be enough.  */
+#if !(defined (USE_GNULIBC_1) || (__GLIBC__ == 2 && __GLIBC_MINOR__ == 0))
+#include <signal.h>
+#include <sys/ucontext.h>
+
+#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)		\
+  do {									\
+    unsigned char *pc_ = (CONTEXT)->ra;					\
+    struct sigcontext *sc_;						\
+    long new_cfa_;							\
+									\
+    /* popl %eax ; movl $__NR_sigreturn,%eax ; int $0x80  */		\
+    if (*(unsigned short *)(pc_+0) == 0xb858				\
+	&& *(unsigned int *)(pc_+2) == 119				\
+	&& *(unsigned short *)(pc_+6) == 0x80cd)			\
+      sc_ = (CONTEXT)->cfa + 4;						\
+    /* movl $__NR_rt_sigreturn,%eax ; int $0x80  */			\
+    else if (*(unsigned char *)(pc_+0) == 0xb8				\
+	     && *(unsigned int *)(pc_+1) == 173				\
+	     && *(unsigned short *)(pc_+5) == 0x80cd)			\
+      {									\
+	struct rt_sigframe {						\
+	  int sig;							\
+	  struct siginfo *pinfo;					\
+	  void *puc;							\
+	  struct siginfo info;						\
+	  struct ucontext uc;						\
+	} *rt_ = (CONTEXT)->cfa;					\
+	sc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;		\
+      }									\
+    else								\
+      break;								\
+									\
+    new_cfa_ = sc_->esp;						\
+    (FS)->cfa_how = CFA_REG_OFFSET;					\
+    (FS)->cfa_reg = 4;							\
+    (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;		\
+									\
+    /* The SVR4 register numbering macros aren't usable in libgcc.  */	\
+    (FS)->regs.reg[0].how = REG_SAVED_OFFSET;				\
+    (FS)->regs.reg[0].loc.offset = (long)&sc_->eax - new_cfa_;		\
+    (FS)->regs.reg[3].how = REG_SAVED_OFFSET;				\
+    (FS)->regs.reg[3].loc.offset = (long)&sc_->ebx - new_cfa_;		\
+    (FS)->regs.reg[1].how = REG_SAVED_OFFSET;				\
+    (FS)->regs.reg[1].loc.offset = (long)&sc_->ecx - new_cfa_;		\
+    (FS)->regs.reg[2].how = REG_SAVED_OFFSET;				\
+    (FS)->regs.reg[2].loc.offset = (long)&sc_->edx - new_cfa_;		\
+    (FS)->regs.reg[6].how = REG_SAVED_OFFSET;				\
+    (FS)->regs.reg[6].loc.offset = (long)&sc_->esi - new_cfa_;		\
+    (FS)->regs.reg[7].how = REG_SAVED_OFFSET;				\
+    (FS)->regs.reg[7].loc.offset = (long)&sc_->edi - new_cfa_;		\
+    (FS)->regs.reg[5].how = REG_SAVED_OFFSET;				\
+    (FS)->regs.reg[5].loc.offset = (long)&sc_->ebp - new_cfa_;		\
+    (FS)->regs.reg[8].how = REG_SAVED_OFFSET;				\
+    (FS)->regs.reg[8].loc.offset = (long)&sc_->eip - new_cfa_;		\
+    (FS)->retaddr_column = 8;						\
+    goto SUCCESS;							\
+  } while (0)
+#endif /* not USE_GNULIBC_1 */
+#endif /* IN_LIBGCC2 */
diff -urN linux-2.6.9_orig/lib/gcc/config/i386/unix.h linux-2.6.9/lib/gcc/config/i386/unix.h
--- linux-2.6.9_orig/lib/gcc/config/i386/unix.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/config/i386/unix.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,65 @@
+/* Definitions for Unix assembler syntax for the Intel 80386.
+   Copyright (C) 1988, 1994, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* This file defines the aspects of assembler syntax
+   that are the same for all the i386 Unix systems
+   (though they may differ in non-Unix systems).  */
+
+/* Define macro used to output shift-double opcodes when the shift
+   count is in %cl.  Some assemblers require %cl as an argument;
+   some don't.  This macro controls what to do: by default, don't
+   print %cl.  */
+#define SHIFT_DOUBLE_OMITS_COUNT 1
+
+/* Define the syntax of pseudo-ops, labels and comments.  */
+
+/* String containing the assembler's comment-starter.  */
+
+#define ASM_COMMENT_START "/"
+
+/* Output to assembler file text saying following lines
+   may contain character constants, extra white space, comments, etc.  */
+
+#define ASM_APP_ON "/APP\n"
+
+/* Output to assembler file text saying following lines
+   no longer contain unusual constructs.  */
+
+#define ASM_APP_OFF "/NO_APP\n"
+
+/* Output before read-only data.  */
+
+#define TEXT_SECTION_ASM_OP "\t.text"
+
+/* Output before writable (initialized) data.  */
+
+#define DATA_SECTION_ASM_OP "\t.data"
+
+/* Output before writable (uninitialized) data.  */
+
+#define BSS_SECTION_ASM_OP "\t.bss"
+
+/* Globalizing directive for a label.  */
+#define GLOBAL_ASM_OP ".globl "
+
+/* By default, target has a 80387, uses IEEE compatible arithmetic,
+   and returns float values in the 387.  */
+
+#define TARGET_SUBTARGET_DEFAULT (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS)
diff -urN linux-2.6.9_orig/lib/gcc/config/linux.h linux-2.6.9/lib/gcc/config/linux.h
--- linux-2.6.9_orig/lib/gcc/config/linux.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/config/linux.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,126 @@
+/* Definitions for Linux-based GNU systems with ELF format
+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2003
+   Free Software Foundation, Inc.
+   Contributed by Eric Youngdale.
+   Modified for stabs-in-ELF by H.J. Lu (hjl@lucon.org).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Don't assume anything about the header files.  */
+#define NO_IMPLICIT_EXTERN_C
+
+#undef ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+#undef MD_EXEC_PREFIX
+#undef MD_STARTFILE_PREFIX
+
+/* Provide a STARTFILE_SPEC appropriate for GNU/Linux.  Here we add
+   the GNU/Linux magical crtbegin.o file (see crtstuff.c) which
+   provides part of the support for getting C++ file-scope static
+   object constructed before entering `main'.  */
+   
+#undef	STARTFILE_SPEC
+#ifdef USE_GNULIBC_1
+#define STARTFILE_SPEC \
+  "%{!shared: \
+     %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} \
+		       %{!p:%{profile:gcrt1.o%s} \
+			 %{!profile:crt1.o%s}}}} \
+   crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
+#elif defined HAVE_LD_PIE
+#define STARTFILE_SPEC \
+  "%{!shared: %{pg|p|profile:gcrt1.o%s;pie:Scrt1.o%s;:crt1.o%s}} \
+   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+#else
+#define STARTFILE_SPEC \
+  "%{!shared: %{pg|p|profile:gcrt1.o%s;:crt1.o%s}} \
+   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+#endif
+
+/* Provide a ENDFILE_SPEC appropriate for GNU/Linux.  Here we tack on
+   the GNU/Linux magical crtend.o file (see crtstuff.c) which
+   provides part of the support for getting C++ file-scope static
+   object constructed before entering `main', followed by a normal
+   GNU/Linux "finalizer" file, `crtn.o'.  */
+
+#undef	ENDFILE_SPEC
+#define ENDFILE_SPEC \
+  "%{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
+
+/* This is for -profile to use -lc_p instead of -lc.  */
+#ifndef CC1_SPEC
+#define CC1_SPEC "%{profile:-p}"
+#endif
+
+/* The GNU C++ standard library requires that these macros be defined.  */
+#undef CPLUSPLUS_CPP_SPEC
+#define CPLUSPLUS_CPP_SPEC "-D_GNU_SOURCE %(cpp)"
+
+#undef	LIB_SPEC
+/* We no longer link with libc_p.a or libg.a by default. If you
+   want to profile or debug the GNU/Linux C library, please add
+   -profile or -ggdb to LDFLAGS at the link time, respectively.  */
+#if 1
+#ifdef USE_GNULIBC_1
+#define LIB_SPEC \
+  "%{!shared: %{p:-lgmon} %{pg:-lgmon} %{profile:-lgmon -lc_p} \
+     %{!profile:%{!ggdb:-lc} %{ggdb:-lg}}}"
+#else
+#define LIB_SPEC \
+  "%{pthread:-lpthread} \
+   %{shared:-lc} \
+   %{!shared:%{mieee-fp:-lieee} %{profile:-lc_p}%{!profile:-lc}}"
+#endif
+#else
+#define LIB_SPEC \
+  "%{!shared: \
+     %{p:-lgmon -lc_p} %{pg:-lgmon -lc_p} \
+       %{!p:%{!pg:%{!g*:-lc} %{g*:-lg}}}}"
+#endif
+
+#define LINUX_TARGET_OS_CPP_BUILTINS()				\
+    do {							\
+	builtin_define ("__gnu_linux__");			\
+	builtin_define_std ("linux");				\
+	builtin_define_std ("unix");				\
+	builtin_assert ("system=linux");			\
+	builtin_assert ("system=unix");				\
+	builtin_assert ("system=posix");			\
+    } while (0)
+
+#if !defined(USE_GNULIBC_1) && defined(HAVE_LD_EH_FRAME_HDR)
+#define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
+#endif
+
+/* Define this so we can compile MS code for use with WINE.  */
+#define HANDLE_PRAGMA_PACK_PUSH_POP
+
+#define LINK_GCC_C_SEQUENCE_SPEC \
+  "%{static:--start-group} %G %L %{static:--end-group}%{!static:%G}"
+
+/* Determine whether the the entire c99 runtime
+   is present in the runtime library.  */
+#ifndef USE_GNULIBC_1
+#define TARGET_C99_FUNCTIONS 1
+#endif
+
+#define TARGET_HAS_F_SETLKW
diff -urN linux-2.6.9_orig/lib/gcc/config/svr4.h linux-2.6.9/lib/gcc/config/svr4.h
--- linux-2.6.9_orig/lib/gcc/config/svr4.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/config/svr4.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,206 @@
+/* Operating system specific defines to be used when targeting GCC for some
+   generic System V Release 4 system.
+   Copyright (C) 1991, 1994, 1995, 1996, 1997, 1998, 1999,
+   2000, 2001 Free Software Foundation, Inc.
+   Contributed by Ron Guilmette (rfg@monkeys.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.
+
+   To use this file, make up a line like that in config.gcc:
+
+	tm_file="$tm_file elfos.h svr4.h MACHINE/svr4.h"
+
+   where MACHINE is replaced by the name of the basic hardware that you
+   are targeting for.  Then, in the file MACHINE/svr4.h, put any really
+   system-specific defines (or overrides of defines) which you find that
+   you need.
+*/
+
+/* Define a symbol indicating that we are using svr4.h.  */
+#define USING_SVR4_H
+
+/* Cpp, assembler, linker, library, and startfile spec's.  */
+
+/* This defines which switch letters take arguments.  On svr4, most of
+   the normal cases (defined in gcc.c) apply, and we also have -h* and
+   -z* options (for the linker).  Note however that there is no such
+   thing as a -T option for svr4.  */
+
+#undef  SWITCH_TAKES_ARG
+#define SWITCH_TAKES_ARG(CHAR)		\
+  (DEFAULT_SWITCH_TAKES_ARG (CHAR)	\
+   || (CHAR) == 'h'			\
+   || (CHAR) == 'x'			\
+   || (CHAR) == 'z')
+
+/* This defines which multi-letter switches take arguments.  On svr4,
+   there are no such switches except those implemented by GCC itself.  */
+
+#define WORD_SWITCH_TAKES_ARG(STR)			\
+ (DEFAULT_WORD_SWITCH_TAKES_ARG (STR)			\
+  && strcmp (STR, "Tdata") && strcmp (STR, "Ttext")	\
+  && strcmp (STR, "Tbss"))
+
+/* Provide an ASM_SPEC appropriate for svr4.  Here we try to support as
+   many of the specialized svr4 assembler options as seems reasonable,
+   given that there are certain options which we can't (or shouldn't)
+   support directly due to the fact that they conflict with other options
+   for other svr4 tools (e.g. ld) or with other options for GCC itself.
+   For example, we don't support the -o (output file) or -R (remove
+   input file) options because GCC already handles these things.  We
+   also don't support the -m (run m4) option for the assembler because
+   that conflicts with the -m (produce load map) option of the svr4
+   linker.  We do however allow passing arbitrary options to the svr4
+   assembler via the -Wa, option.
+
+   Note that gcc doesn't allow a space to follow -Y in a -Ym,* or -Yd,*
+   option.
+
+   The svr4 assembler wants '-' on the command line if it's expected to
+   read its stdin.
+*/
+
+#undef  ASM_SPEC
+#define ASM_SPEC \
+  "%{v:-V} %{Qy:} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*}"
+
+#define AS_NEEDS_DASH_FOR_PIPED_INPUT
+
+/* Under svr4, the normal location of the `ld' and `as' programs is the
+   /usr/ccs/bin directory.  */
+
+#ifndef CROSS_COMPILE
+#undef  MD_EXEC_PREFIX
+#define MD_EXEC_PREFIX "/usr/ccs/bin/"
+#endif
+
+/* Under svr4, the normal location of the various *crt*.o files is the
+   /usr/ccs/lib directory.  */
+
+#ifndef CROSS_COMPILE
+#undef  MD_STARTFILE_PREFIX
+#define MD_STARTFILE_PREFIX "/usr/ccs/lib/"
+#endif
+
+/* Provide a LIB_SPEC appropriate for svr4.  Here we tack on the default
+   standard C library (unless we are building a shared library).  */
+
+#undef	LIB_SPEC
+#define LIB_SPEC "%{!shared:%{!symbolic:-lc}}"
+
+/* Provide an ENDFILE_SPEC appropriate for svr4.  Here we tack on our own
+   magical crtend.o file (see crtstuff.c) which provides part of the
+   support for getting C++ file-scope static object constructed before
+   entering `main', followed by the normal svr3/svr4 "finalizer" file,
+   which is either `gcrtn.o' or `crtn.o'.  */
+
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC "crtend.o%s %{pg:gcrtn.o%s}%{!pg:crtn.o%s}"
+
+/* Provide a LINK_SPEC appropriate for svr4.  Here we provide support
+   for the special GCC options -static, -shared, and -symbolic which
+   allow us to link things in one of these three modes by applying the
+   appropriate combinations of options at link-time.  We also provide
+   support here for as many of the other svr4 linker options as seems
+   reasonable, given that some of them conflict with options for other
+   svr4 tools (e.g. the assembler).  In particular, we do support the
+   -z*, -V, -b, -t, -Qy, -Qn, and -YP* options here, and the -e*, -l*,
+   -o*, -r, -s, -u*, and -L* options are directly supported by gcc.c
+   itself.  We don't directly support the -m (generate load map)
+   option because that conflicts with the -m (run m4) option of the
+   svr4 assembler.  We also don't directly support the svr4 linker's
+   -I* or -M* options because these conflict with existing GCC
+   options.  We do however allow passing arbitrary options to the svr4
+   linker via the -Wl, option, in gcc.c.  We don't support the svr4
+   linker's -a option at all because it is totally useless and because
+   it conflicts with GCC's own -a option.
+
+   Note that gcc doesn't allow a space to follow -Y in a -YP,* option.
+
+   When the -G link option is used (-shared and -symbolic) a final link is
+   not being done.  */
+
+#undef	LINK_SPEC
+#ifdef CROSS_COMPILE
+#define LINK_SPEC "%{h*} %{v:-V} \
+		   %{b} \
+		   %{static:-dn -Bstatic} \
+		   %{shared:-G -dy -z text} \
+		   %{symbolic:-Bsymbolic -G -dy -z text} \
+		   %{G:-G} \
+		   %{YP,*} \
+		   %{Qy:} %{!Qn:-Qy}"
+#else
+#define LINK_SPEC "%{h*} %{v:-V} \
+		   %{b} \
+		   %{static:-dn -Bstatic} \
+		   %{shared:-G -dy -z text} \
+		   %{symbolic:-Bsymbolic -G -dy -z text} \
+		   %{G:-G} \
+		   %{YP,*} \
+		   %{!YP,*:%{p:-Y P,/usr/ccs/lib/libp:/usr/lib/libp:/usr/ccs/lib:/usr/lib} \
+		    %{!p:-Y P,/usr/ccs/lib:/usr/lib}} \
+		   %{Qy:} %{!Qn:-Qy}"
+#endif
+
+/* Gcc automatically adds in one of the files /usr/ccs/lib/values-Xc.o
+   or /usr/ccs/lib/values-Xa.o for each final link step (depending
+   upon the other gcc options selected, such as -ansi).  These files
+   each contain one (initialized) copy of a special variable called
+   `_lib_version'.  Each one of these files has `_lib_version' initialized
+   to a different (enum) value.  The SVR4 library routines query the
+   value of `_lib_version' at run to decide how they should behave.
+   Specifically, they decide (based upon the value of `_lib_version')
+   if they will act in a strictly ANSI conforming manner or not.  */
+
+#undef	STARTFILE_SPEC
+#define STARTFILE_SPEC "%{!shared: \
+			 %{!symbolic: \
+			  %{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}}}}\
+			%{pg:gcrti.o%s}%{!pg:crti.o%s} \
+			%{ansi:values-Xc.o%s} \
+			%{!ansi:values-Xa.o%s} \
+ 			crtbegin.o%s"
+
+/* The numbers used to denote specific machine registers in the System V
+   Release 4 DWARF debugging information are quite likely to be totally
+   different from the numbers used in BSD stabs debugging information
+   for the same kind of target machine.  Thus, we undefine the macro
+   DBX_REGISTER_NUMBER here as an extra inducement to get people to
+   provide proper machine-specific definitions of DBX_REGISTER_NUMBER
+   (which is also used to provide DWARF registers numbers in dwarfout.c)
+   in their tm.h files which include this file.  */
+
+#undef DBX_REGISTER_NUMBER
+
+/* Define the actual types of some ANSI-mandated types.  (These
+   definitions should work for most SVR4 systems).  */
+
+#undef  SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef  PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef  WCHAR_TYPE
+#define WCHAR_TYPE "long int"
+
+#undef  WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+#define TARGET_HAS_F_SETLKW
diff -urN linux-2.6.9_orig/lib/gcc/coretypes.h linux-2.6.9/lib/gcc/coretypes.h
--- linux-2.6.9_orig/lib/gcc/coretypes.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/coretypes.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,65 @@
+/* GCC core type declarations.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+/* Provide forward declarations of core types which are referred to by
+   most of the compiler.  This allows header files to use these types
+   (e.g. in function prototypes) without concern for whether the full
+   definitions are visible.  Some other declarations that need to be
+   universally visible are here, too.
+
+   In the context of tconfig.h, most of these have special definitions
+   which prevent them from being used except in further type
+   declarations.  This is a kludge; the right thing is to avoid
+   including the "tm.h" header set in the context of tconfig.h, but
+   we're not there yet.  */
+
+#ifndef GCC_CORETYPES_H
+#define GCC_CORETYPES_H
+
+#define GTY(x)  /* nothing - marker for gengtype */
+
+#ifndef USED_FOR_TARGET
+
+struct rtx_def;
+typedef struct rtx_def *rtx;
+struct rtvec_def;
+typedef struct rtvec_def *rtvec;
+union tree_node;
+typedef union tree_node *tree;
+
+/* Provide forward struct declaration so that we don't have to include
+   all of cpplib.h whenever a random prototype includes a pointer.
+   Note that the cpp_reader typedef remains part of cpplib.h.  */
+
+struct cpp_reader;
+
+#else
+
+struct _dont_use_rtx_here_;
+struct _dont_use_rtvec_here_;
+union _dont_use_tree_here_;
+#define rtx struct _dont_use_rtx_here_ *
+#define rtvec struct _dont_use_rtvec_here *
+#define tree union _dont_use_tree_here_ *
+
+#endif
+
+#endif /* coretypes.h */
+
diff -urN linux-2.6.9_orig/lib/gcc/crtstuff.c linux-2.6.9/lib/gcc/crtstuff.c
--- linux-2.6.9_orig/lib/gcc/crtstuff.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/crtstuff.c	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,584 @@
+/* Specialized bits of code needed to support construction and
+   destruction of file-scope objects in C++ code.
+   Copyright (C) 1991, 1994, 1995, 1996, 1997, 1998,
+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+   Contributed by Ron Guilmette (rfg@monkeys.com).
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+/* This file is a bit like libgcc2.c in that it is compiled
+   multiple times and yields multiple .o files.
+
+   This file is useful on target machines where the object file format
+   supports multiple "user-defined" sections (e.g. COFF, ELF, ROSE).  On
+   such systems, this file allows us to avoid running collect (or any
+   other such slow and painful kludge).  Additionally, if the target
+   system supports a .init section, this file allows us to support the
+   linking of C++ code with a non-C++ main program.
+
+   Note that if INIT_SECTION_ASM_OP is defined in the tm.h file, then
+   this file *will* make use of the .init section.  If that symbol is
+   not defined however, then the .init section will not be used.
+
+   Currently, only ELF and COFF are supported.  It is likely however that
+   ROSE could also be supported, if someone was willing to do the work to
+   make whatever (small?) adaptations are needed.  (Some work may be
+   needed on the ROSE assembler and linker also.)
+
+   This file must be compiled with gcc.  */
+
+/* It is incorrect to include config.h here, because this file is being
+   compiled for the target, and hence definitions concerning only the host
+   do not apply.  */
+
+/* We include auto-host.h here to get HAVE_GAS_HIDDEN.  This is
+   supposedly valid even though this is a "target" file.  */
+#include "auto-host.h"
+#include "tconfig.h"
+#include "tsystem.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "unwind-dw2-fde.h"
+
+#ifndef FORCE_CODE_SECTION_ALIGN
+# define FORCE_CODE_SECTION_ALIGN
+#endif 
+
+#ifndef CRT_CALL_STATIC_FUNCTION
+# define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)	\
+static void __attribute__((__used__))			\
+call_ ## FUNC (void)					\
+{							\
+  asm (SECTION_OP);					\
+  FUNC ();						\
+  FORCE_CODE_SECTION_ALIGN				\
+  asm (TEXT_SECTION_ASM_OP);				\
+}
+#endif
+
+/* Need special handling for calling functions at startup and module 
+   loading and unloading. */
+#ifdef __KERNEL__
+# undef CRT_CALL_STATIC_FUNCTION
+# include <linux/init.h>
+#endif /* __KERNEL__ */
+
+#if defined(OBJECT_FORMAT_ELF) && defined(HAVE_LD_EH_FRAME_HDR) \
+    && !defined(inhibit_libc) && !defined(CRTSTUFFT_O) \
+    && defined(__GLIBC__) && __GLIBC__ >= 2
+#include <link.h>
+# if (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2) \
+     || (__GLIBC__ == 2 && __GLIBC_MINOR__ == 2 && defined(DT_CONFIG)))
+#  define USE_PT_GNU_EH_FRAME
+# endif
+#endif
+#if defined(EH_FRAME_SECTION_NAME) && !defined(USE_PT_GNU_EH_FRAME)
+# define USE_EH_FRAME_REGISTRY
+#endif
+#if defined(EH_FRAME_SECTION_NAME) && defined(HAVE_LD_RO_RW_SECTION_MIXING)
+# define EH_FRAME_SECTION_CONST const
+#else
+# define EH_FRAME_SECTION_CONST
+#endif
+
+/* We do not want to add the weak attribute to the declarations of these
+   routines in unwind-dw2-fde.h because that will cause the definition of
+   these symbols to be weak as well.
+
+   This exposes a core issue, how to handle creating weak references vs
+   how to create weak definitions.  Either we have to have the definition
+   of TARGET_WEAK_ATTRIBUTE be conditional in the shared header files or
+   have a second declaration if we want a function's references to be weak,
+   but not its definition.
+
+   Making TARGET_WEAK_ATTRIBUTE conditional seems like a good solution until
+   one thinks about scaling to larger problems -- ie, the condition under
+   which TARGET_WEAK_ATTRIBUTE is active will eventually get far too
+   complicated.
+
+   So, we take an approach similar to #pragma weak -- we have a second
+   declaration for functions that we want to have weak references.
+
+   Neither way is particularly good.  */
+   
+/* References to __register_frame_info and __deregister_frame_info should
+   be weak in this file if at all possible.  */
+extern void __register_frame_info (const void *, struct object *)
+				  TARGET_ATTRIBUTE_WEAK;   
+extern void __register_frame_info_bases (const void *, struct object *,
+					 void *, void *)
+				  TARGET_ATTRIBUTE_WEAK;
+extern void *__deregister_frame_info (const void *)
+				     TARGET_ATTRIBUTE_WEAK;
+extern void *__deregister_frame_info_bases (const void *)
+				     TARGET_ATTRIBUTE_WEAK;
+extern void __do_global_ctors_1 (void);
+
+/* Likewise for _Jv_RegisterClasses.  */
+extern void _Jv_RegisterClasses (void *) TARGET_ATTRIBUTE_WEAK;
+
+#ifdef OBJECT_FORMAT_ELF
+
+/*  Declare a pointer to void function type.  */
+typedef void (*func_ptr) (void);
+#define STATIC static
+
+#else  /* OBJECT_FORMAT_ELF */
+
+#include "gbl-ctors.h"
+
+#define STATIC
+
+#endif /* OBJECT_FORMAT_ELF */
+
+#ifdef CRT_BEGIN
+
+/* NOTE:  In order to be able to support SVR4 shared libraries, we arrange
+   to have one set of symbols { __CTOR_LIST__, __DTOR_LIST__, __CTOR_END__,
+   __DTOR_END__ } per root executable and also one set of these symbols
+   per shared library.  So in any given whole process image, we may have
+   multiple definitions of each of these symbols.  In order to prevent
+   these definitions from conflicting with one another, and in order to
+   ensure that the proper lists are used for the initialization/finalization
+   of each individual shared library (respectively), we give these symbols
+   only internal (i.e. `static') linkage, and we also make it a point to
+   refer to only the __CTOR_END__ symbol in crtend.o and the __DTOR_LIST__
+   symbol in crtbegin.o, where they are defined.  */
+
+/* The -1 is a flag to __do_global_[cd]tors indicating that this table
+   does not start with a count of elements.  */
+#ifdef CTOR_LIST_BEGIN
+CTOR_LIST_BEGIN;
+#elif defined(CTORS_SECTION_ASM_OP)
+/* Hack: force cc1 to switch to .data section early, so that assembling
+   __CTOR_LIST__ does not undo our behind-the-back change to .ctors.  */
+static func_ptr force_to_data[1] __attribute__ ((__unused__)) = { };
+asm (CTORS_SECTION_ASM_OP);
+STATIC func_ptr __CTOR_LIST__[1]
+  __attribute__ ((__unused__, aligned(sizeof(func_ptr))))
+  = { (func_ptr) (-1) };
+#else
+STATIC func_ptr __CTOR_LIST__[1]
+  __attribute__ ((__unused__, section(".ctors"), aligned(sizeof(func_ptr))))
+  = { (func_ptr) (-1) };
+#endif /* __CTOR_LIST__ alternatives */
+
+#ifdef DTOR_LIST_BEGIN
+DTOR_LIST_BEGIN;
+#elif defined(DTORS_SECTION_ASM_OP)
+asm (DTORS_SECTION_ASM_OP);
+STATIC func_ptr __DTOR_LIST__[1]
+  __attribute__ ((aligned(sizeof(func_ptr))))
+  = { (func_ptr) (-1) };
+#else
+STATIC func_ptr __DTOR_LIST__[1]
+  __attribute__((section(".dtors"), aligned(sizeof(func_ptr))))
+  = { (func_ptr) (-1) };
+#endif /* __DTOR_LIST__ alternatives */
+
+#ifdef USE_EH_FRAME_REGISTRY
+/* Stick a label at the beginning of the frame unwind info so we can register
+   and deregister it with the exception handling library code.  */
+STATIC EH_FRAME_SECTION_CONST char __EH_FRAME_BEGIN__[]
+     __attribute__((section(EH_FRAME_SECTION_NAME), aligned(4)))
+     = { };
+#endif /* USE_EH_FRAME_REGISTRY */
+
+#ifdef JCR_SECTION_NAME
+/* Stick a label at the beginning of the java class registration info
+   so we can register them properly.  */
+STATIC void *__JCR_LIST__[]
+  __attribute__ ((unused, section(JCR_SECTION_NAME), aligned(sizeof(void*))))
+  = { };
+#endif /* JCR_SECTION_NAME */
+
+#ifdef INIT_SECTION_ASM_OP
+
+#ifdef OBJECT_FORMAT_ELF
+
+/* Declare the __dso_handle variable.  It should have a unique value
+   in every shared-object; in a main program its value is zero.  The
+   object should in any case be protected.  This means the instance
+   in one DSO or the main program is not used in another object.  The
+   dynamic linker takes care of this.  */
+
+#ifdef HAVE_GAS_HIDDEN
+extern void *__dso_handle __attribute__ ((__visibility__ ("hidden")));
+#endif
+#ifdef CRTSTUFFS_O
+void *__dso_handle = &__dso_handle;
+#else
+void *__dso_handle = 0;
+#endif
+
+/* The __cxa_finalize function may not be available so we use only a
+   weak declaration.  */
+extern void __cxa_finalize (void *) TARGET_ATTRIBUTE_WEAK;
+
+/* Run all the global destructors on exit from the program.  */
+ 
+/* Some systems place the number of pointers in the first word of the
+   table.  On SVR4 however, that word is -1.  In all cases, the table is
+   null-terminated.  On SVR4, we start from the beginning of the list and
+   invoke each per-compilation-unit destructor routine in order
+   until we find that null.
+
+   Note that this function MUST be static.  There will be one of these
+   functions in each root executable and one in each shared library, but
+   although they all have the same code, each one is unique in that it
+   refers to one particular associated `__DTOR_LIST__' which belongs to the
+   same particular root executable or shared library file.
+
+   On some systems, this routine is run more than once from the .fini,
+   when exit is called recursively, so we arrange to remember where in
+   the list we left off processing, and we resume at that point,
+   should we be re-invoked.  */
+
+static void __attribute__((used))
+__do_global_dtors_aux (void)
+{
+  static func_ptr *p = __DTOR_LIST__ + 1;
+  static _Bool completed;
+  func_ptr f;
+
+  if (__builtin_expect (completed, 0))
+    return;
+
+#ifdef CRTSTUFFS_O
+  if (__cxa_finalize)
+    __cxa_finalize (__dso_handle);
+#endif
+
+  while ((f = *p))
+    {
+      p++;
+      f ();
+    }
+
+#ifdef USE_EH_FRAME_REGISTRY
+#ifdef CRT_GET_RFIB_DATA
+  /* If we used the new __register_frame_info_bases interface,
+     make sure that we deregister from the same place.  */
+  if (__deregister_frame_info_bases)
+    __deregister_frame_info_bases (__EH_FRAME_BEGIN__);
+#else
+  if (__deregister_frame_info)
+    __deregister_frame_info (__EH_FRAME_BEGIN__);
+#endif
+#endif
+
+  completed = 1;
+}
+
+#ifdef __KERNEL__
+# ifdef MODULE
+/* This is called from cleanup_module() */
+extern void begin_fini(void)
+{
+  __do_global_dtors_aux();
+}
+# endif /* MODULE */
+#else /* !__KERNEL__ */
+/* Stick a call to __do_global_dtors_aux into the .fini section.  */
+CRT_CALL_STATIC_FUNCTION (FINI_SECTION_ASM_OP, __do_global_dtors_aux)
+#endif /* !__KERNEL__ */
+
+#if defined(USE_EH_FRAME_REGISTRY) || defined(JCR_SECTION_NAME)
+/* Stick a call to __register_frame_info into the .init section.  For some
+   reason calls with no arguments work more reliably in .init, so stick the
+   call in another function.  */
+
+static void __attribute__((used))
+frame_dummy (void)
+{
+#ifdef USE_EH_FRAME_REGISTRY
+  static struct object object;
+#ifdef CRT_GET_RFIB_DATA 
+  void *tbase, *dbase;
+  tbase = 0;
+  CRT_GET_RFIB_DATA (dbase);
+  if (__register_frame_info_bases)
+    __register_frame_info_bases (__EH_FRAME_BEGIN__, &object, tbase, dbase);
+#else
+  if (__register_frame_info)
+    __register_frame_info (__EH_FRAME_BEGIN__, &object);
+#endif /* CRT_GET_RFIB_DATA */
+#endif /* USE_EH_FRAME_REGISTRY */
+#ifdef JCR_SECTION_NAME
+  if (__JCR_LIST__[0] && _Jv_RegisterClasses)
+    _Jv_RegisterClasses (__JCR_LIST__);
+#endif /* JCR_SECTION_NAME */
+}
+
+#ifdef __KERNEL__
+# ifdef MODULE
+extern void begin_init(void)
+{
+  frame_dummy();
+}
+# else /* !MODULE */
+static int __init call_frame_dummy(void)
+{
+  frame_dummy();
+  return 0;
+}
+core_initcall(call_frame_dummy);
+# endif /* !MODULE */
+#else /* !__KERNEL__ */
+CRT_CALL_STATIC_FUNCTION (INIT_SECTION_ASM_OP, frame_dummy)
+#endif /* !__KERNEL__ */
+#endif /* USE_EH_FRAME_REGISTRY || JCR_SECTION_NAME */
+
+#else  /* OBJECT_FORMAT_ELF */
+
+/* The function __do_global_ctors_aux is compiled twice (once in crtbegin.o
+   and once in crtend.o).  It must be declared static to avoid a link
+   error.  Here, we define __do_global_ctors as an externally callable
+   function.  It is externally callable so that __main can invoke it when
+   INVOKE__main is defined.  This has the additional effect of forcing cc1
+   to switch to the .text section.  */
+
+static void __do_global_ctors_aux (void);
+void
+__do_global_ctors (void)
+{
+#ifdef INVOKE__main
+  /* If __main won't actually call __do_global_ctors then it doesn't matter
+     what's inside the function.  The inside of __do_global_ctors_aux is
+     called automatically in that case.  And the Alliant fx2800 linker
+     crashes on this reference.  So prevent the crash.  */
+  __do_global_ctors_aux ();
+#endif
+}
+
+asm (INIT_SECTION_ASM_OP);	/* cc1 doesn't know that we are switching! */
+
+/* A routine to invoke all of the global constructors upon entry to the
+   program.  We put this into the .init section (for systems that have
+   such a thing) so that we can properly perform the construction of
+   file-scope static-storage C++ objects within shared libraries.  */
+
+static void __attribute__((used))
+__do_global_ctors_aux (void)	/* prologue goes in .init section */
+{
+  FORCE_CODE_SECTION_ALIGN	/* explicit align before switch to .text */
+  asm (TEXT_SECTION_ASM_OP);	/* don't put epilogue and body in .init */
+  DO_GLOBAL_CTORS_BODY;
+  atexit (__do_global_dtors);
+}
+
+#endif /* OBJECT_FORMAT_ELF */
+
+#elif defined(HAS_INIT_SECTION) /* ! INIT_SECTION_ASM_OP */
+
+extern void __do_global_dtors (void);
+
+/* This case is used by the Irix 6 port, which supports named sections but
+   not an SVR4-style .fini section.  __do_global_dtors can be non-static
+   in this case because we protect it with -hidden_symbol.  */
+
+void
+__do_global_dtors (void)
+{
+  func_ptr *p, f;
+  for (p = __DTOR_LIST__ + 1; (f = *p); p++)
+    f ();
+
+#ifdef USE_EH_FRAME_REGISTRY
+  if (__deregister_frame_info)
+    __deregister_frame_info (__EH_FRAME_BEGIN__);
+#endif
+}
+
+#if defined(USE_EH_FRAME_REGISTRY) || defined(JCR_SECTION_NAME)
+/* A helper function for __do_global_ctors, which is in crtend.o.  Here
+   in crtbegin.o, we can reference a couple of symbols not visible there.
+   Plus, since we're before libgcc.a, we have no problems referencing
+   functions from there.  */
+void
+__do_global_ctors_1(void)
+{
+#ifdef USE_EH_FRAME_REGISTRY
+  static struct object object;
+  if (__register_frame_info)
+    __register_frame_info (__EH_FRAME_BEGIN__, &object);
+#endif
+#ifdef JCR_SECTION_NAME
+  if (__JCR_LIST__[0] && _Jv_RegisterClasses)
+    _Jv_RegisterClasses (__JCR_LIST__);
+#endif
+}
+#endif /* USE_EH_FRAME_REGISTRY || JCR_SECTION_NAME */
+
+#else /* ! INIT_SECTION_ASM_OP && ! HAS_INIT_SECTION */
+#error "What are you doing with crtstuff.c, then?"
+#endif
+
+#elif defined(CRT_END) /* ! CRT_BEGIN */
+
+/* Put a word containing zero at the end of each of our two lists of function
+   addresses.  Note that the words defined here go into the .ctors and .dtors
+   sections of the crtend.o file, and since that file is always linked in
+   last, these words naturally end up at the very ends of the two lists
+   contained in these two sections.  */
+
+#ifdef CTOR_LIST_END
+CTOR_LIST_END;
+#elif defined(CTORS_SECTION_ASM_OP)
+/* Hack: force cc1 to switch to .data section early, so that assembling
+   __CTOR_LIST__ does not undo our behind-the-back change to .ctors.  */
+static func_ptr force_to_data[1] __attribute__ ((__unused__)) = { };
+asm (CTORS_SECTION_ASM_OP);
+STATIC func_ptr __CTOR_END__[1]
+  __attribute__((aligned(sizeof(func_ptr))))
+  = { (func_ptr) 0 };
+#else
+STATIC func_ptr __CTOR_END__[1]
+  __attribute__((section(".ctors"), aligned(sizeof(func_ptr))))
+  = { (func_ptr) 0 };
+#endif
+
+#ifdef DTOR_LIST_END
+DTOR_LIST_END;
+#elif defined(DTORS_SECTION_ASM_OP)
+asm (DTORS_SECTION_ASM_OP);
+STATIC func_ptr __DTOR_END__[1]
+  __attribute__ ((unused, aligned(sizeof(func_ptr))))
+  = { (func_ptr) 0 };
+#else
+STATIC func_ptr __DTOR_END__[1]
+  __attribute__((unused, section(".dtors"), aligned(sizeof(func_ptr))))
+  = { (func_ptr) 0 };
+#endif
+
+#ifdef EH_FRAME_SECTION_NAME
+/* Terminate the frame unwind info section with a 4byte 0 as a sentinel;
+   this would be the 'length' field in a real FDE.  */
+STATIC EH_FRAME_SECTION_CONST int __FRAME_END__[]
+     __attribute__ ((unused, mode(SI), section(EH_FRAME_SECTION_NAME),
+		     aligned(4)))
+     = { 0 };
+#endif /* EH_FRAME_SECTION_NAME */
+
+#ifdef JCR_SECTION_NAME
+/* Null terminate the .jcr section array.  */
+STATIC void *__JCR_END__[1] 
+   __attribute__ ((unused, section(JCR_SECTION_NAME),
+		   aligned(sizeof(void *))))
+   = { 0 };
+#endif /* JCR_SECTION_NAME */
+
+#ifdef INIT_SECTION_ASM_OP
+
+#ifdef OBJECT_FORMAT_ELF
+static void __attribute__((used))
+__do_global_ctors_aux (void)
+{
+  func_ptr *p;
+  for (p = __CTOR_END__ - 1; *p != (func_ptr) -1; p--)
+    (*p) ();
+}
+
+#ifdef __KERNEL__
+# ifdef MODULE
+extern void end_init(void)
+{
+  __do_global_ctors_aux();
+}
+# else /* !MODULE */
+static int __init call___do_global_ctors_aux(void)
+{
+  __do_global_ctors_aux();
+  return 0;
+}
+core_initcall(call___do_global_ctors_aux);
+# endif /* !MODULE */
+#else /* !__KERNEL__ */
+/* Stick a call to __do_global_ctors_aux into the .init section.  */
+CRT_CALL_STATIC_FUNCTION (INIT_SECTION_ASM_OP, __do_global_ctors_aux)
+#endif /* !__KERNEL__ */
+#else  /* OBJECT_FORMAT_ELF */
+
+/* Stick the real initialization code, followed by a normal sort of
+   function epilogue at the very end of the .init section for this
+   entire root executable file or for this entire shared library file.
+
+   Note that we use some tricks here to get *just* the body and just
+   a function epilogue (but no function prologue) into the .init
+   section of the crtend.o file.  Specifically, we switch to the .text
+   section, start to define a function, and then we switch to the .init
+   section just before the body code.
+
+   Earlier on, we put the corresponding function prologue into the .init
+   section of the crtbegin.o file (which will be linked in first).
+
+   Note that we want to invoke all constructors for C++ file-scope static-
+   storage objects AFTER any other possible initialization actions which
+   may be performed by the code in the .init section contributions made by
+   other libraries, etc.  That's because those other initializations may
+   include setup operations for very primitive things (e.g. initializing
+   the state of the floating-point coprocessor, etc.) which should be done
+   before we start to execute any of the user's code.  */
+
+static void
+__do_global_ctors_aux (void)	/* prologue goes in .text section */
+{
+  asm (INIT_SECTION_ASM_OP);
+  DO_GLOBAL_CTORS_BODY ;
+  atexit (__do_global_dtors);
+}				/* epilogue an d body go in .init section */
+
+FORCE_CODE_SECTION_ALIGN
+asm (TEXT_SECTION_ASM_OP) ; 
+
+#endif /* OBJECT_FORMAT_ELF */
+
+#elif defined(HAS_INIT_SECTION) /* ! INIT_SECTION_ASM_OP */
+
+extern void __do_global_ctors (void);
+
+/* This case is used by the Irix 6 port, which supports named sections but
+   not an SVR4-style .init section.  __do_global_ctors can be non-static
+   in this case because we protect it with -hidden_symbol.  */
+void
+__do_global_ctors (void)
+{
+  func_ptr *p;
+#if defined(USE_EH_FRAME_REGISTRY) || defined(JCR_SECTION_NAME)
+  __do_global_ctors_1();
+#endif
+  for (p = __CTOR_END__ - 1; *p != (func_ptr) -1; p--)
+    (*p) ();
+}
+
+#else /* ! INIT_SECTION_ASM_OP && ! HAS_INIT_SECTION */
+#error "What are you doing with crtstuff.c, then?"
+#endif
+
+#else /* ! CRT_BEGIN && ! CRT_END */
+#error "One of CRT_BEGIN or CRT_END must be defined."
+#endif
diff -urN linux-2.6.9_orig/lib/gcc/defaults.h linux-2.6.9/lib/gcc/defaults.h
--- linux-2.6.9_orig/lib/gcc/defaults.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/defaults.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,693 @@
+/* Definitions of various defaults for tm.h macros.
+   Copyright (C) 1992, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   Contributed by Ron Guilmette (rfg@monkeys.com)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+#ifndef GCC_DEFAULTS_H
+#define GCC_DEFAULTS_H
+
+#ifndef GET_ENVIRONMENT
+#define GET_ENVIRONMENT(VALUE, NAME) do { (VALUE) = getenv (NAME); } while (0)
+#endif
+
+#define obstack_chunk_alloc	((void *(*) (long)) xmalloc)
+#define obstack_chunk_free	((void (*) (void *)) free)
+#define OBSTACK_CHUNK_SIZE	0
+#define gcc_obstack_init(OBSTACK)			\
+  _obstack_begin ((OBSTACK), OBSTACK_CHUNK_SIZE, 0,	\
+		  obstack_chunk_alloc,			\
+		  obstack_chunk_free)
+
+/* Define default standard character escape sequences.  */
+#ifndef TARGET_BELL
+#  define TARGET_BELL 007
+#  define TARGET_BS 010
+#  define TARGET_TAB 011
+#  define TARGET_NEWLINE 012
+#  define TARGET_VT 013
+#  define TARGET_FF 014
+#  define TARGET_CR 015
+#  define TARGET_ESC 033
+#endif
+
+/* Store in OUTPUT a string (made with alloca) containing an
+   assembler-name for a local static variable or function named NAME.
+   LABELNO is an integer which is different for each call.  */
+
+#ifndef ASM_PN_FORMAT
+# ifndef NO_DOT_IN_LABEL
+#  define ASM_PN_FORMAT "%s.%lu"
+# else
+#  ifndef NO_DOLLAR_IN_LABEL
+#   define ASM_PN_FORMAT "%s$%lu"
+#  else
+#   define ASM_PN_FORMAT "__%s_%lu"
+#  endif
+# endif
+#endif /* ! ASM_PN_FORMAT */
+
+#ifndef ASM_FORMAT_PRIVATE_NAME
+# define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO) \
+  do { const char *const name_ = (NAME); \
+       char *const output_ = (OUTPUT) = alloca (strlen (name_) + 32);\
+       sprintf (output_, ASM_PN_FORMAT, name_, (unsigned long)(LABELNO)); \
+  } while (0)
+#endif
+
+#ifndef ASM_STABD_OP
+#define ASM_STABD_OP "\t.stabd\t"
+#endif
+
+/* This is how to output an element of a case-vector that is absolute.
+   Some targets don't use this, but we have to define it anyway.  */
+
+#ifndef ASM_OUTPUT_ADDR_VEC_ELT
+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \
+do { fputs (integer_asm_op (POINTER_SIZE / UNITS_PER_WORD, TRUE), FILE); \
+     (*targetm.asm_out.internal_label) (FILE, "L", (VALUE));			\
+     fputc ('\n', FILE);						\
+   } while (0)
+#endif
+
+/* Choose a reasonable default for ASM_OUTPUT_ASCII.  */
+
+#ifndef ASM_OUTPUT_ASCII
+#define ASM_OUTPUT_ASCII(MYFILE, MYSTRING, MYLENGTH) \
+  do {									      \
+    FILE *_hide_asm_out_file = (MYFILE);				      \
+    const unsigned char *_hide_p = (const unsigned char *) (MYSTRING);	      \
+    int _hide_thissize = (MYLENGTH);					      \
+    {									      \
+      FILE *asm_out_file = _hide_asm_out_file;				      \
+      const unsigned char *p = _hide_p;					      \
+      int thissize = _hide_thissize;					      \
+      int i;								      \
+      fprintf (asm_out_file, "\t.ascii \"");				      \
+									      \
+      for (i = 0; i < thissize; i++)					      \
+	{								      \
+	  int c = p[i];			   				      \
+	  if (c == '\"' || c == '\\')					      \
+	    putc ('\\', asm_out_file);					      \
+	  if (ISPRINT(c))						      \
+	    putc (c, asm_out_file);					      \
+	  else								      \
+	    {								      \
+	      fprintf (asm_out_file, "\\%o", c);			      \
+	      /* After an octal-escape, if a digit follows,		      \
+		 terminate one string constant and start another.	      \
+		 The VAX assembler fails to stop reading the escape	      \
+		 after three digits, so this is the only way we		      \
+		 can get it to parse the data properly.  */		      \
+	      if (i < thissize - 1 && ISDIGIT(p[i + 1]))		      \
+		fprintf (asm_out_file, "\"\n\t.ascii \"");		      \
+	  }								      \
+	}								      \
+      fprintf (asm_out_file, "\"\n");					      \
+    }									      \
+  }									      \
+  while (0)
+#endif
+
+/* This is how we tell the assembler to equate two values.  */
+#ifdef SET_ASM_OP
+#ifndef ASM_OUTPUT_DEF
+#define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)				\
+ do {	fprintf ((FILE), "%s", SET_ASM_OP);				\
+	assemble_name (FILE, LABEL1);					\
+	fprintf (FILE, ",");						\
+	assemble_name (FILE, LABEL2);					\
+	fprintf (FILE, "\n");						\
+  } while (0)
+#endif
+#endif
+
+/* This is how to output the definition of a user-level label named
+   NAME, such as the label on a static function or variable NAME.  */
+
+#ifndef ASM_OUTPUT_LABEL
+#define ASM_OUTPUT_LABEL(FILE,NAME) \
+  do { assemble_name ((FILE), (NAME)); fputs (":\n", (FILE)); } while (0)
+#endif
+
+/* This is how to output a reference to a user-level label named NAME.  */
+
+#ifndef ASM_OUTPUT_LABELREF
+#define ASM_OUTPUT_LABELREF(FILE,NAME)  asm_fprintf ((FILE), "%U%s", (NAME))
+#endif
+
+/* Allow target to print debug info labels specially.  This is useful for
+   VLIW targets, since debug info labels should go into the middle of
+   instruction bundles instead of breaking them.  */
+
+#ifndef ASM_OUTPUT_DEBUG_LABEL
+#define ASM_OUTPUT_DEBUG_LABEL(FILE, PREFIX, NUM) \
+  (*targetm.asm_out.internal_label) (FILE, PREFIX, NUM)
+#endif
+
+/* This is how we tell the assembler that a symbol is weak.  */
+#ifndef ASM_OUTPUT_WEAK_ALIAS
+#if defined (ASM_WEAKEN_LABEL) && defined (ASM_OUTPUT_DEF)
+#define ASM_OUTPUT_WEAK_ALIAS(STREAM, NAME, VALUE)	\
+  do							\
+    {							\
+      ASM_WEAKEN_LABEL (STREAM, NAME);			\
+      if (VALUE)					\
+        ASM_OUTPUT_DEF (STREAM, NAME, VALUE);		\
+    }							\
+  while (0)
+#endif
+#endif
+
+/* How to emit a .type directive.  */
+#ifndef ASM_OUTPUT_TYPE_DIRECTIVE
+#if defined TYPE_ASM_OP && defined TYPE_OPERAND_FMT
+#define ASM_OUTPUT_TYPE_DIRECTIVE(STREAM, NAME, TYPE)	\
+  do							\
+    {							\
+      fputs (TYPE_ASM_OP, STREAM);			\
+      assemble_name (STREAM, NAME);			\
+      fputs (", ", STREAM);				\
+      fprintf (STREAM, TYPE_OPERAND_FMT, TYPE);		\
+      putc ('\n', STREAM);				\
+    }							\
+  while (0)
+#endif
+#endif
+
+/* How to emit a .size directive.  */
+#ifndef ASM_OUTPUT_SIZE_DIRECTIVE
+#ifdef SIZE_ASM_OP
+#define ASM_OUTPUT_SIZE_DIRECTIVE(STREAM, NAME, SIZE)	\
+  do							\
+    {							\
+      HOST_WIDE_INT size_ = (SIZE);			\
+      fputs (SIZE_ASM_OP, STREAM);			\
+      assemble_name (STREAM, NAME);			\
+      fprintf (STREAM, ", " HOST_WIDE_INT_PRINT_DEC "\n", size_); \
+    }							\
+  while (0)
+
+#define ASM_OUTPUT_MEASURED_SIZE(STREAM, NAME)		\
+  do							\
+    {							\
+      fputs (SIZE_ASM_OP, STREAM);			\
+      assemble_name (STREAM, NAME);			\
+      fputs (", .-", STREAM);				\
+      assemble_name (STREAM, NAME);			\
+      putc ('\n', STREAM);				\
+    }							\
+  while (0)
+
+#endif
+#endif
+
+/* This determines whether or not we support weak symbols.  */
+#ifndef SUPPORTS_WEAK
+#if defined (ASM_WEAKEN_LABEL) || defined (ASM_WEAKEN_DECL)
+#define SUPPORTS_WEAK 1
+#else
+#define SUPPORTS_WEAK 0
+#endif
+#endif
+
+/* This determines whether or not we support link-once semantics.  */
+#ifndef SUPPORTS_ONE_ONLY
+#ifdef MAKE_DECL_ONE_ONLY
+#define SUPPORTS_ONE_ONLY 1
+#else
+#define SUPPORTS_ONE_ONLY 0
+#endif
+#endif
+
+/* By default, there is no prefix on user-defined symbols.  */
+#ifndef USER_LABEL_PREFIX
+#define USER_LABEL_PREFIX ""
+#endif
+
+/* If the target supports weak symbols, define TARGET_ATTRIBUTE_WEAK to
+   provide a weak attribute.  Else define it to nothing. 
+
+   This would normally belong in ansidecl.h, but SUPPORTS_WEAK is
+   not available at that time.
+
+   Note, this is only for use by target files which we know are to be
+   compiled by GCC.  */
+#ifndef TARGET_ATTRIBUTE_WEAK
+# if SUPPORTS_WEAK
+#  define TARGET_ATTRIBUTE_WEAK __attribute__ ((weak))
+# else
+#  define TARGET_ATTRIBUTE_WEAK
+# endif
+#endif
+
+/* If the target supports init_priority C++ attribute, give
+   SUPPORTS_INIT_PRIORITY a nonzero value.  */
+#ifndef SUPPORTS_INIT_PRIORITY
+#define SUPPORTS_INIT_PRIORITY 1
+#endif /* SUPPORTS_INIT_PRIORITY */
+
+/* If duplicate library search directories can be removed from a
+   linker command without changing the linker's semantics, give this
+   symbol a nonzero.  */
+#ifndef LINK_ELIMINATE_DUPLICATE_LDIRECTORIES
+#define LINK_ELIMINATE_DUPLICATE_LDIRECTORIES 0
+#endif /* LINK_ELIMINATE_DUPLICATE_LDIRECTORIES */
+
+/* If we have a definition of INCOMING_RETURN_ADDR_RTX, assume that
+   the rest of the DWARF 2 frame unwind support is also provided.  */
+#if !defined (DWARF2_UNWIND_INFO) && defined (INCOMING_RETURN_ADDR_RTX)
+#define DWARF2_UNWIND_INFO 1
+#endif
+
+/* If we have named sections, and we're using crtstuff to run ctors,
+   use them for registering eh frame information.  */
+#if defined (TARGET_ASM_NAMED_SECTION) && DWARF2_UNWIND_INFO \
+    && !defined(EH_FRAME_IN_DATA_SECTION)
+#ifndef EH_FRAME_SECTION_NAME
+#define EH_FRAME_SECTION_NAME ".eh_frame"
+#endif
+#endif
+
+/* If we have named section and we support weak symbols, then use the
+   .jcr section for recording java classes which need to be registered
+   at program start-up time.  */
+#if defined (TARGET_ASM_NAMED_SECTION) && SUPPORTS_WEAK
+#ifndef JCR_SECTION_NAME
+#define JCR_SECTION_NAME ".jcr"
+#endif
+#endif
+
+/* By default, we generate a label at the beginning and end of the
+   text section, and compute the size of the text section by
+   subtracting the two.  However, on some platforms that doesn't 
+   work, and we use the section itself, rather than a label at the
+   beginning of it, to indicate the start of the section.  On such
+   platforms, define this to zero.  */
+#ifndef DWARF2_GENERATE_TEXT_SECTION_LABEL
+#define DWARF2_GENERATE_TEXT_SECTION_LABEL 1
+#endif
+
+/* Supply a default definition for PROMOTE_PROTOTYPES.  */
+#ifndef PROMOTE_PROTOTYPES
+#define PROMOTE_PROTOTYPES	0
+#endif
+
+/* Number of hardware registers that go into the DWARF-2 unwind info.
+   If not defined, equals FIRST_PSEUDO_REGISTER  */
+
+#ifndef DWARF_FRAME_REGISTERS
+#define DWARF_FRAME_REGISTERS FIRST_PSEUDO_REGISTER
+#endif
+
+/* How to renumber registers for dbx and gdb.  If not defined, assume
+   no renumbering is necessary.  */
+
+#ifndef DBX_REGISTER_NUMBER
+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)
+#endif
+
+/* Default sizes for base C types.  If the sizes are different for
+   your target, you should override these values by defining the
+   appropriate symbols in your tm.h file.  */
+
+#ifndef BITS_PER_UNIT
+#define BITS_PER_UNIT 8
+#endif
+
+#ifndef BITS_PER_WORD
+#define BITS_PER_WORD (BITS_PER_UNIT * UNITS_PER_WORD)
+#endif
+
+#ifndef CHAR_TYPE_SIZE
+#define CHAR_TYPE_SIZE BITS_PER_UNIT
+#endif
+
+#ifndef BOOL_TYPE_SIZE
+/* `bool' has size and alignment `1', on almost all platforms.  */
+#define BOOL_TYPE_SIZE CHAR_TYPE_SIZE
+#endif
+
+#ifndef SHORT_TYPE_SIZE
+#define SHORT_TYPE_SIZE (BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))
+#endif
+
+#ifndef INT_TYPE_SIZE
+#define INT_TYPE_SIZE BITS_PER_WORD
+#endif
+
+#ifndef LONG_TYPE_SIZE
+#define LONG_TYPE_SIZE BITS_PER_WORD
+#endif
+
+#ifndef LONG_LONG_TYPE_SIZE
+#define LONG_LONG_TYPE_SIZE (BITS_PER_WORD * 2)
+#endif
+
+#ifndef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE INT_TYPE_SIZE
+#endif
+
+#ifndef FLOAT_TYPE_SIZE
+#define FLOAT_TYPE_SIZE BITS_PER_WORD
+#endif
+
+#ifndef DOUBLE_TYPE_SIZE
+#define DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)
+#endif
+
+#ifndef LONG_DOUBLE_TYPE_SIZE
+#define LONG_DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)
+#endif
+
+/* Width in bits of a pointer.  Mind the value of the macro `Pmode'.  */
+#ifndef POINTER_SIZE
+#define POINTER_SIZE BITS_PER_WORD
+#endif
+
+#ifndef PIC_OFFSET_TABLE_REGNUM
+#define PIC_OFFSET_TABLE_REGNUM INVALID_REGNUM
+#endif
+
+/* By default, the preprocessor should be invoked the same way in C++
+   as in C.  */
+#ifndef CPLUSPLUS_CPP_SPEC
+#ifdef CPP_SPEC
+#define CPLUSPLUS_CPP_SPEC CPP_SPEC
+#endif
+#endif
+
+#ifndef ACCUMULATE_OUTGOING_ARGS
+#define ACCUMULATE_OUTGOING_ARGS 0
+#endif
+
+/* Supply a default definition for PUSH_ARGS.  */
+#ifndef PUSH_ARGS
+#ifdef PUSH_ROUNDING
+#define PUSH_ARGS	!ACCUMULATE_OUTGOING_ARGS
+#else
+#define PUSH_ARGS	0
+#endif
+#endif
+
+/* Decide whether a function's arguments should be processed
+   from first to last or from last to first.
+
+   They should if the stack and args grow in opposite directions, but
+   only if we have push insns.  */
+
+#ifdef PUSH_ROUNDING
+
+#ifndef PUSH_ARGS_REVERSED
+#if defined (STACK_GROWS_DOWNWARD) != defined (ARGS_GROW_DOWNWARD)
+#define PUSH_ARGS_REVERSED  PUSH_ARGS
+#endif
+#endif
+
+#endif
+
+#ifndef PUSH_ARGS_REVERSED
+#define PUSH_ARGS_REVERSED 0
+#endif
+
+/* If PREFERRED_STACK_BOUNDARY is not defined, set it to STACK_BOUNDARY.
+   STACK_BOUNDARY is required.  */
+#ifndef PREFERRED_STACK_BOUNDARY
+#define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY
+#endif
+
+/* By default, the C++ compiler will use function addresses in the
+   vtable entries.  Setting this nonzero tells the compiler to use
+   function descriptors instead.  The value of this macro says how
+   many words wide the descriptor is (normally 2).  It is assumed 
+   that the address of a function descriptor may be treated as a
+   pointer to a function.  */
+#ifndef TARGET_VTABLE_USES_DESCRIPTORS
+#define TARGET_VTABLE_USES_DESCRIPTORS 0
+#endif
+
+/* By default, the vtable entries are void pointers, the so the alignment
+   is the same as pointer alignment.  The value of this macro specifies
+   the alignment of the vtable entry in bits.  It should be defined only
+   when special alignment is necessary.  */
+#ifndef TARGET_VTABLE_ENTRY_ALIGN
+#define TARGET_VTABLE_ENTRY_ALIGN POINTER_SIZE
+#endif
+
+/* There are a few non-descriptor entries in the vtable at offsets below
+   zero.  If these entries must be padded (say, to preserve the alignment
+   specified by TARGET_VTABLE_ENTRY_ALIGN), set this to the number of
+   words in each data entry.  */
+#ifndef TARGET_VTABLE_DATA_ENTRY_DISTANCE
+#define TARGET_VTABLE_DATA_ENTRY_DISTANCE 1
+#endif
+
+/* Select a format to encode pointers in exception handling data.  We
+   prefer those that result in fewer dynamic relocations.  Assume no
+   special support here and encode direct references.  */
+#ifndef ASM_PREFERRED_EH_DATA_FORMAT
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)  DW_EH_PE_absptr
+#endif
+
+/* By default, the C++ compiler will use the lowest bit of the pointer
+   to function to indicate a pointer-to-member-function points to a
+   virtual member function.  However, if FUNCTION_BOUNDARY indicates
+   function addresses aren't always even, the lowest bit of the delta
+   field will be used.  */
+#ifndef TARGET_PTRMEMFUNC_VBIT_LOCATION
+#define TARGET_PTRMEMFUNC_VBIT_LOCATION \
+  (FUNCTION_BOUNDARY >= 2 * BITS_PER_UNIT \
+   ? ptrmemfunc_vbit_in_pfn : ptrmemfunc_vbit_in_delta)
+#endif
+
+#ifndef DEFAULT_GDB_EXTENSIONS
+#define DEFAULT_GDB_EXTENSIONS 1
+#endif
+
+/* If more than one debugging type is supported, you must define
+   PREFERRED_DEBUGGING_TYPE to choose a format in a system-dependent way.
+
+   This is one long line cause VAXC can't handle a \-newline.  */
+#if 1 < (defined (DBX_DEBUGGING_INFO) + defined (SDB_DEBUGGING_INFO) + defined (DWARF2_DEBUGGING_INFO) + defined (XCOFF_DEBUGGING_INFO) + defined (VMS_DEBUGGING_INFO))
+#ifndef PREFERRED_DEBUGGING_TYPE
+You Lose!  You must define PREFERRED_DEBUGGING_TYPE!
+#endif /* no PREFERRED_DEBUGGING_TYPE */
+#else /* Only one debugging format supported.  Define PREFERRED_DEBUGGING_TYPE
+	 so other code needn't care.  */
+#ifdef DBX_DEBUGGING_INFO
+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG
+#endif
+#ifdef SDB_DEBUGGING_INFO
+#define PREFERRED_DEBUGGING_TYPE SDB_DEBUG
+#endif
+#ifdef DWARF_DEBUGGING_INFO
+#define PREFERRED_DEBUGGING_TYPE DWARF_DEBUG
+#endif
+#ifdef DWARF2_DEBUGGING_INFO
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+#endif
+#ifdef VMS_DEBUGGING_INFO
+#define PREFERRED_DEBUGGING_TYPE VMS_AND_DWARF2_DEBUG
+#endif
+#ifdef XCOFF_DEBUGGING_INFO
+#define PREFERRED_DEBUGGING_TYPE XCOFF_DEBUG
+#endif
+#endif /* More than one debugger format enabled.  */
+
+/* If still not defined, must have been because no debugging formats
+   are supported.  */
+#ifndef PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE NO_DEBUG
+#endif
+
+/* Define codes for all the float formats that we know of.  */
+#define UNKNOWN_FLOAT_FORMAT 0
+#define IEEE_FLOAT_FORMAT 1
+#define VAX_FLOAT_FORMAT 2
+#define IBM_FLOAT_FORMAT 3
+#define C4X_FLOAT_FORMAT 4
+
+/* Default to IEEE float if not specified.  Nearly all machines use it.  */
+#ifndef TARGET_FLOAT_FORMAT
+#define	TARGET_FLOAT_FORMAT	IEEE_FLOAT_FORMAT
+#endif
+
+/* Determine the register class for registers suitable to be the base
+   address register in a MEM.  Allow the choice to be dependent upon
+   the mode of the memory access.  */
+#ifndef MODE_BASE_REG_CLASS
+#define MODE_BASE_REG_CLASS(MODE) BASE_REG_CLASS
+#endif
+
+#ifndef LARGEST_EXPONENT_IS_NORMAL
+#define LARGEST_EXPONENT_IS_NORMAL(SIZE) 0
+#endif
+
+#ifndef ROUND_TOWARDS_ZERO
+#define ROUND_TOWARDS_ZERO 0
+#endif
+
+#ifndef MODE_HAS_NANS
+#define MODE_HAS_NANS(MODE)					\
+  (FLOAT_MODE_P (MODE)						\
+   && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT			\
+   && !LARGEST_EXPONENT_IS_NORMAL (GET_MODE_BITSIZE (MODE)))
+#endif
+
+#ifndef MODE_HAS_INFINITIES
+#define MODE_HAS_INFINITIES(MODE)				\
+  (FLOAT_MODE_P (MODE)						\
+   && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT			\
+   && !LARGEST_EXPONENT_IS_NORMAL (GET_MODE_BITSIZE (MODE)))
+#endif
+
+#ifndef MODE_HAS_SIGNED_ZEROS
+#define MODE_HAS_SIGNED_ZEROS(MODE) \
+  (FLOAT_MODE_P (MODE) && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)
+#endif
+
+#ifndef MODE_HAS_SIGN_DEPENDENT_ROUNDING
+#define MODE_HAS_SIGN_DEPENDENT_ROUNDING(MODE)			\
+  (FLOAT_MODE_P (MODE)						\
+   && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT			\
+   && !ROUND_TOWARDS_ZERO)
+#endif
+
+#ifndef FLOAT_LIB_COMPARE_RETURNS_BOOL
+#define FLOAT_LIB_COMPARE_RETURNS_BOOL(MODE, COMPARISON) false
+#endif
+
+/* If FLOAT_WORDS_BIG_ENDIAN is not defined in the header files,
+   then the word-endianness is the same as for integers.  */
+#ifndef FLOAT_WORDS_BIG_ENDIAN
+#define FLOAT_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN
+#endif
+
+#ifndef TARGET_FLT_EVAL_METHOD
+#define TARGET_FLT_EVAL_METHOD 0
+#endif
+
+#ifndef HOT_TEXT_SECTION_NAME
+#define HOT_TEXT_SECTION_NAME "text.hot"
+#endif
+
+#ifndef UNLIKELY_EXECUTED_TEXT_SECTION_NAME
+#define UNLIKELY_EXECUTED_TEXT_SECTION_NAME "text.unlikely"
+#endif
+
+#ifndef VECTOR_MODE_SUPPORTED_P
+#define VECTOR_MODE_SUPPORTED_P(MODE) 0
+#endif
+
+/* Determine whether __cxa_atexit, rather than atexit, is used to
+   register C++ destructors for local statics and global objects.  */
+#ifndef DEFAULT_USE_CXA_ATEXIT
+#define DEFAULT_USE_CXA_ATEXIT 0
+#endif
+
+/* Determine whether extra constraint letter should be handled
+   via address reload (like 'o').  */
+#ifndef EXTRA_MEMORY_CONSTRAINT
+#define EXTRA_MEMORY_CONSTRAINT(C,STR) 0
+#endif
+
+/* Determine whether extra constraint letter should be handled
+   as an address (like 'p').  */
+#ifndef EXTRA_ADDRESS_CONSTRAINT
+#define EXTRA_ADDRESS_CONSTRAINT(C,STR) 0
+#endif
+
+/* When a port defines CONSTRAINT_LEN, it should use DEFAULT_CONSTRAINT_LEN
+   for all the characters that it does not want to change, so things like the
+  'length' of a digit in a matching constraint is an implementation detail,
+   and not part of the interface.  */
+#define DEFAULT_CONSTRAINT_LEN(C,STR) 1
+
+#ifndef CONSTRAINT_LEN
+#define CONSTRAINT_LEN(C,STR) DEFAULT_CONSTRAINT_LEN (C, STR)
+#endif
+
+#if defined (CONST_OK_FOR_LETTER_P) && ! defined (CONST_OK_FOR_CONSTRAINT_P)
+#define CONST_OK_FOR_CONSTRAINT_P(VAL,C,STR) CONST_OK_FOR_LETTER_P (VAL, C)
+#endif
+
+#if defined (CONST_DOUBLE_OK_FOR_LETTER_P) && ! defined (CONST_DOUBLE_OK_FOR_CONSTRAINT_P)
+#define CONST_DOUBLE_OK_FOR_CONSTRAINT_P(OP,C,STR) \
+  CONST_DOUBLE_OK_FOR_LETTER_P (OP, C)
+#endif
+
+#ifndef REG_CLASS_FROM_CONSTRAINT
+#define REG_CLASS_FROM_CONSTRAINT(C,STR) REG_CLASS_FROM_LETTER (C)
+#endif
+
+#if defined (EXTRA_CONSTRAINT) && ! defined (EXTRA_CONSTRAINT_STR)
+#define EXTRA_CONSTRAINT_STR(OP, C,STR) EXTRA_CONSTRAINT (OP, C)
+#endif
+
+#ifndef REGISTER_MOVE_COST
+#define REGISTER_MOVE_COST(m, x, y) 2
+#endif
+
+/* Determine whether the the entire c99 runtime
+   is present in the runtime library.  */
+#ifndef TARGET_C99_FUNCTIONS
+#define TARGET_C99_FUNCTIONS 0
+#endif
+
+/* Indicate that CLZ and CTZ are undefined at zero.  */
+#ifndef CLZ_DEFINED_VALUE_AT_ZERO 
+#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  0
+#endif
+#ifndef CTZ_DEFINED_VALUE_AT_ZERO 
+#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  0
+#endif
+
+/* Provide a default value for STORE_FLAG_VALUE.  */
+#ifndef STORE_FLAG_VALUE
+#define STORE_FLAG_VALUE  1
+#endif
+
+/* This macro is used to determine what the largest unit size that
+   move_by_pieces can use is.  */
+
+/* MOVE_MAX_PIECES is the number of bytes at a time which we can
+   move efficiently, as opposed to  MOVE_MAX which is the maximum
+   number of bytes we can move with a single instruction.  */
+
+#ifndef MOVE_MAX_PIECES
+#define MOVE_MAX_PIECES   MOVE_MAX
+#endif
+
+#ifndef STACK_POINTER_OFFSET
+#define STACK_POINTER_OFFSET    0
+#endif
+
+#ifndef LOCAL_REGNO
+#define LOCAL_REGNO(REGNO)  0
+#endif
+
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
+   the stack pointer does not matter.  The value is tested only in
+   functions that have frame pointers.  */
+#ifndef EXIT_IGNORE_STACK
+#define EXIT_IGNORE_STACK 0
+#endif
+
+#endif  /* ! GCC_DEFAULTS_H */
diff -urN linux-2.6.9_orig/lib/gcc/dwarf2.h linux-2.6.9/lib/gcc/dwarf2.h
--- linux-2.6.9_orig/lib/gcc/dwarf2.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/dwarf2.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,635 @@
+/* Declarations and definitions of codes relating to the DWARF2 symbolic
+   debugging information format.
+   Copyright (C) 1992, 1993, 1995, 1996, 1997, 1999, 2000, 2001, 2002
+   Free Software Foundation, Inc.
+
+   Written by Gary Funck (gary@intrepid.com) The Ada Joint Program
+   Office (AJPO), Florida State University and Silicon Graphics Inc.
+   provided support for this effort -- June 21, 1995.
+
+   Derived from the DWARF 1 implementation written by Ron Guilmette
+   (rfg@netcom.com), November 1990.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+/* This file is derived from the DWARF specification (a public document)
+   Revision 2.0.0 (July 27, 1993) developed by the UNIX International
+   Programming Languages Special Interest Group (UI/PLSIG) and distributed
+   by UNIX International.  Copies of this specification are available from
+   UNIX International, 20 Waterview Boulevard, Parsippany, NJ, 07054.
+
+   This file also now contains definitions from the DWARF 3 specification.  */
+
+/* This file is shared between GCC and GDB, and should not contain
+   prototypes.  */
+
+#ifndef GCC_DWARF2_H
+#define GCC_DWARF2_H
+
+/* Tag names and codes.  */
+enum dwarf_tag
+  {
+    DW_TAG_padding = 0x00,
+    DW_TAG_array_type = 0x01,
+    DW_TAG_class_type = 0x02,
+    DW_TAG_entry_point = 0x03,
+    DW_TAG_enumeration_type = 0x04,
+    DW_TAG_formal_parameter = 0x05,
+    DW_TAG_imported_declaration = 0x08,
+    DW_TAG_label = 0x0a,
+    DW_TAG_lexical_block = 0x0b,
+    DW_TAG_member = 0x0d,
+    DW_TAG_pointer_type = 0x0f,
+    DW_TAG_reference_type = 0x10,
+    DW_TAG_compile_unit = 0x11,
+    DW_TAG_string_type = 0x12,
+    DW_TAG_structure_type = 0x13,
+    DW_TAG_subroutine_type = 0x15,
+    DW_TAG_typedef = 0x16,
+    DW_TAG_union_type = 0x17,
+    DW_TAG_unspecified_parameters = 0x18,
+    DW_TAG_variant = 0x19,
+    DW_TAG_common_block = 0x1a,
+    DW_TAG_common_inclusion = 0x1b,
+    DW_TAG_inheritance = 0x1c,
+    DW_TAG_inlined_subroutine = 0x1d,
+    DW_TAG_module = 0x1e,
+    DW_TAG_ptr_to_member_type = 0x1f,
+    DW_TAG_set_type = 0x20,
+    DW_TAG_subrange_type = 0x21,
+    DW_TAG_with_stmt = 0x22,
+    DW_TAG_access_declaration = 0x23,
+    DW_TAG_base_type = 0x24,
+    DW_TAG_catch_block = 0x25,
+    DW_TAG_const_type = 0x26,
+    DW_TAG_constant = 0x27,
+    DW_TAG_enumerator = 0x28,
+    DW_TAG_file_type = 0x29,
+    DW_TAG_friend = 0x2a,
+    DW_TAG_namelist = 0x2b,
+    DW_TAG_namelist_item = 0x2c,
+    DW_TAG_packed_type = 0x2d,
+    DW_TAG_subprogram = 0x2e,
+    DW_TAG_template_type_param = 0x2f,
+    DW_TAG_template_value_param = 0x30,
+    DW_TAG_thrown_type = 0x31,
+    DW_TAG_try_block = 0x32,
+    DW_TAG_variant_part = 0x33,
+    DW_TAG_variable = 0x34,
+    DW_TAG_volatile_type = 0x35,
+    /* DWARF 3.  */
+    DW_TAG_dwarf_procedure = 0x36,
+    DW_TAG_restrict_type = 0x37,
+    DW_TAG_interface_type = 0x38,
+    DW_TAG_namespace = 0x39,
+    DW_TAG_imported_module = 0x3a,
+    DW_TAG_unspecified_type = 0x3b,
+    DW_TAG_partial_unit = 0x3c,
+    DW_TAG_imported_unit = 0x3d,
+    /* SGI/MIPS Extensions.  */
+    DW_TAG_MIPS_loop = 0x4081,
+    /* GNU extensions.  */
+    DW_TAG_format_label = 0x4101,	/* For FORTRAN 77 and Fortran 90.  */
+    DW_TAG_function_template = 0x4102,	/* For C++.  */
+    DW_TAG_class_template = 0x4103,	/* For C++.  */
+    DW_TAG_GNU_BINCL = 0x4104,
+    DW_TAG_GNU_EINCL = 0x4105
+  };
+
+#define DW_TAG_lo_user	0x4080
+#define DW_TAG_hi_user	0xffff
+
+/* Flag that tells whether entry has a child or not.  */
+#define DW_children_no   0
+#define	DW_children_yes  1
+
+/* Form names and codes.  */
+enum dwarf_form
+  {
+    DW_FORM_addr = 0x01,
+    DW_FORM_block2 = 0x03,
+    DW_FORM_block4 = 0x04,
+    DW_FORM_data2 = 0x05,
+    DW_FORM_data4 = 0x06,
+    DW_FORM_data8 = 0x07,
+    DW_FORM_string = 0x08,
+    DW_FORM_block = 0x09,
+    DW_FORM_block1 = 0x0a,
+    DW_FORM_data1 = 0x0b,
+    DW_FORM_flag = 0x0c,
+    DW_FORM_sdata = 0x0d,
+    DW_FORM_strp = 0x0e,
+    DW_FORM_udata = 0x0f,
+    DW_FORM_ref_addr = 0x10,
+    DW_FORM_ref1 = 0x11,
+    DW_FORM_ref2 = 0x12,
+    DW_FORM_ref4 = 0x13,
+    DW_FORM_ref8 = 0x14,
+    DW_FORM_ref_udata = 0x15,
+    DW_FORM_indirect = 0x16
+  };
+
+/* Attribute names and codes.  */
+
+enum dwarf_attribute
+  {
+    DW_AT_sibling = 0x01,
+    DW_AT_location = 0x02,
+    DW_AT_name = 0x03,
+    DW_AT_ordering = 0x09,
+    DW_AT_subscr_data = 0x0a,
+    DW_AT_byte_size = 0x0b,
+    DW_AT_bit_offset = 0x0c,
+    DW_AT_bit_size = 0x0d,
+    DW_AT_element_list = 0x0f,
+    DW_AT_stmt_list = 0x10,
+    DW_AT_low_pc = 0x11,
+    DW_AT_high_pc = 0x12,
+    DW_AT_language = 0x13,
+    DW_AT_member = 0x14,
+    DW_AT_discr = 0x15,
+    DW_AT_discr_value = 0x16,
+    DW_AT_visibility = 0x17,
+    DW_AT_import = 0x18,
+    DW_AT_string_length = 0x19,
+    DW_AT_common_reference = 0x1a,
+    DW_AT_comp_dir = 0x1b,
+    DW_AT_const_value = 0x1c,
+    DW_AT_containing_type = 0x1d,
+    DW_AT_default_value = 0x1e,
+    DW_AT_inline = 0x20,
+    DW_AT_is_optional = 0x21,
+    DW_AT_lower_bound = 0x22,
+    DW_AT_producer = 0x25,
+    DW_AT_prototyped = 0x27,
+    DW_AT_return_addr = 0x2a,
+    DW_AT_start_scope = 0x2c,
+    DW_AT_stride_size = 0x2e,
+    DW_AT_upper_bound = 0x2f,
+    DW_AT_abstract_origin = 0x31,
+    DW_AT_accessibility = 0x32,
+    DW_AT_address_class = 0x33,
+    DW_AT_artificial = 0x34,
+    DW_AT_base_types = 0x35,
+    DW_AT_calling_convention = 0x36,
+    DW_AT_count = 0x37,
+    DW_AT_data_member_location = 0x38,
+    DW_AT_decl_column = 0x39,
+    DW_AT_decl_file = 0x3a,
+    DW_AT_decl_line = 0x3b,
+    DW_AT_declaration = 0x3c,
+    DW_AT_discr_list = 0x3d,
+    DW_AT_encoding = 0x3e,
+    DW_AT_external = 0x3f,
+    DW_AT_frame_base = 0x40,
+    DW_AT_friend = 0x41,
+    DW_AT_identifier_case = 0x42,
+    DW_AT_macro_info = 0x43,
+    DW_AT_namelist_items = 0x44,
+    DW_AT_priority = 0x45,
+    DW_AT_segment = 0x46,
+    DW_AT_specification = 0x47,
+    DW_AT_static_link = 0x48,
+    DW_AT_type = 0x49,
+    DW_AT_use_location = 0x4a,
+    DW_AT_variable_parameter = 0x4b,
+    DW_AT_virtuality = 0x4c,
+    DW_AT_vtable_elem_location = 0x4d,
+    /* DWARF 3 values.  */
+    DW_AT_allocated     = 0x4e,
+    DW_AT_associated    = 0x4f,
+    DW_AT_data_location = 0x50,
+    DW_AT_stride        = 0x51,
+    DW_AT_entry_pc      = 0x52,
+    DW_AT_use_UTF8      = 0x53,
+    DW_AT_extension     = 0x54,
+    DW_AT_ranges        = 0x55,
+    DW_AT_trampoline    = 0x56,
+    DW_AT_call_column   = 0x57,
+    DW_AT_call_file     = 0x58,
+    DW_AT_call_line     = 0x59,
+    /* SGI/MIPS Extensions.  */
+    DW_AT_MIPS_fde = 0x2001,
+    DW_AT_MIPS_loop_begin = 0x2002,
+    DW_AT_MIPS_tail_loop_begin = 0x2003,
+    DW_AT_MIPS_epilog_begin = 0x2004,
+    DW_AT_MIPS_loop_unroll_factor = 0x2005,
+    DW_AT_MIPS_software_pipeline_depth = 0x2006,
+    DW_AT_MIPS_linkage_name = 0x2007,
+    DW_AT_MIPS_stride = 0x2008,
+    DW_AT_MIPS_abstract_name = 0x2009,
+    DW_AT_MIPS_clone_origin = 0x200a,
+    DW_AT_MIPS_has_inlines = 0x200b,
+    /* GNU extensions.  */
+    DW_AT_sf_names   = 0x2101,
+    DW_AT_src_info   = 0x2102,
+    DW_AT_mac_info   = 0x2103,
+    DW_AT_src_coords = 0x2104,
+    DW_AT_body_begin = 0x2105,
+    DW_AT_body_end   = 0x2106,
+    DW_AT_GNU_vector = 0x2107,
+    /* VMS Extensions.  */
+    DW_AT_VMS_rtnbeg_pd_address = 0x2201
+  };
+
+#define DW_AT_lo_user	0x2000	/* Implementation-defined range start.  */
+#define DW_AT_hi_user	0x3ff0	/* Implementation-defined range end.  */
+
+/* Location atom names and codes.  */
+enum dwarf_location_atom
+  {
+    DW_OP_addr = 0x03,
+    DW_OP_deref = 0x06,
+    DW_OP_const1u = 0x08,
+    DW_OP_const1s = 0x09,
+    DW_OP_const2u = 0x0a,
+    DW_OP_const2s = 0x0b,
+    DW_OP_const4u = 0x0c,
+    DW_OP_const4s = 0x0d,
+    DW_OP_const8u = 0x0e,
+    DW_OP_const8s = 0x0f,
+    DW_OP_constu = 0x10,
+    DW_OP_consts = 0x11,
+    DW_OP_dup = 0x12,
+    DW_OP_drop = 0x13,
+    DW_OP_over = 0x14,
+    DW_OP_pick = 0x15,
+    DW_OP_swap = 0x16,
+    DW_OP_rot = 0x17,
+    DW_OP_xderef = 0x18,
+    DW_OP_abs = 0x19,
+    DW_OP_and = 0x1a,
+    DW_OP_div = 0x1b,
+    DW_OP_minus = 0x1c,
+    DW_OP_mod = 0x1d,
+    DW_OP_mul = 0x1e,
+    DW_OP_neg = 0x1f,
+    DW_OP_not = 0x20,
+    DW_OP_or = 0x21,
+    DW_OP_plus = 0x22,
+    DW_OP_plus_uconst = 0x23,
+    DW_OP_shl = 0x24,
+    DW_OP_shr = 0x25,
+    DW_OP_shra = 0x26,
+    DW_OP_xor = 0x27,
+    DW_OP_bra = 0x28,
+    DW_OP_eq = 0x29,
+    DW_OP_ge = 0x2a,
+    DW_OP_gt = 0x2b,
+    DW_OP_le = 0x2c,
+    DW_OP_lt = 0x2d,
+    DW_OP_ne = 0x2e,
+    DW_OP_skip = 0x2f,
+    DW_OP_lit0 = 0x30,
+    DW_OP_lit1 = 0x31,
+    DW_OP_lit2 = 0x32,
+    DW_OP_lit3 = 0x33,
+    DW_OP_lit4 = 0x34,
+    DW_OP_lit5 = 0x35,
+    DW_OP_lit6 = 0x36,
+    DW_OP_lit7 = 0x37,
+    DW_OP_lit8 = 0x38,
+    DW_OP_lit9 = 0x39,
+    DW_OP_lit10 = 0x3a,
+    DW_OP_lit11 = 0x3b,
+    DW_OP_lit12 = 0x3c,
+    DW_OP_lit13 = 0x3d,
+    DW_OP_lit14 = 0x3e,
+    DW_OP_lit15 = 0x3f,
+    DW_OP_lit16 = 0x40,
+    DW_OP_lit17 = 0x41,
+    DW_OP_lit18 = 0x42,
+    DW_OP_lit19 = 0x43,
+    DW_OP_lit20 = 0x44,
+    DW_OP_lit21 = 0x45,
+    DW_OP_lit22 = 0x46,
+    DW_OP_lit23 = 0x47,
+    DW_OP_lit24 = 0x48,
+    DW_OP_lit25 = 0x49,
+    DW_OP_lit26 = 0x4a,
+    DW_OP_lit27 = 0x4b,
+    DW_OP_lit28 = 0x4c,
+    DW_OP_lit29 = 0x4d,
+    DW_OP_lit30 = 0x4e,
+    DW_OP_lit31 = 0x4f,
+    DW_OP_reg0 = 0x50,
+    DW_OP_reg1 = 0x51,
+    DW_OP_reg2 = 0x52,
+    DW_OP_reg3 = 0x53,
+    DW_OP_reg4 = 0x54,
+    DW_OP_reg5 = 0x55,
+    DW_OP_reg6 = 0x56,
+    DW_OP_reg7 = 0x57,
+    DW_OP_reg8 = 0x58,
+    DW_OP_reg9 = 0x59,
+    DW_OP_reg10 = 0x5a,
+    DW_OP_reg11 = 0x5b,
+    DW_OP_reg12 = 0x5c,
+    DW_OP_reg13 = 0x5d,
+    DW_OP_reg14 = 0x5e,
+    DW_OP_reg15 = 0x5f,
+    DW_OP_reg16 = 0x60,
+    DW_OP_reg17 = 0x61,
+    DW_OP_reg18 = 0x62,
+    DW_OP_reg19 = 0x63,
+    DW_OP_reg20 = 0x64,
+    DW_OP_reg21 = 0x65,
+    DW_OP_reg22 = 0x66,
+    DW_OP_reg23 = 0x67,
+    DW_OP_reg24 = 0x68,
+    DW_OP_reg25 = 0x69,
+    DW_OP_reg26 = 0x6a,
+    DW_OP_reg27 = 0x6b,
+    DW_OP_reg28 = 0x6c,
+    DW_OP_reg29 = 0x6d,
+    DW_OP_reg30 = 0x6e,
+    DW_OP_reg31 = 0x6f,
+    DW_OP_breg0 = 0x70,
+    DW_OP_breg1 = 0x71,
+    DW_OP_breg2 = 0x72,
+    DW_OP_breg3 = 0x73,
+    DW_OP_breg4 = 0x74,
+    DW_OP_breg5 = 0x75,
+    DW_OP_breg6 = 0x76,
+    DW_OP_breg7 = 0x77,
+    DW_OP_breg8 = 0x78,
+    DW_OP_breg9 = 0x79,
+    DW_OP_breg10 = 0x7a,
+    DW_OP_breg11 = 0x7b,
+    DW_OP_breg12 = 0x7c,
+    DW_OP_breg13 = 0x7d,
+    DW_OP_breg14 = 0x7e,
+    DW_OP_breg15 = 0x7f,
+    DW_OP_breg16 = 0x80,
+    DW_OP_breg17 = 0x81,
+    DW_OP_breg18 = 0x82,
+    DW_OP_breg19 = 0x83,
+    DW_OP_breg20 = 0x84,
+    DW_OP_breg21 = 0x85,
+    DW_OP_breg22 = 0x86,
+    DW_OP_breg23 = 0x87,
+    DW_OP_breg24 = 0x88,
+    DW_OP_breg25 = 0x89,
+    DW_OP_breg26 = 0x8a,
+    DW_OP_breg27 = 0x8b,
+    DW_OP_breg28 = 0x8c,
+    DW_OP_breg29 = 0x8d,
+    DW_OP_breg30 = 0x8e,
+    DW_OP_breg31 = 0x8f,
+    DW_OP_regx = 0x90,
+    DW_OP_fbreg = 0x91,
+    DW_OP_bregx = 0x92,
+    DW_OP_piece = 0x93,
+    DW_OP_deref_size = 0x94,
+    DW_OP_xderef_size = 0x95,
+    DW_OP_nop = 0x96,
+    /* DWARF 3 extensions.  */
+    DW_OP_push_object_address = 0x97,
+    DW_OP_call2 = 0x98,
+    DW_OP_call4 = 0x99,
+    DW_OP_call_ref = 0x9a,
+    /* GNU extensions.  */
+    DW_OP_GNU_push_tls_address = 0xe0
+  };
+
+#define DW_OP_lo_user	0xe0	/* Implementation-defined range start.  */
+#define DW_OP_hi_user	0xff	/* Implementation-defined range end.  */
+
+/* Type encodings.  */
+enum dwarf_type
+  {
+    DW_ATE_void = 0x0,
+    DW_ATE_address = 0x1,
+    DW_ATE_boolean = 0x2,
+    DW_ATE_complex_float = 0x3,
+    DW_ATE_float = 0x4,
+    DW_ATE_signed = 0x5,
+    DW_ATE_signed_char = 0x6,
+    DW_ATE_unsigned = 0x7,
+    DW_ATE_unsigned_char = 0x8,
+    /* DWARF 3.  */
+    DW_ATE_imaginary_float = 0x9
+  };
+
+#define	DW_ATE_lo_user 0x80
+#define	DW_ATE_hi_user 0xff
+
+/* Array ordering names and codes.  */
+enum dwarf_array_dim_ordering
+  {
+    DW_ORD_row_major = 0,
+    DW_ORD_col_major = 1
+  };
+
+/* Access attribute.  */
+enum dwarf_access_attribute
+  {
+    DW_ACCESS_public = 1,
+    DW_ACCESS_protected = 2,
+    DW_ACCESS_private = 3
+  };
+
+/* Visibility.  */
+enum dwarf_visibility_attribute
+  {
+    DW_VIS_local = 1,
+    DW_VIS_exported = 2,
+    DW_VIS_qualified = 3
+  };
+
+/* Virtuality.  */
+enum dwarf_virtuality_attribute
+  {
+    DW_VIRTUALITY_none = 0,
+    DW_VIRTUALITY_virtual = 1,
+    DW_VIRTUALITY_pure_virtual = 2
+  };
+
+/* Case sensitivity.  */
+enum dwarf_id_case
+  {
+    DW_ID_case_sensitive = 0,
+    DW_ID_up_case = 1,
+    DW_ID_down_case = 2,
+    DW_ID_case_insensitive = 3
+  };
+
+/* Calling convention.  */
+enum dwarf_calling_convention
+  {
+    DW_CC_normal = 0x1,
+    DW_CC_program = 0x2,
+    DW_CC_nocall = 0x3
+  };
+
+#define DW_CC_lo_user 0x40
+#define DW_CC_hi_user 0xff
+
+/* Inline attribute.  */
+enum dwarf_inline_attribute
+  {
+    DW_INL_not_inlined = 0,
+    DW_INL_inlined = 1,
+    DW_INL_declared_not_inlined = 2,
+    DW_INL_declared_inlined = 3
+  };
+
+/* Discriminant lists.  */
+enum dwarf_discrim_list
+  {
+    DW_DSC_label = 0,
+    DW_DSC_range = 1
+  };
+
+/* Line number opcodes.  */
+enum dwarf_line_number_ops
+  {
+    DW_LNS_extended_op = 0,
+    DW_LNS_copy = 1,
+    DW_LNS_advance_pc = 2,
+    DW_LNS_advance_line = 3,
+    DW_LNS_set_file = 4,
+    DW_LNS_set_column = 5,
+    DW_LNS_negate_stmt = 6,
+    DW_LNS_set_basic_block = 7,
+    DW_LNS_const_add_pc = 8,
+    DW_LNS_fixed_advance_pc = 9,
+    /* DWARF 3.  */
+    DW_LNS_set_prologue_end = 10,
+    DW_LNS_set_epilogue_begin = 11,
+    DW_LNS_set_isa = 12
+  };
+
+/* Line number extended opcodes.  */
+enum dwarf_line_number_x_ops
+  {
+    DW_LNE_end_sequence = 1,
+    DW_LNE_set_address = 2,
+    DW_LNE_define_file = 3
+  };
+
+/* Call frame information.  */
+enum dwarf_call_frame_info
+  {
+    DW_CFA_advance_loc = 0x40,
+    DW_CFA_offset = 0x80,
+    DW_CFA_restore = 0xc0,
+    DW_CFA_nop = 0x00,
+    DW_CFA_set_loc = 0x01,
+    DW_CFA_advance_loc1 = 0x02,
+    DW_CFA_advance_loc2 = 0x03,
+    DW_CFA_advance_loc4 = 0x04,
+    DW_CFA_offset_extended = 0x05,
+    DW_CFA_restore_extended = 0x06,
+    DW_CFA_undefined = 0x07,
+    DW_CFA_same_value = 0x08,
+    DW_CFA_register = 0x09,
+    DW_CFA_remember_state = 0x0a,
+    DW_CFA_restore_state = 0x0b,
+    DW_CFA_def_cfa = 0x0c,
+    DW_CFA_def_cfa_register = 0x0d,
+    DW_CFA_def_cfa_offset = 0x0e,
+
+    /* DWARF 3.  */
+    DW_CFA_def_cfa_expression = 0x0f,
+    DW_CFA_expression = 0x10,
+    DW_CFA_offset_extended_sf = 0x11,
+    DW_CFA_def_cfa_sf = 0x12,
+    DW_CFA_def_cfa_offset_sf = 0x13,
+
+    /* SGI/MIPS specific.  */
+    DW_CFA_MIPS_advance_loc8 = 0x1d,
+
+    /* GNU extensions.  */
+    DW_CFA_GNU_window_save = 0x2d,
+    DW_CFA_GNU_args_size = 0x2e,
+    DW_CFA_GNU_negative_offset_extended = 0x2f
+  };
+
+#define DW_CIE_ID	  0xffffffff
+#define DW_CIE_VERSION	  1
+
+#define DW_CFA_extended   0
+#define DW_CFA_low_user   0x1c
+#define DW_CFA_high_user  0x3f
+
+#define DW_CHILDREN_no		     0x00
+#define DW_CHILDREN_yes		     0x01
+
+#define DW_ADDR_none		0
+
+/* Source language names and codes.  */
+enum dwarf_source_language
+  {
+    DW_LANG_C89 = 0x0001,
+    DW_LANG_C = 0x0002,
+    DW_LANG_Ada83 = 0x0003,
+    DW_LANG_C_plus_plus = 0x0004,
+    DW_LANG_Cobol74 = 0x0005,
+    DW_LANG_Cobol85 = 0x0006,
+    DW_LANG_Fortran77 = 0x0007,
+    DW_LANG_Fortran90 = 0x0008,
+    DW_LANG_Pascal83 = 0x0009,
+    DW_LANG_Modula2 = 0x000a,
+    DW_LANG_Java = 0x000b,
+    /* DWARF 3.  */
+    DW_LANG_C99 = 0x000c,
+    DW_LANG_Ada95 = 0x000d,
+    DW_LANG_Fortran95 = 0x000e,
+    /* MIPS.  */
+    DW_LANG_Mips_Assembler = 0x8001
+  };
+
+
+#define DW_LANG_lo_user 0x8000	/* Implementation-defined range start.  */
+#define DW_LANG_hi_user 0xffff	/* Implementation-defined range start.  */
+
+/* Names and codes for macro information.  */
+enum dwarf_macinfo_record_type
+  {
+    DW_MACINFO_define = 1,
+    DW_MACINFO_undef = 2,
+    DW_MACINFO_start_file = 3,
+    DW_MACINFO_end_file = 4,
+    DW_MACINFO_vendor_ext = 255
+  };
+
+/* @@@ For use with GNU frame unwind information.  */
+
+#define DW_EH_PE_absptr		0x00
+#define DW_EH_PE_omit		0xff
+
+#define DW_EH_PE_uleb128	0x01
+#define DW_EH_PE_udata2		0x02
+#define DW_EH_PE_udata4		0x03
+#define DW_EH_PE_udata8		0x04
+#define DW_EH_PE_sleb128	0x09
+#define DW_EH_PE_sdata2		0x0A
+#define DW_EH_PE_sdata4		0x0B
+#define DW_EH_PE_sdata8		0x0C
+#define DW_EH_PE_signed		0x08
+
+#define DW_EH_PE_pcrel		0x10
+#define DW_EH_PE_textrel	0x20
+#define DW_EH_PE_datarel	0x30
+#define DW_EH_PE_funcrel	0x40
+#define DW_EH_PE_aligned	0x50
+
+#define DW_EH_PE_indirect	0x80
+
+#endif /* dwarf2.h */
diff -urN linux-2.6.9_orig/lib/gcc/fixdefines.h linux-2.6.9/lib/gcc/fixdefines.h
--- linux-2.6.9_orig/lib/gcc/fixdefines.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/fixdefines.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,66 @@
+/*  fixdefines.h
+ *
+ *  Copyright (C) - Reykjavik University 2004
+ *  Authors:            Petur Runolfsson
+ *  E-mail:     pronto@ru.is
+ */
+#ifndef LINUX_FIXDEFINES_H_INCLUDED
+#define LINUX_FIXDEFINES_H_INCLUDED
+
+#include <c++/begin_include.h>
+#include <linux/slab.h>
+#include <c++/end_include.h>
+
+/* Replacement macros for malloc, free and abort so the GCC runtime libraries
+ * can be compiled for use in the kernel with minimal modifications. */
+#ifdef __cplusplus
+extern "C"
+#else
+static
+#endif
+inline void* cxx_malloc(size_t sz)
+{
+   return kmalloc(sz, GFP_KERNEL);
+}
+
+#ifdef __cplusplus
+extern "C"
+#else
+static
+#endif
+inline void cxx_free(void* p)
+{
+   kfree(p);
+}
+
+#define free cxx_free
+#define malloc cxx_malloc
+
+#ifdef __cplusplus
+extern "C"
+inline void __attribute__((__noreturn__)) cxx_abort(void)
+{
+   printk("Aborted\n");
+   BUG();
+   for (;;);
+}
+#define abort cxx_abort
+#else
+static inline void __attribute__((__noreturn__))
+c_abort(const char* file, int line, const char* function)
+{
+   printk("Aborted from %s:%d:%s\n", file, line, function);
+   BUG();
+   for (;;);
+}
+
+#define abort() c_abort(__FILE__, __LINE__, __FUNCTION__)
+#endif
+
+/* The libraries used are from gcc-3.4.0. This is needed so they can be
+ * compiled with gcc-3.3.2. */
+#if __GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)
+#define __builtin_extend_pointer(x) ((_Unwind_Ptr) (x))
+#endif
+
+#endif
diff -urN linux-2.6.9_orig/lib/gcc/libgcc_syms.c linux-2.6.9/lib/gcc/libgcc_syms.c
--- linux-2.6.9_orig/lib/gcc/libgcc_syms.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/libgcc_syms.c	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,22 @@
+#include <linux/module.h>
+
+#define EXPORT(sym) \
+extern void sym (void); \
+EXPORT_SYMBOL(sym)
+
+EXPORT(_Unwind_GetDataRelBase);
+EXPORT(_Unwind_SetGR);
+EXPORT(_Unwind_GetLanguageSpecificData);
+EXPORT(_Unwind_GetTextRelBase);
+EXPORT(_Unwind_SetIP);
+EXPORT(_Unwind_RaiseException);
+EXPORT(_Unwind_DeleteException);
+EXPORT(_Unwind_Resume);
+EXPORT(_Unwind_GetRegionStart);
+EXPORT(_Unwind_Resume_or_Rethrow);
+EXPORT(_Unwind_GetIP);
+EXPORT(__register_frame_info);
+EXPORT(__register_frame_info_bases);
+EXPORT(__deregister_frame_info);
+EXPORT(__deregister_frame_info_bases);
+EXPORT(__dso_handle);
diff -urN linux-2.6.9_orig/lib/gcc/Makefile linux-2.6.9/lib/gcc/Makefile
--- linux-2.6.9_orig/lib/gcc/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/Makefile	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,20 @@
+#
+# Makefile for C++ runtime library (libgcc)
+#
+
+LIBGCC_CFLAGS := -Dinhibit_libc  -DIN_GCC \
+	-static  -I$(src)/../../include/c++/bits \
+	-I$(src)/../../include/asm/gcc -I$(src)/../../include/gcc \
+	-include $(src)/fixdefines.h -I$(src)
+
+ifeq ($(build_crt),1)
+include $(src)/Makefile.crt
+else
+
+EXTRA_CFLAGS	+= -fexceptions $(LIBGCC_CFLAGS)
+
+obj-$(CONFIG_CXX_RUNTIME)	+= libgcc.o
+
+libgcc-objs	+= unwind-dw2.o unwind-dw2-fde.o libgcc_syms.o
+
+endif # not build_crt
diff -urN linux-2.6.9_orig/lib/gcc/Makefile.crt linux-2.6.9/lib/gcc/Makefile.crt
--- linux-2.6.9_orig/lib/gcc/Makefile.crt	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/Makefile.crt	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,23 @@
+# -*- Makefile -*- for crtstuff.c
+#
+
+EXTRA_CFLAGS	+= $(LIBGCC_CFLAGS) -finhibit-size-directive \
+	-fno-inline-functions -fno-exceptions
+EXTRA_CFLAGS	+= $(call check_gcc,-fno-zero-initialized-in-bss,)
+
+CFLAGS_crtbegin.o := -DCRT_BEGIN
+CFLAGS_crtend.o := -DCRT_END
+CFLAGS_crtbeginM.o := -DCRT_BEGIN -DMODULE -DCRTSTUFFS_O
+CFLAGS_crtendM.o := -DCRT_END -DMODULE -DCRTSTUFFS_O
+
+$(obj)/crtbegin.o:	$(src)/crtstuff.c
+	$(call if_changed_rule,cc_o_c)
+
+$(obj)/crtend.o:	$(src)/crtstuff.c
+	$(call if_changed_rule,cc_o_c)
+
+$(obj)/crtbeginM.o:	$(src)/crtstuff.c
+	$(call if_changed_rule,cc_o_c)
+
+$(obj)/crtendM.o:	$(src)/crtstuff.c
+	$(call if_changed_rule,cc_o_c)
diff -urN linux-2.6.9_orig/lib/gcc/tsystem.h linux-2.6.9/lib/gcc/tsystem.h
--- linux-2.6.9_orig/lib/gcc/tsystem.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/tsystem.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,109 @@
+/* Get common system includes and various definitions and declarations
+   based on target macros.
+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+/* As a special exception, if you link this library with other files,
+   some of which are compiled with GCC, to produce an executable,
+   this library does not by itself cause the resulting executable
+   to be covered by the GNU General Public License.
+   This exception does not however invalidate any other reasons why
+   the executable file might be covered by the GNU General Public License.  */
+
+#ifndef GCC_TSYSTEM_H
+#define GCC_TSYSTEM_H
+
+/* System headers (e.g. stdio.h, stdlib.h, unistd.h) sometimes
+   indirectly include getopt.h.  Our -I flags will cause gcc's gnu
+   getopt.h to be included, not the platform's copy.  In the default
+   case, gnu getopt.h will provide us with a no-argument prototype
+   which will generate -Wstrict-prototypes warnings.  None of the
+   target files actually use getopt, so it is safe to tell gnu
+   getopt.h we never need this prototype.  */
+#ifndef HAVE_DECL_GETOPT
+#define HAVE_DECL_GETOPT 1
+#endif
+
+/* GCC supplies these headers.  */
+#include <stddef.h>
+#include <float.h>
+
+#ifdef inhibit_libc
+
+#ifndef malloc
+extern void *malloc (size_t);
+#endif
+
+#ifndef free
+extern void free (void *);
+#endif
+
+#ifndef atexit
+extern int atexit (void (*)(void));
+#endif
+
+#ifndef abort
+extern void abort (void) __attribute__ ((__noreturn__));
+#endif
+
+#ifndef strlen
+extern size_t strlen (const char *);
+#endif
+
+#else /* ! inhibit_libc */
+/* We disable this when inhibit_libc, so that gcc can still be built without
+   needing header files first.  */
+/* ??? This is not a good solution, since prototypes may be required in
+   some cases for correct code.  */
+
+/* GCC supplies this header.  */
+#include <stdarg.h>
+
+/* All systems have this header.  */
+#include <stdio.h>
+
+/* All systems have this header.  */
+#include <sys/types.h>
+
+/* All systems have this header.  */
+#include <errno.h>
+
+#ifndef errno
+extern int errno;
+#endif
+
+/* GCC (fixproto) guarantees these system headers exist.  */
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+/* GCC supplies this header.  */
+#include <limits.h>
+
+/* GCC (fixproto) guarantees this system headers exists.  */
+#include <time.h>
+
+#endif /* inhibit_libc */
+
+/* Define a generic NULL if one hasn't already been defined.  */
+#ifndef NULL
+#define NULL 0
+#endif
+
+#endif /* ! GCC_TSYSTEM_H */
diff -urN linux-2.6.9_orig/lib/gcc/unwind-dw2.c linux-2.6.9/lib/gcc/unwind-dw2.c
--- linux-2.6.9_orig/lib/gcc/unwind-dw2.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/unwind-dw2.c	2004-10-29 17:00:57.000000000 +0000
@@ -0,0 +1,1726 @@
+/* DWARF2 exception handling and frame unwind runtime interface routines.
+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003
+   Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   In addition to the permissions in the GNU General Public License, the
+   Free Software Foundation gives you unlimited permission to link the
+   compiled version of this file into combinations with other programs,
+   and to distribute those combinations without any restriction coming
+   from the use of this file.  (The General Public License restrictions
+   do apply in other respects; for example, they cover modification of
+   the file, and distribution when not linked into a combined
+   executable.)
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include "tconfig.h"
+#include "tsystem.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "dwarf2.h"
+#include "unwind.h"
+#ifdef __USING_SJLJ_EXCEPTIONS__
+# define NO_SIZE_OF_ENCODED_VALUE
+#endif
+#include "unwind-pe.h"
+#include "unwind-dw2-fde.h"
+#include "gthr.h"
+
+
+#ifndef __USING_SJLJ_EXCEPTIONS__
+
+#ifndef STACK_GROWS_DOWNWARD
+#define STACK_GROWS_DOWNWARD 0
+#else
+#undef STACK_GROWS_DOWNWARD
+#define STACK_GROWS_DOWNWARD 1
+#endif
+
+/* A target can override (perhaps for backward compatibility) how
+   many dwarf2 columns are unwound.  */
+#ifndef DWARF_FRAME_REGISTERS
+#define DWARF_FRAME_REGISTERS FIRST_PSEUDO_REGISTER
+#endif
+
+/* Dwarf frame registers used for pre gcc 3.0 compiled glibc.  */
+#ifndef PRE_GCC3_DWARF_FRAME_REGISTERS
+#define PRE_GCC3_DWARF_FRAME_REGISTERS DWARF_FRAME_REGISTERS
+#endif
+
+#ifndef DWARF_REG_TO_UNWIND_COLUMN
+#define DWARF_REG_TO_UNWIND_COLUMN(REGNO) (REGNO)
+#endif
+
+/* A target can do some update context frobbing.  */
+#ifndef MD_FROB_UPDATE_CONTEXT
+#define MD_FROB_UPDATE_CONTEXT(CTX, FS) do { } while (0)
+#endif
+
+/* This is the register and unwind state for a particular frame.  This
+   provides the information necessary to unwind up past a frame and return
+   to its caller.  */
+struct _Unwind_Context
+{
+  void *reg[DWARF_FRAME_REGISTERS+1];
+  void *cfa;
+  void *ra;
+  void *lsda;
+  struct dwarf_eh_bases bases;
+  _Unwind_Word args_size;
+};
+
+/* Byte size of every register managed by these routines.  */
+static unsigned char dwarf_reg_size_table[DWARF_FRAME_REGISTERS+1];
+
+
+/* The result of interpreting the frame unwind info for a frame.
+   This is all symbolic at this point, as none of the values can
+   be resolved until the target pc is located.  */
+typedef struct
+{
+  /* Each register save state can be described in terms of a CFA slot,
+     another register, or a location expression.  */
+  struct frame_state_reg_info
+  {
+    struct {
+      union {
+	_Unwind_Word reg;
+	_Unwind_Sword offset;
+	const unsigned char *exp;
+      } loc;
+      enum {
+	REG_UNSAVED,
+	REG_SAVED_OFFSET,
+	REG_SAVED_REG,
+	REG_SAVED_EXP
+      } how;
+    } reg[DWARF_FRAME_REGISTERS+1];
+
+    /* Used to implement DW_CFA_remember_state.  */
+    struct frame_state_reg_info *prev;
+  } regs;
+
+  /* The CFA can be described in terms of a reg+offset or a
+     location expression.  */
+  _Unwind_Sword cfa_offset;
+  _Unwind_Word cfa_reg;
+  const unsigned char *cfa_exp;
+  enum {
+    CFA_UNSET,
+    CFA_REG_OFFSET,
+    CFA_EXP
+  } cfa_how;
+
+  /* The PC described by the current frame state.  */
+  void *pc;
+
+  /* The information we care about from the CIE/FDE.  */
+  _Unwind_Personality_Fn personality;
+  _Unwind_Sword data_align;
+  _Unwind_Word code_align;
+  unsigned char retaddr_column;
+  unsigned char fde_encoding;
+  unsigned char lsda_encoding;
+  unsigned char saw_z;
+  void *eh_ptr;
+} _Unwind_FrameState;
+
+/* Read unaligned data from the instruction buffer.  */
+
+union unaligned
+{
+  void *p;
+  unsigned u2 __attribute__ ((mode (HI)));
+  unsigned u4 __attribute__ ((mode (SI)));
+  unsigned u8 __attribute__ ((mode (DI)));
+  signed s2 __attribute__ ((mode (HI)));
+  signed s4 __attribute__ ((mode (SI)));
+  signed s8 __attribute__ ((mode (DI)));
+} __attribute__ ((packed));
+
+static inline void *
+read_pointer (const void *p) { const union unaligned *up = p; return up->p; }
+
+static inline int
+read_1u (const void *p) { return *(const unsigned char *) p; }
+
+static inline int
+read_1s (const void *p) { return *(const signed char *) p; }
+
+static inline int
+read_2u (const void *p) { const union unaligned *up = p; return up->u2; }
+
+static inline int
+read_2s (const void *p) { const union unaligned *up = p; return up->s2; }
+
+static inline unsigned int
+read_4u (const void *p) { const union unaligned *up = p; return up->u4; }
+
+static inline int
+read_4s (const void *p) { const union unaligned *up = p; return up->s4; }
+
+static inline unsigned long
+read_8u (const void *p) { const union unaligned *up = p; return up->u8; }
+
+static inline unsigned long
+read_8s (const void *p) { const union unaligned *up = p; return up->s8; }
+
+/* Get the value of register REG as saved in CONTEXT.  */
+
+inline _Unwind_Word
+_Unwind_GetGR (struct _Unwind_Context *context, int index)
+{
+  int size;
+  void *ptr;
+
+  index = DWARF_REG_TO_UNWIND_COLUMN (index);
+  if (index >= (int) sizeof(dwarf_reg_size_table))
+    abort ();
+  size = dwarf_reg_size_table[index];
+  ptr = context->reg[index];
+
+  /* This will segfault if the register hasn't been saved.  */
+  if (size == sizeof(_Unwind_Ptr))
+    return * (_Unwind_Ptr *) ptr;
+
+  if (size == sizeof(_Unwind_Word))
+    return * (_Unwind_Word *) ptr;
+
+  // We don't want to require gcc-3.4.0 for compiling the kernel.
+#if __GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)
+  return * (_Unwind_Word *) context->reg[index];
+#endif
+
+  abort ();
+}
+
+static inline void *
+_Unwind_GetPtr (struct _Unwind_Context *context, int index)
+{
+  return (void *)(_Unwind_Ptr) _Unwind_GetGR (context, index);
+}
+
+/* Get the value of the CFA as saved in CONTEXT.  */
+
+_Unwind_Word
+_Unwind_GetCFA (struct _Unwind_Context *context)
+{
+  return (_Unwind_Ptr) context->cfa;
+}
+
+/* Overwrite the saved value for register REG in CONTEXT with VAL.  */
+
+inline void
+_Unwind_SetGR (struct _Unwind_Context *context, int index, _Unwind_Word val)
+{
+  int size;
+  void *ptr;
+
+  index = DWARF_REG_TO_UNWIND_COLUMN (index);
+  if (index >= (int) sizeof(dwarf_reg_size_table))
+    abort ();
+  size = dwarf_reg_size_table[index];
+  ptr = context->reg[index];
+
+  if (size == sizeof(_Unwind_Ptr))
+    * (_Unwind_Ptr *) ptr = val;
+  else if (size == sizeof(_Unwind_Word))
+    * (_Unwind_Word *) ptr = val;
+  else
+    abort ();
+}
+
+/* Get the pointer to a register INDEX as saved in CONTEXT.  */
+
+static inline void *
+_Unwind_GetGRPtr (struct _Unwind_Context *context, int index)
+{
+  index = DWARF_REG_TO_UNWIND_COLUMN (index);
+  return context->reg[index];
+}
+
+/* Set the pointer to a register INDEX as saved in CONTEXT.  */
+
+static inline void
+_Unwind_SetGRPtr (struct _Unwind_Context *context, int index, void *p)
+{
+  index = DWARF_REG_TO_UNWIND_COLUMN (index);
+  context->reg[index] = p;
+}
+
+/* Retrieve the return address for CONTEXT.  */
+
+inline _Unwind_Ptr
+_Unwind_GetIP (struct _Unwind_Context *context)
+{
+  return (_Unwind_Ptr) context->ra;
+}
+
+/* Overwrite the return address for CONTEXT with VAL.  */
+
+inline void
+_Unwind_SetIP (struct _Unwind_Context *context, _Unwind_Ptr val)
+{
+  context->ra = (void *) val;
+}
+
+void *
+_Unwind_GetLanguageSpecificData (struct _Unwind_Context *context)
+{
+  return context->lsda;
+}
+
+_Unwind_Ptr
+_Unwind_GetRegionStart (struct _Unwind_Context *context)
+{
+  return (_Unwind_Ptr) context->bases.func;
+}
+
+void *
+_Unwind_FindEnclosingFunction (void *pc)
+{
+  struct dwarf_eh_bases bases;
+  const struct dwarf_fde *fde = _Unwind_Find_FDE (pc-1, &bases);
+  if (fde)
+    return bases.func;
+  else
+    return NULL;
+}
+
+#ifndef __ia64__
+_Unwind_Ptr
+_Unwind_GetDataRelBase (struct _Unwind_Context *context)
+{
+  return (_Unwind_Ptr) context->bases.dbase;
+}
+
+_Unwind_Ptr
+_Unwind_GetTextRelBase (struct _Unwind_Context *context)
+{
+  return (_Unwind_Ptr) context->bases.tbase;
+}
+#endif
+
+/* Extract any interesting information from the CIE for the translation
+   unit F belongs to.  Return a pointer to the byte after the augmentation,
+   or NULL if we encountered an undecipherable augmentation.  */
+
+static const unsigned char *
+extract_cie_info (const struct dwarf_cie *cie, struct _Unwind_Context *context,
+		  _Unwind_FrameState *fs)
+{
+  const unsigned char *aug = cie->augmentation;
+  const unsigned char *p = aug + strlen (aug) + 1;
+  const unsigned char *ret = NULL;
+  _Unwind_Word utmp;
+
+  /* g++ v2 "eh" has pointer immediately following augmentation string,
+     so it must be handled first.  */
+  if (aug[0] == 'e' && aug[1] == 'h')
+    {
+      fs->eh_ptr = read_pointer (p);
+      p += sizeof (void *);
+      aug += 2;
+    }
+
+  /* Immediately following the augmentation are the code and
+     data alignment and return address column.  */
+  p = read_uleb128 (p, &fs->code_align);
+  p = read_sleb128 (p, &fs->data_align);
+  fs->retaddr_column = *p++;
+  fs->lsda_encoding = DW_EH_PE_omit;
+
+  /* If the augmentation starts with 'z', then a uleb128 immediately
+     follows containing the length of the augmentation field following
+     the size.  */
+  if (*aug == 'z')
+    {
+      p = read_uleb128 (p, &utmp);
+      ret = p + utmp;
+
+      fs->saw_z = 1;
+      ++aug;
+    }
+
+  /* Iterate over recognized augmentation subsequences.  */
+  while (*aug != '\0')
+    {
+      /* "L" indicates a byte showing how the LSDA pointer is encoded.  */
+      if (aug[0] == 'L')
+	{
+	  fs->lsda_encoding = *p++;
+	  aug += 1;
+	}
+
+      /* "R" indicates a byte indicating how FDE addresses are encoded.  */
+      else if (aug[0] == 'R')
+	{
+	  fs->fde_encoding = *p++;
+	  aug += 1;
+	}
+
+      /* "P" indicates a personality routine in the CIE augmentation.  */
+      else if (aug[0] == 'P')
+	{
+	  p = read_encoded_value (context, *p, p + 1,
+				  (_Unwind_Ptr *) &fs->personality);
+	  aug += 1;
+	}
+
+      /* Otherwise we have an unknown augmentation string.
+	 Bail unless we saw a 'z' prefix.  */
+      else
+	return ret;
+    }
+
+  return ret ? ret : p;
+}
+
+
+/* Decode a DW_OP stack program.  Return the top of stack.  Push INITIAL
+   onto the stack to start.  */
+
+static _Unwind_Word
+execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,
+		  struct _Unwind_Context *context, _Unwind_Word initial)
+{
+  _Unwind_Word stack[64];	/* ??? Assume this is enough.  */
+  int stack_elt;
+
+  stack[0] = initial;
+  stack_elt = 1;
+
+  while (op_ptr < op_end)
+    {
+      enum dwarf_location_atom op = *op_ptr++;
+      _Unwind_Word result, reg, utmp;
+      _Unwind_Sword offset, stmp;
+
+      switch (op)
+	{
+	case DW_OP_lit0:
+	case DW_OP_lit1:
+	case DW_OP_lit2:
+	case DW_OP_lit3:
+	case DW_OP_lit4:
+	case DW_OP_lit5:
+	case DW_OP_lit6:
+	case DW_OP_lit7:
+	case DW_OP_lit8:
+	case DW_OP_lit9:
+	case DW_OP_lit10:
+	case DW_OP_lit11:
+	case DW_OP_lit12:
+	case DW_OP_lit13:
+	case DW_OP_lit14:
+	case DW_OP_lit15:
+	case DW_OP_lit16:
+	case DW_OP_lit17:
+	case DW_OP_lit18:
+	case DW_OP_lit19:
+	case DW_OP_lit20:
+	case DW_OP_lit21:
+	case DW_OP_lit22:
+	case DW_OP_lit23:
+	case DW_OP_lit24:
+	case DW_OP_lit25:
+	case DW_OP_lit26:
+	case DW_OP_lit27:
+	case DW_OP_lit28:
+	case DW_OP_lit29:
+	case DW_OP_lit30:
+	case DW_OP_lit31:
+	  result = op - DW_OP_lit0;
+	  break;
+
+	case DW_OP_addr:
+	  result = (_Unwind_Word) (_Unwind_Ptr) read_pointer (op_ptr);
+	  op_ptr += sizeof (void *);
+	  break;
+
+	case DW_OP_const1u:
+	  result = read_1u (op_ptr);
+	  op_ptr += 1;
+	  break;
+	case DW_OP_const1s:
+	  result = read_1s (op_ptr);
+	  op_ptr += 1;
+	  break;
+	case DW_OP_const2u:
+	  result = read_2u (op_ptr);
+	  op_ptr += 2;
+	  break;
+	case DW_OP_const2s:
+	  result = read_2s (op_ptr);
+	  op_ptr += 2;
+	  break;
+	case DW_OP_const4u:
+	  result = read_4u (op_ptr);
+	  op_ptr += 4;
+	  break;
+	case DW_OP_const4s:
+	  result = read_4s (op_ptr);
+	  op_ptr += 4;
+	  break;
+	case DW_OP_const8u:
+	  result = read_8u (op_ptr);
+	  op_ptr += 8;
+	  break;
+	case DW_OP_const8s:
+	  result = read_8s (op_ptr);
+	  op_ptr += 8;
+	  break;
+	case DW_OP_constu:
+	  op_ptr = read_uleb128 (op_ptr, &result);
+	  break;
+	case DW_OP_consts:
+	  op_ptr = read_sleb128 (op_ptr, &stmp);
+	  result = stmp;
+	  break;
+
+	case DW_OP_reg0:
+	case DW_OP_reg1:
+	case DW_OP_reg2:
+	case DW_OP_reg3:
+	case DW_OP_reg4:
+	case DW_OP_reg5:
+	case DW_OP_reg6:
+	case DW_OP_reg7:
+	case DW_OP_reg8:
+	case DW_OP_reg9:
+	case DW_OP_reg10:
+	case DW_OP_reg11:
+	case DW_OP_reg12:
+	case DW_OP_reg13:
+	case DW_OP_reg14:
+	case DW_OP_reg15:
+	case DW_OP_reg16:
+	case DW_OP_reg17:
+	case DW_OP_reg18:
+	case DW_OP_reg19:
+	case DW_OP_reg20:
+	case DW_OP_reg21:
+	case DW_OP_reg22:
+	case DW_OP_reg23:
+	case DW_OP_reg24:
+	case DW_OP_reg25:
+	case DW_OP_reg26:
+	case DW_OP_reg27:
+	case DW_OP_reg28:
+	case DW_OP_reg29:
+	case DW_OP_reg30:
+	case DW_OP_reg31:
+	  result = _Unwind_GetGR (context, op - DW_OP_reg0);
+	  break;
+	case DW_OP_regx:
+	  op_ptr = read_uleb128 (op_ptr, &reg);
+	  result = _Unwind_GetGR (context, reg);
+	  break;
+
+	case DW_OP_breg0:
+	case DW_OP_breg1:
+	case DW_OP_breg2:
+	case DW_OP_breg3:
+	case DW_OP_breg4:
+	case DW_OP_breg5:
+	case DW_OP_breg6:
+	case DW_OP_breg7:
+	case DW_OP_breg8:
+	case DW_OP_breg9:
+	case DW_OP_breg10:
+	case DW_OP_breg11:
+	case DW_OP_breg12:
+	case DW_OP_breg13:
+	case DW_OP_breg14:
+	case DW_OP_breg15:
+	case DW_OP_breg16:
+	case DW_OP_breg17:
+	case DW_OP_breg18:
+	case DW_OP_breg19:
+	case DW_OP_breg20:
+	case DW_OP_breg21:
+	case DW_OP_breg22:
+	case DW_OP_breg23:
+	case DW_OP_breg24:
+	case DW_OP_breg25:
+	case DW_OP_breg26:
+	case DW_OP_breg27:
+	case DW_OP_breg28:
+	case DW_OP_breg29:
+	case DW_OP_breg30:
+	case DW_OP_breg31:
+	  op_ptr = read_sleb128 (op_ptr, &offset);
+	  result = _Unwind_GetGR (context, op - DW_OP_breg0) + offset;
+	  break;
+	case DW_OP_bregx:
+	  op_ptr = read_uleb128 (op_ptr, &reg);
+	  op_ptr = read_sleb128 (op_ptr, &offset);
+	  result = _Unwind_GetGR (context, reg) + offset;
+	  break;
+
+	case DW_OP_dup:
+	  if (stack_elt < 1)
+	    abort ();
+	  result = stack[stack_elt - 1];
+	  break;
+
+	case DW_OP_drop:
+	  if (--stack_elt < 0)
+	    abort ();
+	  goto no_push;
+
+	case DW_OP_pick:
+	  offset = *op_ptr++;
+	  if (offset >= stack_elt - 1)
+	    abort ();
+	  result = stack[stack_elt - 1 - offset];
+	  break;
+
+	case DW_OP_over:
+	  if (stack_elt < 2)
+	    abort ();
+	  result = stack[stack_elt - 2];
+	  break;
+
+	case DW_OP_rot:
+	  {
+	    _Unwind_Word t1, t2, t3;
+
+	    if (stack_elt < 3)
+	      abort ();
+	    t1 = stack[stack_elt - 1];
+	    t2 = stack[stack_elt - 2];
+	    t3 = stack[stack_elt - 3];
+	    stack[stack_elt - 1] = t2;
+	    stack[stack_elt - 2] = t3;
+	    stack[stack_elt - 3] = t1;
+	    goto no_push;
+	  }
+
+	case DW_OP_deref:
+	case DW_OP_deref_size:
+	case DW_OP_abs:
+	case DW_OP_neg:
+	case DW_OP_not:
+	case DW_OP_plus_uconst:
+	  /* Unary operations.  */
+	  if (--stack_elt < 0)
+	    abort ();
+	  result = stack[stack_elt];
+
+	  switch (op)
+	    {
+	    case DW_OP_deref:
+	      {
+		void *ptr = (void *) (_Unwind_Ptr) result;
+		result = (_Unwind_Ptr) read_pointer (ptr);
+	      }
+	      break;
+
+	    case DW_OP_deref_size:
+	      {
+		void *ptr = (void *) (_Unwind_Ptr) result;
+		switch (*op_ptr++)
+		  {
+		  case 1:
+		    result = read_1u (ptr);
+		    break;
+		  case 2:
+		    result = read_2u (ptr);
+		    break;
+		  case 4:
+		    result = read_4u (ptr);
+		    break;
+		  case 8:
+		    result = read_8u (ptr);
+		    break;
+		  default:
+		    abort ();
+		  }
+	      }
+	      break;
+
+	    case DW_OP_abs:
+	      if ((_Unwind_Sword) result < 0)
+		result = -result;
+	      break;
+	    case DW_OP_neg:
+	      result = -result;
+	      break;
+	    case DW_OP_not:
+	      result = ~result;
+	      break;
+	    case DW_OP_plus_uconst:
+	      op_ptr = read_uleb128 (op_ptr, &utmp);
+	      result += utmp;
+	      break;
+
+	    default:
+	      abort ();
+	    }
+	  break;
+
+	case DW_OP_and:
+	case DW_OP_div:
+	case DW_OP_minus:
+	case DW_OP_mod:
+	case DW_OP_mul:
+	case DW_OP_or:
+	case DW_OP_plus:
+	case DW_OP_le:
+	case DW_OP_ge:
+	case DW_OP_eq:
+	case DW_OP_lt:
+	case DW_OP_gt:
+	case DW_OP_ne:
+	  {
+	    /* Binary operations.  */
+	    _Unwind_Word first, second;
+	    if ((stack_elt -= 2) < 0)
+	      abort ();
+	    second = stack[stack_elt];
+	    first = stack[stack_elt + 1];
+
+	    switch (op)
+	      {
+	      case DW_OP_and:
+		result = second & first;
+		break;
+	      case DW_OP_div:
+		result = (_Unwind_Sword) second / (_Unwind_Sword) first;
+		break;
+	      case DW_OP_minus:
+		result = second - first;
+		break;
+	      case DW_OP_mod:
+		result = (_Unwind_Sword) second % (_Unwind_Sword) first;
+		break;
+	      case DW_OP_mul:
+		result = second * first;
+		break;
+	      case DW_OP_or:
+		result = second | first;
+		break;
+	      case DW_OP_plus:
+		result = second + first;
+		break;
+	      case DW_OP_shl:
+		result = second << first;
+		break;
+	      case DW_OP_shr:
+		result = second >> first;
+		break;
+	      case DW_OP_shra:
+		result = (_Unwind_Sword) second >> first;
+		break;
+	      case DW_OP_xor:
+		result = second ^ first;
+		break;
+	      case DW_OP_le:
+		result = (_Unwind_Sword) first <= (_Unwind_Sword) second;
+		break;
+	      case DW_OP_ge:
+		result = (_Unwind_Sword) first >= (_Unwind_Sword) second;
+		break;
+	      case DW_OP_eq:
+		result = (_Unwind_Sword) first == (_Unwind_Sword) second;
+		break;
+	      case DW_OP_lt:
+		result = (_Unwind_Sword) first < (_Unwind_Sword) second;
+		break;
+	      case DW_OP_gt:
+		result = (_Unwind_Sword) first > (_Unwind_Sword) second;
+		break;
+	      case DW_OP_ne:
+		result = (_Unwind_Sword) first != (_Unwind_Sword) second;
+		break;
+
+	      default:
+		abort ();
+	      }
+	  }
+	  break;
+
+	case DW_OP_skip:
+	  offset = read_2s (op_ptr);
+	  op_ptr += 2;
+	  op_ptr += offset;
+	  goto no_push;
+
+	case DW_OP_bra:
+	  if (--stack_elt < 0)
+	    abort ();
+	  offset = read_2s (op_ptr);
+	  op_ptr += 2;
+	  if (stack[stack_elt] != 0)
+	    op_ptr += offset;
+	  goto no_push;
+
+	case DW_OP_nop:
+	  goto no_push;
+
+	default:
+	  abort ();
+	}
+
+      /* Most things push a result value.  */
+      if ((size_t) stack_elt >= sizeof(stack)/sizeof(*stack))
+	abort ();
+      stack[stack_elt++] = result;
+    no_push:;
+    }
+
+  /* We were executing this program to get a value.  It should be
+     at top of stack.  */
+  if (--stack_elt < 0)
+    abort ();
+  return stack[stack_elt];
+}
+
+
+/* Decode DWARF 2 call frame information. Takes pointers the
+   instruction sequence to decode, current register information and
+   CIE info, and the PC range to evaluate.  */
+
+static void
+execute_cfa_program (const unsigned char *insn_ptr,
+		     const unsigned char *insn_end,
+		     struct _Unwind_Context *context,
+		     _Unwind_FrameState *fs)
+{
+  struct frame_state_reg_info *unused_rs = NULL;
+  /* Don't allow remember/restore between CIE and FDE programs.  */
+  fs->regs.prev = NULL;
+
+  /* The comparison with the return address uses < rather than <= because
+     we are only interested in the effects of code before the call; for a
+     noreturn function, the return address may point to unrelated code with
+     a different stack configuration that we are not interested in.  We
+     assume that the call itself is unwind info-neutral; if not, or if
+     there are delay instructions that adjust the stack, these must be
+     reflected at the point immediately before the call insn.  */
+  while (insn_ptr < insn_end && fs->pc < context->ra)
+    {
+      unsigned char insn = *insn_ptr++;
+      _Unwind_Word reg, utmp;
+      _Unwind_Sword offset, stmp;
+
+      if ((insn & 0xc0) == DW_CFA_advance_loc)
+	fs->pc += (insn & 0x3f) * fs->code_align;
+      else if ((insn & 0xc0) == DW_CFA_offset)
+	{
+	  reg = insn & 0x3f;
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
+	  offset = (_Unwind_Sword) utmp * fs->data_align;
+	  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how
+	    = REG_SAVED_OFFSET;
+	  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;
+	}
+      else if ((insn & 0xc0) == DW_CFA_restore)
+	{
+	  reg = insn & 0x3f;
+	  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_UNSAVED;
+	}
+      else switch (insn)
+	{
+	case DW_CFA_set_loc:
+	  insn_ptr = read_encoded_value (context, fs->fde_encoding,
+					 insn_ptr, (_Unwind_Ptr *) &fs->pc);
+	  break;
+
+	case DW_CFA_advance_loc1:
+	  fs->pc += read_1u (insn_ptr) * fs->code_align;
+	  insn_ptr += 1;
+	  break;
+	case DW_CFA_advance_loc2:
+	  fs->pc += read_2u (insn_ptr) * fs->code_align;
+	  insn_ptr += 2;
+	  break;
+	case DW_CFA_advance_loc4:
+	  fs->pc += read_4u (insn_ptr) * fs->code_align;
+	  insn_ptr += 4;
+	  break;
+
+	case DW_CFA_offset_extended:
+	  insn_ptr = read_uleb128 (insn_ptr, &reg);
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
+	  offset = (_Unwind_Sword) utmp * fs->data_align;
+	  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how
+	    = REG_SAVED_OFFSET;
+	  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;
+	  break;
+
+	case DW_CFA_restore_extended:
+	  insn_ptr = read_uleb128 (insn_ptr, &reg);
+	  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN(reg)].how = REG_UNSAVED;
+	  break;
+
+	case DW_CFA_undefined:
+	case DW_CFA_same_value:
+	  insn_ptr = read_uleb128 (insn_ptr, &reg);
+	  break;
+
+	case DW_CFA_nop:
+	  break;
+
+	case DW_CFA_register:
+	  {
+	    _Unwind_Word reg2;
+	    insn_ptr = read_uleb128 (insn_ptr, &reg);
+	    insn_ptr = read_uleb128 (insn_ptr, &reg2);
+	    fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_SAVED_REG;
+	    fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.reg = reg2;
+	  }
+	  break;
+
+	case DW_CFA_remember_state:
+	  {
+	    struct frame_state_reg_info *new_rs;
+	    if (unused_rs)
+	      {
+		new_rs = unused_rs;
+		unused_rs = unused_rs->prev;
+	      }
+	    else
+	      new_rs = __builtin_alloca (sizeof (struct frame_state_reg_info));
+
+	    *new_rs = fs->regs;
+	    fs->regs.prev = new_rs;
+	  }
+	  break;
+
+	case DW_CFA_restore_state:
+	  {
+	    struct frame_state_reg_info *old_rs = fs->regs.prev;
+	    fs->regs = *old_rs;
+	    old_rs->prev = unused_rs;
+	    unused_rs = old_rs;
+	  }
+	  break;
+
+	case DW_CFA_def_cfa:
+	  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_reg);
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
+	  fs->cfa_offset = utmp;
+	  fs->cfa_how = CFA_REG_OFFSET;
+	  break;
+
+	case DW_CFA_def_cfa_register:
+	  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_reg);
+	  fs->cfa_how = CFA_REG_OFFSET;
+	  break;
+
+	case DW_CFA_def_cfa_offset:
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
+	  fs->cfa_offset = utmp;
+	  /* cfa_how deliberately not set.  */
+	  break;
+
+	case DW_CFA_def_cfa_expression:
+	  fs->cfa_exp = insn_ptr;
+	  fs->cfa_how = CFA_EXP;
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
+	  insn_ptr += utmp;
+	  break;
+
+	case DW_CFA_expression:
+	  insn_ptr = read_uleb128 (insn_ptr, &reg);
+	  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how = REG_SAVED_EXP;
+	  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.exp = insn_ptr;
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
+	  insn_ptr += utmp;
+	  break;
+
+	  /* From the 2.1 draft.  */
+	case DW_CFA_offset_extended_sf:
+	  insn_ptr = read_uleb128 (insn_ptr, &reg);
+	  insn_ptr = read_sleb128 (insn_ptr, &stmp);
+	  offset = stmp * fs->data_align;
+	  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how
+	    = REG_SAVED_OFFSET;
+	  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = offset;
+	  break;
+
+	case DW_CFA_def_cfa_sf:
+	  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_reg);
+	  insn_ptr = read_sleb128 (insn_ptr, &fs->cfa_offset);
+	  fs->cfa_how = CFA_REG_OFFSET;
+	  break;
+
+	case DW_CFA_def_cfa_offset_sf:
+	  insn_ptr = read_sleb128 (insn_ptr, &fs->cfa_offset);
+	  /* cfa_how deliberately not set.  */
+	  break;
+
+	case DW_CFA_GNU_window_save:
+	  /* ??? Hardcoded for SPARC register window configuration.  */
+	  for (reg = 16; reg < 32; ++reg)
+	    {
+	      fs->regs.reg[reg].how = REG_SAVED_OFFSET;
+	      fs->regs.reg[reg].loc.offset = (reg - 16) * sizeof (void *);
+	    }
+	  break;
+
+	case DW_CFA_GNU_args_size:
+	  insn_ptr = read_uleb128 (insn_ptr, &context->args_size);
+	  break;
+
+	case DW_CFA_GNU_negative_offset_extended:
+	  /* Obsoleted by DW_CFA_offset_extended_sf, but used by
+	     older PowerPC code.  */
+	  insn_ptr = read_uleb128 (insn_ptr, &reg);
+	  insn_ptr = read_uleb128 (insn_ptr, &utmp);
+	  offset = (_Unwind_Word) utmp * fs->data_align;
+	  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].how
+	    = REG_SAVED_OFFSET;
+	  fs->regs.reg[DWARF_REG_TO_UNWIND_COLUMN (reg)].loc.offset = -offset;
+	  break;
+
+	default:
+	  abort ();
+	}
+    }
+}
+
+
+
+/* Given the _Unwind_Context CONTEXT for a stack frame, look up the FDE for
+   its caller and decode it into FS.  This function also sets the
+   args_size and lsda members of CONTEXT, as they are really information
+   about the caller's frame.  */
+
+//routine that caches fs info!!!
+
+#include <linux/customhash.h>
+
+struct fs_cache {
+        struct fs_cache **pprev_fs_cache_hash;
+        struct fs_cache *next_fs_cache_hash;
+        int ra;
+        _Unwind_FrameState *fs;
+        void* tbase;
+        void* dbase;
+        void* func;
+        _Unwind_Word args_size;
+        void *lsda;
+};
+
+ HASH(fs_cache, struct fs_cache, 8,
+ (fs_cache->ra== ra),
+ (ra),
+ (fs_cache->ra),
+ int ra)
+
+ _Unwind_Reason_Code
+uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState **fs_pointer)
+{
+  const struct dwarf_fde *fde;
+  const struct dwarf_cie *cie;
+  const unsigned char *aug, *insn, *end;
+  _Unwind_FrameState *fs;
+  struct fs_cache* cached_fs;
+ 
+
+   //now check if the fs can be found in the cache???
+   cached_fs = hash_find_fs_cache((int) context->ra);
+   if(cached_fs!=0)
+   {
+   	   context->bases.dbase=cached_fs->dbase;
+   	   context->bases.tbase=cached_fs->tbase;
+   	   context->bases.func=cached_fs->func;
+   	   context->args_size=cached_fs->args_size;
+   	   context->lsda=cached_fs->lsda;
+   	   *fs_pointer=cached_fs->fs;
+   	   return _URC_NO_REASON;
+   }
+   fs= malloc (sizeof (_Unwind_FrameState));
+   memset (fs, 0, sizeof (*fs));
+   context->args_size = 0;
+  context->lsda = 0;
+  
+  
+
+  if (context->ra == 0)
+    return _URC_END_OF_STACK;
+
+  fde = _Unwind_Find_FDE (context->ra - 1, &context->bases);
+  
+       
+  if (fde == NULL)
+    {
+      /* Couldn't find frame unwind info for this function.  Try a
+	 target-specific fallback mechanism.  This will necessarily
+	 not provide a personality routine or LSDA.  */
+#ifdef MD_FALLBACK_FRAME_STATE_FOR
+      MD_FALLBACK_FRAME_STATE_FOR (context, fs, success);
+      return _URC_END_OF_STACK;
+    success:
+      return _URC_NO_REASON;
+#else
+      return _URC_END_OF_STACK;
+#endif
+    }
+
+  fs->pc = context->bases.func;
+
+  cie = get_cie (fde);
+  insn = extract_cie_info (cie, context, fs);
+  if (insn == NULL)
+    /* CIE contained unknown augmentation.  */
+    return _URC_FATAL_PHASE1_ERROR;
+
+  /* First decode all the insns in the CIE.  */
+  end = (unsigned char *) next_fde ((struct dwarf_fde *) cie);
+  execute_cfa_program (insn, end, context, fs);
+
+  /* Locate augmentation for the fde.  */
+  aug = (unsigned char *) fde + sizeof (*fde);
+  aug += 2 * size_of_encoded_value (fs->fde_encoding);
+  insn = NULL;
+  if (fs->saw_z)
+    {
+      _Unwind_Word i;
+      aug = read_uleb128 (aug, &i);
+      insn = aug + i;
+    }
+  if (fs->lsda_encoding != DW_EH_PE_omit)
+    aug = read_encoded_value (context, fs->lsda_encoding, aug,
+			      (_Unwind_Ptr *) &context->lsda);
+
+  /* Then the insns in the FDE up to our target PC.  */
+  if (insn == NULL)
+    insn = aug;
+  end = (unsigned char *) next_fde (fde);
+  execute_cfa_program (insn, end, context, fs);
+  //now update the cache!
+  {
+       cached_fs = malloc (sizeof (struct fs_cache));
+       cached_fs->ra = (int) context->ra;
+       cached_fs->fs=fs;
+       cached_fs->dbase = context->bases.dbase;
+       cached_fs->tbase = context->bases.tbase;
+       cached_fs->func = context->bases.func;
+       cached_fs->args_size = context->args_size;
+       cached_fs->lsda = context->lsda;
+       hash_init_fs_cache(cached_fs);
+       hash_add_fs_cache(cached_fs); 
+  }     
+  *fs_pointer=fs;
+  return _URC_NO_REASON;
+}
+
+
+
+typedef struct frame_state
+{
+  void *cfa;
+  void *eh_ptr;
+  long cfa_offset;
+  long args_size;
+  long reg_or_offset[PRE_GCC3_DWARF_FRAME_REGISTERS+1];
+  unsigned short cfa_reg;
+  unsigned short retaddr_column;
+  char saved[PRE_GCC3_DWARF_FRAME_REGISTERS+1];
+} frame_state;
+
+struct frame_state * __frame_state_for (void *, struct frame_state *);
+
+/* Called from pre-G++ 3.0 __throw to find the registers to restore for
+   a given PC_TARGET.  The caller should allocate a local variable of
+   `struct frame_state' and pass its address to STATE_IN.  */
+
+struct frame_state *
+__frame_state_for (void *pc_target, struct frame_state *state_in)
+{
+  struct _Unwind_Context context;
+  
+  _Unwind_FrameState *fs;
+  int reg;
+
+  memset (&context, 0, sizeof (struct _Unwind_Context));
+  context.ra = pc_target + 1;
+
+
+
+
+  if (uw_frame_state_for (&context, &fs) != _URC_NO_REASON)
+    return 0;
+
+  /* We have no way to pass a location expression for the CFA to our
+     caller.  It wouldn't understand it anyway.  */
+  if (fs->cfa_how == CFA_EXP)
+    return 0;
+
+  for (reg = 0; reg < PRE_GCC3_DWARF_FRAME_REGISTERS + 1; reg++)
+    {
+      state_in->saved[reg] = fs->regs.reg[reg].how;
+      switch (state_in->saved[reg])
+	{
+	case REG_SAVED_REG:
+	  state_in->reg_or_offset[reg] = fs->regs.reg[reg].loc.reg;
+	  break;
+	case REG_SAVED_OFFSET:
+	  state_in->reg_or_offset[reg] = fs->regs.reg[reg].loc.offset;
+	  break;
+	default:
+	  state_in->reg_or_offset[reg] = 0;
+	  break;
+	}
+    }
+
+  state_in->cfa_offset = fs->cfa_offset;
+  state_in->cfa_reg = fs->cfa_reg;
+  state_in->retaddr_column = fs->retaddr_column;
+  state_in->args_size = context.args_size;
+  state_in->eh_ptr = fs->eh_ptr;
+
+  return state_in;
+}
+
+
+
+typedef union { _Unwind_Ptr ptr; _Unwind_Word word; } _Unwind_SpTmp;
+
+static inline void
+_Unwind_SetSpColumn (struct _Unwind_Context *context, void *cfa,
+                     _Unwind_SpTmp *tmp_sp)
+{
+  int size = dwarf_reg_size_table[__builtin_dwarf_sp_column ()];
+  
+  if (size == sizeof(_Unwind_Ptr))
+    tmp_sp->ptr = (_Unwind_Ptr) cfa;
+  else if (size == sizeof(_Unwind_Word))
+    tmp_sp->word = (_Unwind_Ptr) cfa;
+  else
+    abort ();
+  _Unwind_SetGRPtr (context, __builtin_dwarf_sp_column (), tmp_sp);
+}
+
+ void
+uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  struct _Unwind_Context orig_context = *context;
+  void *cfa;
+  long i;
+
+#ifdef EH_RETURN_STACKADJ_RTX
+  /* Special handling here: Many machines do not use a frame pointer,
+     and track the CFA only through offsets from the stack pointer from
+     one frame to the next.  In this case, the stack pointer is never
+     stored, so it has no saved address in the context.  What we do
+     have is the CFA from the previous stack frame.
+
+     In very special situations (such as unwind info for signal return),
+     there may be location expressions that use the stack pointer as well.
+
+     Do this conditionally for one frame.  This allows the unwind info
+     for one frame to save a copy of the stack pointer from the previous
+     frame, and be able to use much easier CFA mechanisms to do it.
+     Always zap the saved stack pointer value for the next frame; carrying
+     the value over from one frame to another doesn't make sense.  */
+
+  _Unwind_SpTmp tmp_sp;
+
+  if (!_Unwind_GetGRPtr (&orig_context, __builtin_dwarf_sp_column ()))
+    _Unwind_SetSpColumn (&orig_context, context->cfa, &tmp_sp);
+  _Unwind_SetGRPtr (context, __builtin_dwarf_sp_column (), NULL);
+#endif
+
+  /* Compute this frame's CFA.  */
+  switch (fs->cfa_how)
+    {
+    case CFA_REG_OFFSET:
+      cfa = _Unwind_GetPtr (&orig_context, fs->cfa_reg);
+      cfa += fs->cfa_offset;
+      break;
+
+    case CFA_EXP:
+      {
+	const unsigned char *exp = fs->cfa_exp;
+	_Unwind_Word len;
+
+	exp = read_uleb128 (exp, &len);
+	cfa = (void *) (_Unwind_Ptr)
+	  execute_stack_op (exp, exp + len, &orig_context, 0);
+	break;
+      }
+
+    default:
+      abort ();
+    }
+  context->cfa = cfa;
+
+  /* Compute the addresses of all registers saved in this frame.  */
+  for (i = 0; i < DWARF_FRAME_REGISTERS + 1; ++i)
+    switch (fs->regs.reg[i].how)
+      {
+      case REG_UNSAVED:
+	break;
+
+      case REG_SAVED_OFFSET:
+	_Unwind_SetGRPtr (context, i,
+			  (void *) (cfa + fs->regs.reg[i].loc.offset));
+	break;
+
+      case REG_SAVED_REG:
+	_Unwind_SetGRPtr
+	  (context, i,
+	   _Unwind_GetGRPtr (&orig_context, fs->regs.reg[i].loc.reg));
+	break;
+
+      case REG_SAVED_EXP:
+	{
+	  const unsigned char *exp = fs->regs.reg[i].loc.exp;
+	  _Unwind_Word len;
+	  _Unwind_Ptr val;
+
+	  exp = read_uleb128 (exp, &len);
+	  val = execute_stack_op (exp, exp + len, &orig_context,
+				  (_Unwind_Ptr) cfa);
+	  _Unwind_SetGRPtr (context, i, (void *) val);
+	}
+	break;
+      }
+
+  MD_FROB_UPDATE_CONTEXT (context, fs);
+}
+
+/* CONTEXT describes the unwind state for a frame, and FS describes the FDE
+   of its caller.  Update CONTEXT to refer to the caller as well.  Note
+   that the args_size and lsda members are not updated here, but later in
+   uw_frame_state_for.  */
+
+ void
+uw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  uw_update_context_1 (context, fs);
+
+  /* Compute the return address now, since the return address column
+     can change from frame to frame.  */
+  context->ra = __builtin_extract_return_addr
+    (_Unwind_GetPtr (context, fs->retaddr_column));
+}
+
+/* Fill in CONTEXT for top-of-stack.  The only valid registers at this
+   level will be the return address and the CFA.  */
+
+#define uw_init_context(CONTEXT)					   \
+  do									   \
+    {									   \
+      /* Do any necessary initialization to access arbitrary stack frames. \
+	 On the SPARC, this means flushing the register windows.  */	   \
+      __builtin_unwind_init ();						   \
+      uw_init_context_1 (CONTEXT, __builtin_dwarf_cfa (),		   \
+			 __builtin_return_address (0));			   \
+    }									   \
+  while (0)
+
+ inline void
+init_dwarf_reg_size_table (void)
+{
+  __builtin_init_dwarf_reg_size_table (dwarf_reg_size_table);
+}
+
+
+ void
+uw_init_context_1 (struct _Unwind_Context *context,
+		   void *outer_cfa, void *outer_ra)
+{
+  void *ra = __builtin_extract_return_addr (__builtin_return_address (0));
+  _Unwind_FrameState *fs;
+  _Unwind_SpTmp sp_slot;
+
+  memset (context, 0, sizeof (struct _Unwind_Context));
+  context->ra = ra;
+
+  if (uw_frame_state_for (context, &fs) != _URC_NO_REASON)
+    abort ();
+
+#if __GTHREADS
+  {
+    static __gthread_once_t once_regsizes = __GTHREAD_ONCE_INIT;
+    if (__gthread_once (&once_regsizes, init_dwarf_reg_size_table) != 0
+	|| dwarf_reg_size_table[0] == 0)
+      init_dwarf_reg_size_table ();
+  }
+#else
+  if (dwarf_reg_size_table[0] == 0)
+    init_dwarf_reg_size_table ();
+#endif
+
+  /* Force the frame state to use the known cfa value.  */
+  _Unwind_SetSpColumn (context, outer_cfa, &sp_slot);
+  fs->cfa_how = CFA_REG_OFFSET;
+  fs->cfa_reg = __builtin_dwarf_sp_column ();
+  fs->cfa_offset = 0;
+
+  uw_update_context_1 (context, fs);
+
+  /* If the return address column was saved in a register in the
+     initialization context, then we can't see it in the given
+     call frame data.  So have the initialization context tell us.  */
+  context->ra = __builtin_extract_return_addr (outer_ra);
+}
+
+/* Install TARGET into CURRENT so that we can return to it.  This is a
+   macro because __builtin_eh_return must be invoked in the context of
+   our caller.  */
+
+#define uw_install_context(CURRENT, TARGET)				 \
+  do									 \
+    {									 \
+      long offset = uw_install_context_1 ((CURRENT), (TARGET));		 \
+      void *handler = __builtin_frob_return_addr ((TARGET)->ra);	 \
+      __builtin_eh_return (offset, handler);				 \
+    }									 \
+  while (0)
+
+ long
+uw_install_context_1 (struct _Unwind_Context *myCurrent,
+		      struct _Unwind_Context *target)
+{
+  long i;
+
+  for (i = 0; i < DWARF_FRAME_REGISTERS; ++i)
+    {
+      void *c = myCurrent->reg[i];
+      void *t = target->reg[i];
+
+      if (t && c && t != c)
+	memcpy (c, t, dwarf_reg_size_table[i]);
+    }
+
+#ifdef EH_RETURN_STACKADJ_RTX
+  {
+    void *target_cfa;
+
+    /* If the last frame records a saved stack pointer, use it.  */
+    if (_Unwind_GetGRPtr (target, __builtin_dwarf_sp_column ()))
+      target_cfa = _Unwind_GetPtr (target, __builtin_dwarf_sp_column ());
+    else
+      target_cfa = target->cfa;
+
+    /* We adjust SP by the difference between CURRENT and TARGET's CFA.  */
+    if (STACK_GROWS_DOWNWARD)
+      return target_cfa - myCurrent->cfa + target->args_size;
+    else
+      return myCurrent->cfa - target_cfa - target->args_size;
+  }
+#else
+  return 0;
+#endif
+}
+
+ inline _Unwind_Ptr
+uw_identify_context (struct _Unwind_Context *context)
+{
+  return _Unwind_GetIP (context);
+}
+
+/* Exception handling and frame unwind runtime interface routines. -*- C -*-
+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   In addition to the permissions in the GNU General Public License, the
+   Free Software Foundation gives you unlimited permission to link the
+   compiled version of this file into combinations with other programs,
+   and to distribute those combinations without any restriction coming
+   from the use of this file.  (The General Public License restrictions
+   do apply in other respects; for example, they cover modification of
+   the file, and distribution when not linked into a combined
+   executable.)
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+/* This is derived from the C++ ABI for IA-64.  Where we diverge
+   for cross-architecture compatibility are noted with "@@@".  
+   This file is included from unwind-dw2.c or unwind-ia64.c.  */
+
+/* Subroutine of _Unwind_RaiseException also invoked from _Unwind_Resume. 
+
+   Unwind the stack calling the personality routine to find both the
+   exception handler and intermediary cleanup code.  We'll only locate
+   the first such frame here.  Cleanup code will call back into
+   _Unwind_Resume and we'll continue Phase 2 there.  */
+
+
+
+ _Unwind_Reason_Code
+_Unwind_RaiseException_Phase2(struct _Unwind_Exception *exc,
+      struct _Unwind_Context *context)
+{
+  _Unwind_Reason_Code code;
+  
+  while (1)
+    {
+      _Unwind_FrameState fs;
+      int match_handler;
+
+      code = uw_frame_state_for (context, &fs);
+
+      /* Identify when we've reached the designated handler context.  */
+      match_handler = (uw_identify_context (context) == exc->private_2
+       ? _UA_HANDLER_FRAME : 0);
+
+      if (code != _URC_NO_REASON)
+/* Some error encountered.  Usually the unwinder doesn't
+   diagnose these and merely crashes.  */
+return _URC_FATAL_PHASE2_ERROR;
+
+      /* Unwind successful.  Run the personality routine, if any.  */
+      if (fs.personality)
+{
+  code = (*fs.personality) (1, _UA_CLEANUP_PHASE | match_handler,
+    exc->exception_class, exc, context);
+  if (code == _URC_INSTALL_CONTEXT)
+    break;
+  if (code != _URC_CONTINUE_UNWIND) 
+    return _URC_FATAL_PHASE2_ERROR;
+}
+
+      /* Don't let us unwind past the handler context.  */
+      if (match_handler)
+abort ();
+
+      uw_update_context (context, &fs);
+    }
+  
+  return code;
+}
+
+/* Raise an exception, passing along the given exception object.  */
+
+_Unwind_Reason_Code
+_Unwind_RaiseException(struct _Unwind_Exception *exc)
+{
+  struct _Unwind_Context this_context, cur_context;
+  _Unwind_Reason_Code code;
+  /* Set up this_context to describe the current stack frame.  */
+  uw_init_context (&this_context);
+   
+  cur_context = this_context;
+
+  /* Phase 1: Search.  Unwind the stack, calling the personality routine
+     with the _UA_SEARCH_PHASE flag set.  Do not modify the stack yet.  */
+  while (1)
+    {
+      _Unwind_FrameState fs;
+
+      /* Set up fs to describe the FDE for the caller of cur_context.  The
+ first time through the loop, that means __cxa_throw.  */
+      code = uw_frame_state_for (&cur_context, &fs);
+
+     
+      if (code == _URC_END_OF_STACK)
+/* Hit end of stack with no handler found.  */
+return _URC_END_OF_STACK;
+
+      if (code != _URC_NO_REASON)
+/* Some error encountered.  Ususally the unwinder doesn't
+   diagnose these and merely crashes.  */
+return _URC_FATAL_PHASE1_ERROR;
+
+      /* Unwind successful.  Run the personality routine, if any.  */
+      if (fs.personality)
+{
+  code = (*fs.personality) (1, _UA_SEARCH_PHASE, exc->exception_class,
+    exc, &cur_context);
+  if (code == _URC_HANDLER_FOUND)
+    break;
+  else if (code != _URC_CONTINUE_UNWIND)
+    return _URC_FATAL_PHASE1_ERROR;
+}
+      /* Update cur_context to describe the same frame as fs.  */
+      uw_update_context (&cur_context, &fs);
+    }
+
+  /* Indicate to _Unwind_Resume and associated subroutines that this
+     is not a forced unwind.  Further, note where we found a handler.  */
+  exc->private_1 = 0;
+  exc->private_2 = uw_identify_context (&cur_context);
+
+  cur_context = this_context;
+  code = _Unwind_RaiseException_Phase2 (exc, &cur_context);
+  if (code != _URC_INSTALL_CONTEXT)
+    return code;
+
+  uw_install_context (&this_context, &cur_context);
+}
+
+
+/* Subroutine of _Unwind_ForcedUnwind also invoked from _Unwind_Resume.  */
+
+static _Unwind_Reason_Code
+_Unwind_ForcedUnwind_Phase2(struct _Unwind_Exception *exc,
+    struct _Unwind_Context *context)
+{
+  _Unwind_Stop_Fn stop = (_Unwind_Stop_Fn) (_Unwind_Ptr) exc->private_1;
+  void *stop_argument = (void *) (_Unwind_Ptr) exc->private_2;
+  _Unwind_Reason_Code code, stop_code;
+
+  while (1)
+    {
+      _Unwind_FrameState fs;
+      int action;
+
+      /* Set up fs to describe the FDE for the caller of cur_context.  */
+      code = uw_frame_state_for (context, &fs);
+      if (code != _URC_NO_REASON && code != _URC_END_OF_STACK)
+return _URC_FATAL_PHASE2_ERROR;
+
+      /* Unwind successful.  */
+      action = _UA_FORCE_UNWIND | _UA_CLEANUP_PHASE;
+      if (code == _URC_END_OF_STACK)
+action |= _UA_END_OF_STACK;
+      stop_code = (*stop) (1, action, exc->exception_class, exc,
+   context, stop_argument);
+      if (stop_code != _URC_NO_REASON)
+return _URC_FATAL_PHASE2_ERROR;
+
+      /* Stop didn't want to do anything.  Invoke the personality
+ handler, if applicable, to run cleanups.  */
+      if (code == _URC_END_OF_STACK)
+break;
+
+      if (fs.personality)
+{
+  code = (*fs.personality) (1, _UA_FORCE_UNWIND | _UA_CLEANUP_PHASE,
+    exc->exception_class, exc, context);
+  if (code == _URC_INSTALL_CONTEXT)
+    break;
+  if (code != _URC_CONTINUE_UNWIND) 
+    return _URC_FATAL_PHASE2_ERROR;
+}
+
+      /* Update cur_context to describe the same frame as fs.  */
+      uw_update_context (context, &fs);
+    }
+
+  return code;
+}
+
+
+/* Raise an exception for forced unwinding.  */
+
+_Unwind_Reason_Code
+_Unwind_ForcedUnwind (struct _Unwind_Exception *exc,
+      _Unwind_Stop_Fn stop, void * stop_argument)
+{
+  struct _Unwind_Context this_context, cur_context;
+  _Unwind_Reason_Code code;
+
+  uw_init_context (&this_context);
+  cur_context = this_context;
+
+  exc->private_1 = (_Unwind_Ptr) stop;
+  exc->private_2 = (_Unwind_Ptr) stop_argument;
+
+  code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context);
+  if (code != _URC_INSTALL_CONTEXT)
+    return code;
+
+  uw_install_context (&this_context, &cur_context);
+}
+
+
+
+/* Resume propagation of an FORCE_UNWIND exception, or to rethrow
+   a normal exception that was handled.  */
+
+_Unwind_Reason_Code
+_Unwind_Resume_or_Rethrow (struct _Unwind_Exception *exc)
+{
+  struct _Unwind_Context this_context, cur_context;
+  _Unwind_Reason_Code code;
+
+  /* Choose between continuing to process _Unwind_RaiseException
+     or _Unwind_ForcedUnwind.  */
+  if (exc->private_1 == 0)
+    return _Unwind_RaiseException (exc);
+
+  uw_init_context (&this_context);
+  cur_context = this_context;
+
+  code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context);
+
+  if (code != _URC_INSTALL_CONTEXT)
+    abort ();
+
+  uw_install_context (&this_context, &cur_context);
+}
+
+
+/* A convenience function that calls the exception_cleanup field.  */
+
+void
+_Unwind_DeleteException (struct _Unwind_Exception *exc)
+{
+  if (exc->exception_cleanup)
+    (*exc->exception_cleanup) (_URC_FOREIGN_EXCEPTION_CAUGHT, exc);
+}
+
+
+/* Perform stack backtrace through unwind data.  */
+
+_Unwind_Reason_Code
+_Unwind_Backtrace(_Unwind_Trace_Fn trace, void * trace_argument)
+{
+  struct _Unwind_Context context;
+  _Unwind_Reason_Code code;
+
+  uw_init_context (&context);
+
+  while (1)
+    {
+      _Unwind_FrameState fs;
+
+      /* Set up fs to describe the FDE for the caller of context.  */
+      code = uw_frame_state_for (&context, &fs);
+      if (code != _URC_NO_REASON && code != _URC_END_OF_STACK)
+return _URC_FATAL_PHASE1_ERROR;
+
+      /* Call trace function.  */
+      if ((*trace) (&context, trace_argument) != _URC_NO_REASON)
+return _URC_FATAL_PHASE1_ERROR;
+
+      /* We're done at end of stack.  */
+      if (code == _URC_END_OF_STACK)
+break;
+
+      /* Update context to describe the same frame as fs.  */
+      uw_update_context (&context, &fs);
+    }
+
+  return code;
+}
+
+#endif /* !USING_SJLJ_EXCEPTIONS */
diff -urN linux-2.6.9_orig/lib/gcc/unwind-dw2-fde.c linux-2.6.9/lib/gcc/unwind-dw2-fde.c
--- linux-2.6.9_orig/lib/gcc/unwind-dw2-fde.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/unwind-dw2-fde.c	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,1086 @@
+/* Subroutines needed for unwinding stack frames for exception handling.  */
+/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+   Contributed by Jason Merrill <jason@cygnus.com>.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+#ifndef _Unwind_Find_FDE
+#include "tconfig.h"
+#include "tsystem.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "dwarf2.h"
+#include "unwind.h"
+#define NO_BASE_OF_ENCODED_VALUE
+#include "unwind-pe.h"
+#include "unwind-dw2-fde.h"
+#include "gthr.h"
+#endif
+
+
+void registerObject(struct object * ob);
+   
+static struct object *seen_objects;
+
+#ifdef __GTHREAD_MUTEX_INIT
+static __gthread_mutex_t object_mutex = __GTHREAD_MUTEX_INIT;
+#else
+static __gthread_mutex_t object_mutex;
+#endif
+
+#ifdef __GTHREAD_MUTEX_INIT_FUNCTION
+static void
+init_object_mutex (void)
+{
+  __GTHREAD_MUTEX_INIT_FUNCTION (&object_mutex);
+}
+
+static void
+init_object_mutex_once (void)
+{
+  static __gthread_once_t once = __GTHREAD_ONCE_INIT;
+  __gthread_once (&once, init_object_mutex);
+}
+#else
+#define init_object_mutex_once()
+#endif
+
+/* Called from crtbegin.o to register the unwind info for an object.  */
+
+void
+__register_frame_info_bases (const void *begin, struct object *ob,
+			     void *tbase, void *dbase)
+{
+  /* If .eh_frame is empty, don't register at all.  */
+  if ((uword *) begin == 0 || *(uword *) begin == 0)
+    return;
+
+  ob->pc_begin = (void *)-1;
+  ob->tbase = tbase;
+  ob->dbase = dbase;
+  ob->u.single = begin;
+  ob->s.i = 0;
+  ob->s.b.encoding = DW_EH_PE_omit;
+#ifdef DWARF2_OBJECT_END_PTR_EXTENSION
+  ob->fde_end = NULL;
+#endif
+
+  init_object_mutex_once ();
+  __gthread_mutex_lock (&object_mutex);
+  registerObject(ob);
+
+  __gthread_mutex_unlock (&object_mutex);
+}
+
+void
+__register_frame_info (const void *begin, struct object *ob)
+{
+  __register_frame_info_bases (begin, ob, 0, 0);
+}
+
+void
+__register_frame (void *begin)
+{
+  struct object *ob;
+
+  /* If .eh_frame is empty, don't register at all.  */
+  if (*(uword *) begin == 0)
+    return;
+
+  ob = malloc (sizeof (struct object));
+  __register_frame_info (begin, ob);
+}
+
+/* Similar, but BEGIN is actually a pointer to a table of unwind entries
+   for different translation units.  Called from the file generated by
+   collect2.  */
+
+void
+__register_frame_info_table_bases (void *begin, struct object *ob,
+				   void *tbase, void *dbase)
+{
+  ob->pc_begin = (void *)-1;
+  ob->tbase = tbase;
+  ob->dbase = dbase;
+  ob->u.array = begin;
+  ob->s.i = 0;
+  ob->s.b.from_array = 1;
+  ob->s.b.encoding = DW_EH_PE_omit;
+
+  init_object_mutex_once ();
+  __gthread_mutex_lock (&object_mutex);
+
+ 
+  registerObject(ob);
+
+  __gthread_mutex_unlock (&object_mutex);
+}
+
+void
+__register_frame_info_table (void *begin, struct object *ob)
+{
+  __register_frame_info_table_bases (begin, ob, 0, 0);
+}
+
+void
+__register_frame_table (void *begin)
+{
+  struct object *ob = malloc (sizeof (struct object));
+  __register_frame_info_table (begin, ob);
+}
+
+/* Called from crtbegin.o to deregister the unwind info for an object.  */
+/* ??? Glibc has for a while now exported __register_frame_info and
+   __deregister_frame_info.  If we call __register_frame_info_bases
+   from crtbegin (wherein it is declared weak), and this object does
+   not get pulled from libgcc.a for other reasons, then the
+   invocation of __deregister_frame_info will be resolved from glibc.
+   Since the registration did not happen there, we'll abort.
+
+   Therefore, declare a new deregistration entry point that does the
+   exact same thing, but will resolve to the same library as
+   implements __register_frame_info_bases.  */
+
+void *
+__deregister_frame_info_bases (const void *begin)
+{
+  struct object **p;
+  struct object *ob = 0;
+
+  /* If .eh_frame is empty, we haven't registered.  */
+  if ((uword *) begin == 0 || *(uword *) begin == 0)
+    return ob;
+
+  init_object_mutex_once ();
+  __gthread_mutex_lock (&object_mutex);
+
+  
+  for (p = &seen_objects; *p ; p = &(*p)->next)
+    if ((*p)->s.b.sorted)
+      {
+	if ((*p)->u.sort->orig_data == begin)
+	  {
+	    ob = *p;
+	    *p = ob->next;
+	    free (ob->u.sort);
+	    goto out;
+	  }
+      }
+    else
+      {
+	if ((*p)->u.single == begin)
+	  {
+	    ob = *p;
+	    *p = ob->next;
+	    goto out;
+	  }
+      }
+
+ 
+  //now empty the cache!!!
+  //TODO 19 oct 2004 halldor: Do we want to clean up
+  // the two cache tables of entries belonging to this module?  
+  __gthread_mutex_unlock (&object_mutex);
+  abort ();
+
+ out:
+  __gthread_mutex_unlock (&object_mutex);
+  return (void *) ob;
+}
+
+void *
+__deregister_frame_info (const void *begin)
+{
+  return __deregister_frame_info_bases (begin);
+}
+
+void
+__deregister_frame (void *begin)
+{
+  /* If .eh_frame is empty, we haven't registered.  */
+  if (*(uword *) begin != 0)
+    free (__deregister_frame_info (begin));
+}
+
+
+/* Like base_of_encoded_value, but take the base from a struct object
+   instead of an _Unwind_Context.  */
+
+static _Unwind_Ptr
+base_from_object (unsigned char encoding, struct object *ob)
+{
+  if (encoding == DW_EH_PE_omit)
+    return 0;
+
+  switch (encoding & 0x70)
+    {
+    case DW_EH_PE_absptr:
+    case DW_EH_PE_pcrel:
+    case DW_EH_PE_aligned:
+      return 0;
+
+    case DW_EH_PE_textrel:
+      return (_Unwind_Ptr) ob->tbase;
+    case DW_EH_PE_datarel:
+      return (_Unwind_Ptr) ob->dbase;
+    }
+  abort ();
+}
+
+/* Return the FDE pointer encoding from the CIE.  */
+/* ??? This is a subset of extract_cie_info from unwind-dw2.c.  */
+
+static int
+get_cie_encoding (const struct dwarf_cie *cie)
+{
+  const unsigned char *aug, *p;
+  _Unwind_Ptr dummy;
+  _Unwind_Word utmp;
+  _Unwind_Sword stmp;
+
+  aug = cie->augmentation;
+  if (aug[0] != 'z')
+    return DW_EH_PE_absptr;
+
+  p = aug + strlen (aug) + 1;		/* Skip the augmentation string.  */
+  p = read_uleb128 (p, &utmp);		/* Skip code alignment.  */
+  p = read_sleb128 (p, &stmp);		/* Skip data alignment.  */
+  p++;					/* Skip return address column.  */
+
+  aug++;				/* Skip 'z' */
+  p = read_uleb128 (p, &utmp);		/* Skip augmentation length.  */
+  while (1)
+    {
+      /* This is what we're looking for.  */
+      if (*aug == 'R')
+	return *p;
+      /* Personality encoding and pointer.  */
+      else if (*aug == 'P')
+	{
+	  /* ??? Avoid dereferencing indirect pointers, since we're
+	     faking the base address.  Gotta keep DW_EH_PE_aligned
+	     intact, however.  */
+	  p = read_encoded_value_with_base (*p & 0x7F, 0, p + 1, &dummy);
+	}
+      /* LSDA encoding.  */
+      else if (*aug == 'L')
+	p++;
+      /* Otherwise end of string, or unknown augmentation.  */
+      else
+	return DW_EH_PE_absptr;
+      aug++;
+    }
+}
+
+static inline int
+get_fde_encoding (const struct dwarf_fde *f)
+{
+  return get_cie_encoding (get_cie (f));
+}
+
+
+/* Sorting an array of FDEs by address.
+   (Ideally we would have the linker sort the FDEs so we don't have to do
+   it at run time. But the linkers are not yet prepared for this.)  */
+
+/* Comparison routines.  Three variants of increasing complexity.  */
+
+static int
+fde_unencoded_compare (struct object *ob __attribute__((unused)),
+		       const fde *x, const fde *y)
+{
+  _Unwind_Ptr x_ptr = *(_Unwind_Ptr *) x->pc_begin;
+  _Unwind_Ptr y_ptr = *(_Unwind_Ptr *) y->pc_begin;
+
+  if (x_ptr > y_ptr)
+    return 1;
+  if (x_ptr < y_ptr)
+    return -1;
+  return 0;
+}
+
+static int
+fde_single_encoding_compare (struct object *ob, const fde *x, const fde *y)
+{
+  _Unwind_Ptr base, x_ptr, y_ptr;
+
+  base = base_from_object (ob->s.b.encoding, ob);
+  read_encoded_value_with_base (ob->s.b.encoding, base, x->pc_begin, &x_ptr);
+  read_encoded_value_with_base (ob->s.b.encoding, base, y->pc_begin, &y_ptr);
+
+  if (x_ptr > y_ptr)
+    return 1;
+  if (x_ptr < y_ptr)
+    return -1;
+  return 0;
+}
+
+static int
+fde_mixed_encoding_compare (struct object *ob, const fde *x, const fde *y)
+{
+  int x_encoding, y_encoding;
+  _Unwind_Ptr x_ptr, y_ptr;
+
+  x_encoding = get_fde_encoding (x);
+  read_encoded_value_with_base (x_encoding, base_from_object (x_encoding, ob),
+				x->pc_begin, &x_ptr);
+
+  y_encoding = get_fde_encoding (y);
+  read_encoded_value_with_base (y_encoding, base_from_object (y_encoding, ob),
+				y->pc_begin, &y_ptr);
+
+  if (x_ptr > y_ptr)
+    return 1;
+  if (x_ptr < y_ptr)
+    return -1;
+  return 0;
+}
+
+typedef int (*fde_compare_t) (struct object *, const fde *, const fde *);
+
+
+/* This is a special mix of insertion sort and heap sort, optimized for
+   the data sets that actually occur. They look like
+   101 102 103 127 128 105 108 110 190 111 115 119 125 160 126 129 130.
+   I.e. a linearly increasing sequence (coming from functions in the text
+   section), with additionally a few unordered elements (coming from functions
+   in gnu_linkonce sections) whose values are higher than the values in the
+   surrounding linear sequence (but not necessarily higher than the values
+   at the end of the linear sequence!).
+   The worst-case total run time is O(N) + O(n log (n)), where N is the
+   total number of FDEs and n is the number of erratic ones.  */
+
+struct fde_accumulator
+{
+  struct fde_vector *linear;
+  struct fde_vector *erratic;
+};
+
+static inline int
+start_fde_sort (struct fde_accumulator *accu, size_t count)
+{
+  size_t size;
+  if (! count)
+    return 0;
+
+  size = sizeof (struct fde_vector) + sizeof (const fde *) * count;
+  if ((accu->linear = malloc (size)))
+    {
+      accu->linear->count = 0;
+      if ((accu->erratic = malloc (size)))
+	accu->erratic->count = 0;
+      return 1;
+    }
+  else
+    return 0;
+}
+
+static inline void
+fde_insert (struct fde_accumulator *accu, const fde *this_fde)
+{
+  if (accu->linear)
+    accu->linear->array[accu->linear->count++] = this_fde;
+}
+
+/* Split LINEAR into a linear sequence with low values and an erratic
+   sequence with high values, put the linear one (of longest possible
+   length) into LINEAR and the erratic one into ERRATIC. This is O(N).
+
+   Because the longest linear sequence we are trying to locate within the
+   incoming LINEAR array can be interspersed with (high valued) erratic
+   entries.  We construct a chain indicating the sequenced entries.
+   To avoid having to allocate this chain, we overlay it onto the space of
+   the ERRATIC array during construction.  A final pass iterates over the
+   chain to determine what should be placed in the ERRATIC array, and
+   what is the linear sequence.  This overlay is safe from aliasing.  */
+
+static inline void
+fde_split (struct object *ob, fde_compare_t fde_compare,
+	   struct fde_vector *linear, struct fde_vector *erratic)
+{
+  static const fde *marker;
+  size_t count = linear->count;
+  const fde **chain_end = &marker;
+  size_t i, j, k;
+
+  /* This should optimize out, but it is wise to make sure this assumption
+     is correct. Should these have different sizes, we cannot cast between
+     them and the overlaying onto ERRATIC will not work.  */
+  if (sizeof (const fde *) != sizeof (const fde **))
+    abort ();
+
+  for (i = 0; i < count; i++)
+    {
+      const fde **probe;
+
+      for (probe = chain_end;
+	   probe != &marker && fde_compare (ob, linear->array[i], *probe) < 0;
+	   probe = chain_end)
+	{
+	  chain_end = (const fde **) erratic->array[probe - linear->array];
+	  erratic->array[probe - linear->array] = NULL;
+	}
+      erratic->array[i] = (const fde *) chain_end;
+      chain_end = &linear->array[i];
+    }
+
+  /* Each entry in LINEAR which is part of the linear sequence we have
+     discovered will correspond to a non-NULL entry in the chain we built in
+     the ERRATIC array.  */
+  for (i = j = k = 0; i < count; i++)
+    if (erratic->array[i])
+      linear->array[j++] = linear->array[i];
+    else
+      erratic->array[k++] = linear->array[i];
+  linear->count = j;
+  erratic->count = k;
+}
+
+#define SWAP(x,y) do { const fde * tmp = x; x = y; y = tmp; } while (0)
+
+/* Convert a semi-heap to a heap.  A semi-heap is a heap except possibly
+   for the first (root) node; push it down to its rightful place.  */
+
+static void
+frame_downheap (struct object *ob, fde_compare_t fde_compare, const fde **a,
+		int lo, int hi)
+{
+  int i, j;
+
+  for (i = lo, j = 2*i+1;
+       j < hi;
+       j = 2*i+1)
+    {
+      if (j+1 < hi && fde_compare (ob, a[j], a[j+1]) < 0)
+	++j;
+
+      if (fde_compare (ob, a[i], a[j]) < 0)
+	{
+	  SWAP (a[i], a[j]);
+	  i = j;
+	}
+      else
+	break;
+    }
+}
+
+/* This is O(n log(n)).  BSD/OS defines heapsort in stdlib.h, so we must
+   use a name that does not conflict.  */
+
+static void
+frame_heapsort (struct object *ob, fde_compare_t fde_compare,
+		struct fde_vector *erratic)
+{
+  /* For a description of this algorithm, see:
+     Samuel P. Harbison, Guy L. Steele Jr.: C, a reference manual, 2nd ed.,
+     p. 60-61.  */
+  const fde ** a = erratic->array;
+  /* A portion of the array is called a "heap" if for all i>=0:
+     If i and 2i+1 are valid indices, then a[i] >= a[2i+1].
+     If i and 2i+2 are valid indices, then a[i] >= a[2i+2].  */
+  size_t n = erratic->count;
+  int m;
+
+  /* Expand our heap incrementally from the end of the array, heapifying
+     each resulting semi-heap as we go.  After each step, a[m] is the top
+     of a heap.  */
+  for (m = n/2-1; m >= 0; --m)
+    frame_downheap (ob, fde_compare, a, m, n);
+
+  /* Shrink our heap incrementally from the end of the array, first
+     swapping out the largest element a[0] and then re-heapifying the
+     resulting semi-heap.  After each step, a[0..m) is a heap.  */
+  for (m = n-1; m >= 1; --m)
+    {
+      SWAP (a[0], a[m]);
+      frame_downheap (ob, fde_compare, a, 0, m);
+    }
+#undef SWAP
+}
+
+/* Merge V1 and V2, both sorted, and put the result into V1.  */
+static inline void
+fde_merge (struct object *ob, fde_compare_t fde_compare,
+	   struct fde_vector *v1, struct fde_vector *v2)
+{
+  size_t i1, i2;
+  const fde * fde2;
+
+  i2 = v2->count;
+  if (i2 > 0)
+    {
+      i1 = v1->count;
+      do
+	{
+	  i2--;
+	  fde2 = v2->array[i2];
+	  while (i1 > 0 && fde_compare (ob, v1->array[i1-1], fde2) > 0)
+	    {
+	      v1->array[i1+i2] = v1->array[i1-1];
+	      i1--;
+	    }
+	  v1->array[i1+i2] = fde2;
+	}
+      while (i2 > 0);
+      v1->count += v2->count;
+    }
+}
+
+static inline void
+end_fde_sort (struct object *ob, struct fde_accumulator *accu, size_t count)
+{
+  fde_compare_t fde_compare;
+
+  if (accu->linear && accu->linear->count != count)
+    abort ();
+
+  if (ob->s.b.mixed_encoding)
+    fde_compare = fde_mixed_encoding_compare;
+  else if (ob->s.b.encoding == DW_EH_PE_absptr)
+    fde_compare = fde_unencoded_compare;
+  else
+    fde_compare = fde_single_encoding_compare;
+
+  if (accu->erratic)
+    {
+      fde_split (ob, fde_compare, accu->linear, accu->erratic);
+      if (accu->linear->count + accu->erratic->count != count)
+	abort ();
+      frame_heapsort (ob, fde_compare, accu->erratic);
+      fde_merge (ob, fde_compare, accu->linear, accu->erratic);
+      free (accu->erratic);
+    }
+  else
+    {
+      /* We've not managed to malloc an erratic array,
+	 so heap sort in the linear one.  */
+      frame_heapsort (ob, fde_compare, accu->linear);
+    }
+}
+
+
+/* Update encoding, mixed_encoding, and pc_begin for OB for the
+   fde array beginning at THIS_FDE.  Return the number of fdes
+   encountered along the way.  */
+
+static size_t
+classify_object_over_fdes (struct object *ob, const fde *this_fde)
+{
+  const struct dwarf_cie *last_cie = 0;
+  size_t count = 0;
+  int encoding = DW_EH_PE_absptr;
+  _Unwind_Ptr base = 0;
+
+  for (; ! last_fde (ob, this_fde); this_fde = next_fde (this_fde))
+    {
+      const struct dwarf_cie *this_cie;
+      _Unwind_Ptr mask, pc_begin;
+
+      /* Skip CIEs.  */
+      if (this_fde->CIE_delta == 0)
+	continue;
+
+      /* Determine the encoding for this FDE.  Note mixed encoded
+	 objects for later.  */
+      this_cie = get_cie (this_fde);
+      if (this_cie != last_cie)
+	{
+	  last_cie = this_cie;
+	  encoding = get_cie_encoding (this_cie);
+	  base = base_from_object (encoding, ob);
+	  if (ob->s.b.encoding == DW_EH_PE_omit)
+	    ob->s.b.encoding = encoding;
+	  else if (ob->s.b.encoding != encoding)
+	    ob->s.b.mixed_encoding = 1;
+	}
+
+      read_encoded_value_with_base (encoding, base, this_fde->pc_begin,
+				    &pc_begin);
+
+      /* Take care to ignore link-once functions that were removed.
+	 In these cases, the function address will be NULL, but if
+	 the encoding is smaller than a pointer a true NULL may not
+	 be representable.  Assume 0 in the representable bits is NULL.  */
+      mask = size_of_encoded_value (encoding);
+      if (mask < sizeof (void *))
+	mask = (1L << (mask << 3)) - 1;
+      else
+	mask = -1;
+
+      if ((pc_begin & mask) == 0)
+	continue;
+
+      count += 1;
+      if ((void *) pc_begin < ob->pc_begin)
+	ob->pc_begin = (void *) pc_begin;
+    }
+
+  return count;
+}
+
+static void
+add_fdes (struct object *ob, struct fde_accumulator *accu, const fde *this_fde)
+{
+  const struct dwarf_cie *last_cie = 0;
+  int encoding = ob->s.b.encoding;
+  _Unwind_Ptr base = base_from_object (ob->s.b.encoding, ob);
+
+  for (; ! last_fde (ob, this_fde); this_fde = next_fde (this_fde))
+    {
+      const struct dwarf_cie *this_cie;
+
+      /* Skip CIEs.  */
+      if (this_fde->CIE_delta == 0)
+	continue;
+
+      if (ob->s.b.mixed_encoding)
+	{
+	  /* Determine the encoding for this FDE.  Note mixed encoded
+	     objects for later.  */
+	  this_cie = get_cie (this_fde);
+	  if (this_cie != last_cie)
+	    {
+	      last_cie = this_cie;
+	      encoding = get_cie_encoding (this_cie);
+	      base = base_from_object (encoding, ob);
+	    }
+	}
+
+      if (encoding == DW_EH_PE_absptr)
+	{
+	  if (*(_Unwind_Ptr *) this_fde->pc_begin == 0)
+	    continue;
+	}
+      else
+	{
+	  _Unwind_Ptr pc_begin, mask;
+
+	  read_encoded_value_with_base (encoding, base, this_fde->pc_begin,
+					&pc_begin);
+
+	  /* Take care to ignore link-once functions that were removed.
+	     In these cases, the function address will be NULL, but if
+	     the encoding is smaller than a pointer a true NULL may not
+	     be representable.  Assume 0 in the representable bits is NULL.  */
+	  mask = size_of_encoded_value (encoding);
+	  if (mask < sizeof (void *))
+	    mask = (1L << (mask << 3)) - 1;
+	  else
+	    mask = -1;
+
+	  if ((pc_begin & mask) == 0)
+	    continue;
+	}
+
+      fde_insert (accu, this_fde);
+    }
+}
+
+/* Set up a sorted array of pointers to FDEs for a loaded object.  We
+   count up the entries before allocating the array because it's likely to
+   be faster.  We can be called multiple times, should we have failed to
+   allocate a sorted fde array on a previous occasion.  */
+
+static inline void
+init_object (struct object* ob)
+{
+  struct fde_accumulator accu;
+  size_t count;
+
+  count = ob->s.b.count;
+  if (count == 0)
+    {
+      if (ob->s.b.from_array)
+	{
+	  fde **p = ob->u.array;
+	  for (count = 0; *p; ++p)
+	    count += classify_object_over_fdes (ob, *p);
+	}
+      else
+	count = classify_object_over_fdes (ob, ob->u.single);
+
+      /* The count field we have in the main struct object is somewhat
+	 limited, but should suffice for virtually all cases.  If the
+	 counted value doesn't fit, re-write a zero.  The worst that
+	 happens is that we re-count next time -- admittedly non-trivial
+	 in that this implies some 2M fdes, but at least we function.  */
+      ob->s.b.count = count;
+      if (ob->s.b.count != count)
+	ob->s.b.count = 0;
+    }
+
+  if (!start_fde_sort (&accu, count))
+    return;
+
+  if (ob->s.b.from_array)
+    {
+      fde **p;
+      for (p = ob->u.array; *p; ++p)
+	add_fdes (ob, &accu, *p);
+    }
+  else
+    add_fdes (ob, &accu, ob->u.single);
+
+  end_fde_sort (ob, &accu, count);
+
+  /* Save the original fde pointer, since this is the key by which the
+     DSO will deregister the object.  */
+  accu.linear->orig_data = ob->u.single;
+  ob->u.sort = accu.linear;
+
+  ob->s.b.sorted = 1;
+}
+
+/* A linear search through a set of FDEs for the given PC.  This is
+   used when there was insufficient memory to allocate and sort an
+   array.  */
+
+static const fde *
+linear_search_fdes (struct object *ob, const fde *this_fde, void *pc)
+{
+  const struct dwarf_cie *last_cie = 0;
+  int encoding = ob->s.b.encoding;
+  _Unwind_Ptr base = base_from_object (ob->s.b.encoding, ob);
+
+  for (; ! last_fde (ob, this_fde); this_fde = next_fde (this_fde))
+    {
+      const struct dwarf_cie *this_cie;
+      _Unwind_Ptr pc_begin, pc_range;
+
+      /* Skip CIEs.  */
+      if (this_fde->CIE_delta == 0)
+	continue;
+
+      if (ob->s.b.mixed_encoding)
+	{
+	  /* Determine the encoding for this FDE.  Note mixed encoded
+	     objects for later.  */
+	  this_cie = get_cie (this_fde);
+	  if (this_cie != last_cie)
+	    {
+	      last_cie = this_cie;
+	      encoding = get_cie_encoding (this_cie);
+	      base = base_from_object (encoding, ob);
+	    }
+	}
+
+      if (encoding == DW_EH_PE_absptr)
+	{
+	  pc_begin = ((_Unwind_Ptr *) this_fde->pc_begin)[0];
+	  pc_range = ((_Unwind_Ptr *) this_fde->pc_begin)[1];
+	  if (pc_begin == 0)
+	    continue;
+	}
+      else
+	{
+	  _Unwind_Ptr mask;
+	  const char *p;
+
+	  p = read_encoded_value_with_base (encoding, base,
+					    this_fde->pc_begin, &pc_begin);
+	  read_encoded_value_with_base (encoding & 0x0F, 0, p, &pc_range);
+
+	  /* Take care to ignore link-once functions that were removed.
+	     In these cases, the function address will be NULL, but if
+	     the encoding is smaller than a pointer a true NULL may not
+	     be representable.  Assume 0 in the representable bits is NULL.  */
+	  mask = size_of_encoded_value (encoding);
+	  if (mask < sizeof (void *))
+	    mask = (1L << (mask << 3)) - 1;
+	  else
+	    mask = -1;
+
+	  if ((pc_begin & mask) == 0)
+	    continue;
+	}
+
+      if ((_Unwind_Ptr) pc - pc_begin < pc_range)
+	return this_fde;
+    }
+
+  return NULL;
+}
+
+/* Binary search for an FDE containing the given PC.  Here are three
+   implementations of increasing complexity.  */
+
+static inline const fde *
+binary_search_unencoded_fdes (struct object *ob, void *pc)
+{
+  struct fde_vector *vec = ob->u.sort;
+  size_t lo, hi;
+
+  for (lo = 0, hi = vec->count; lo < hi; )
+    {
+      size_t i = (lo + hi) / 2;
+      const fde *f = vec->array[i];
+      void *pc_begin;
+      uaddr pc_range;
+
+      pc_begin = ((void **) f->pc_begin)[0];
+      pc_range = ((uaddr *) f->pc_begin)[1];
+
+      if (pc < pc_begin)
+	hi = i;
+      else if (pc >= pc_begin + pc_range)
+	lo = i + 1;
+      else
+	return f;
+    }
+
+  return NULL;
+}
+
+static inline const fde *
+binary_search_single_encoding_fdes (struct object *ob, void *pc)
+{
+  struct fde_vector *vec = ob->u.sort;
+  int encoding = ob->s.b.encoding;
+  _Unwind_Ptr base = base_from_object (encoding, ob);
+  size_t lo, hi;
+
+  for (lo = 0, hi = vec->count; lo < hi; )
+    {
+      size_t i = (lo + hi) / 2;
+      const fde *f = vec->array[i];
+      _Unwind_Ptr pc_begin, pc_range;
+      const char *p;
+
+      p = read_encoded_value_with_base (encoding, base, f->pc_begin,
+					&pc_begin);
+      read_encoded_value_with_base (encoding & 0x0F, 0, p, &pc_range);
+
+      if ((_Unwind_Ptr) pc < pc_begin)
+	hi = i;
+      else if ((_Unwind_Ptr) pc >= pc_begin + pc_range)
+	lo = i + 1;
+      else
+	return f;
+    }
+
+  return NULL;
+}
+
+static inline const fde *
+binary_search_mixed_encoding_fdes (struct object *ob, void *pc)
+{
+  struct fde_vector *vec = ob->u.sort;
+  size_t lo, hi;
+
+  for (lo = 0, hi = vec->count; lo < hi; )
+    {
+      size_t i = (lo + hi) / 2;
+      const fde *f = vec->array[i];
+      _Unwind_Ptr pc_begin, pc_range;
+      const char *p;
+      int encoding;
+
+      encoding = get_fde_encoding (f);
+      p = read_encoded_value_with_base (encoding,
+					base_from_object (encoding, ob),
+					f->pc_begin, &pc_begin);
+      read_encoded_value_with_base (encoding & 0x0F, 0, p, &pc_range);
+
+      if ((_Unwind_Ptr) pc < pc_begin)
+	hi = i;
+      else if ((_Unwind_Ptr) pc >= pc_begin + pc_range)
+	lo = i + 1;
+      else
+	return f;
+    }
+
+  return NULL;
+}
+
+static const fde *
+search_object (struct object* ob, void *pc)
+{
+  /* If the data hasn't been sorted, try to do this now.  We may have
+     more memory available than last time we tried.  */
+  if (! ob->s.b.sorted)
+    {
+      init_object (ob);
+
+      /* Despite the above comment, the normal reason to get here is
+	 that we've not processed this object before.  A quick range
+	 check is in order.  */
+      if (pc < ob->pc_begin)
+	return NULL;
+    }
+
+  if (ob->s.b.sorted)
+    {
+      if (ob->s.b.mixed_encoding)
+	return binary_search_mixed_encoding_fdes (ob, pc);
+      else if (ob->s.b.encoding == DW_EH_PE_absptr)
+	return binary_search_unencoded_fdes (ob, pc);
+      else
+	return binary_search_single_encoding_fdes (ob, pc);
+    }
+  else
+    {
+      /* Long slow labourious linear search, cos we've no memory.  */
+      if (ob->s.b.from_array)
+	{
+	  fde **p;
+	  for (p = ob->u.array; *p ; p++)
+	    {
+	      const fde *f = linear_search_fdes (ob, *p, pc);
+	      if (f)
+		return f;
+	    }
+	  return NULL;
+	}
+      else
+	return linear_search_fdes (ob, ob->u.single, pc);
+    }
+}
+
+
+#include <linux/customhash.h>
+
+struct fde_cache {
+        struct fde_cache **pprev_fde_cache_hash;
+        struct fde_cache *next_fde_cache_hash;
+        int pc;
+        struct fde *fde;
+        struct object *ob;
+};
+
+ HASH(fde_cache, struct fde_cache, 8,
+ (fde_cache->pc== pc),
+ (pc),
+ (fde_cache->pc),
+ int pc)
+ 
+
+
+const fde *
+_Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)
+{
+  struct object *ob;
+  const fde *f = NULL;
+  
+
+ struct fde_cache* cached_fde=0;//our cached info!
+ init_object_mutex_once ();
+ __gthread_mutex_lock (&object_mutex);
+
+
+ //Try to find the FDE in our cache!
+   cached_fde = hash_find_fde_cache((int) pc);
+   //printk("Count: %u, cachedfde: %x\n",cou,cached_fde);
+   if(cached_fde!=0)
+   {
+   	   f=cached_fde->fde;
+   	   ob = cached_fde->ob;
+	   //printk("Chached fde: %x\n",f);
+	   //printk("Cached Object: %x\n",ob);
+   	   goto fini;
+   }
+
+
+  /* Linear search through the classified objects, to find the one
+     containing the pc.  Note that pc_begin is sorted descending, and
+     we expect objects to be non-overlapping.  */
+  for (ob = seen_objects; ob; ob = ob->next)
+    if (pc >= ob->pc_begin)
+      {
+	f = search_object (ob, pc);
+	if (f)
+	{
+
+   //Need to update the cache!
+       cached_fde = malloc (sizeof (struct fde_cache));
+       cached_fde->pc = (int) pc;
+       cached_fde->fde=f;
+       cached_fde->ob=ob;
+       hash_init_fde_cache(cached_fde);
+       hash_add_fde_cache(cached_fde);       
+
+	
+	  goto fini;
+
+      }	
+
+   }
+
+
+ fini:
+     __gthread_mutex_unlock (&object_mutex);
+
+  if (f)
+    {
+      int encoding;
+
+      bases->tbase = ob->tbase;
+      bases->dbase = ob->dbase;
+
+      encoding = ob->s.b.encoding;
+      if (ob->s.b.mixed_encoding)
+	encoding = get_fde_encoding (f);
+      read_encoded_value_with_base (encoding, base_from_object (encoding, ob),
+				    f->pc_begin, (_Unwind_Ptr *)&bases->func);
+    }
+  return f;
+}
+
+
+void registerObjectHelper(struct object * ob)
+{
+ 	struct object **p;
+     
+   init_object (ob);
+   /* Insert the object into the classified list.  */
+   for (p = &seen_objects; *p ; p = &(*p)->next)
+   {
+     if ((*p)->pc_begin < ob->pc_begin)
+      break;
+   }
+   ob->next = *p;
+   *p = ob;
+}
+static struct object * kernelOb = 0;  
+void registerObject(struct object * ob)
+{ 
+	//slight twitch for UML to register the kernel objects
+	//when kmalloc has started to work!
+	if(kernelOb==0)
+	{
+		kernelOb = ob;
+		return;
+	}
+	if(seen_objects==0)
+	{
+	   	registerObjectHelper(kernelOb);
+	}
+	registerObjectHelper(ob); 
+	
+	
+   
+}
+
diff -urN linux-2.6.9_orig/lib/gcc/unwind-dw2-fde.h linux-2.6.9/lib/gcc/unwind-dw2-fde.h
--- linux-2.6.9_orig/lib/gcc/unwind-dw2-fde.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/unwind-dw2-fde.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,180 @@
+/* Subroutines needed for unwinding stack frames for exception handling.  */
+/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2004
+   Free Software Foundation, Inc.
+   Contributed by Jason Merrill <jason@cygnus.com>.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 2, or (at your option) any later
+version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+02111-1307, USA.  */
+
+#ifndef GCC_UNWIND_DW2_FDE_H
+#define GCC_UNWIND_DW2_FDE_H
+
+struct fde_vector
+{
+  const void *orig_data;
+  size_t count;
+  const struct dwarf_fde *array[];
+};
+
+struct object
+{
+  void *pc_begin;
+  void *tbase;
+  void *dbase;
+  union {
+    const struct dwarf_fde *single;
+    struct dwarf_fde **array;
+    struct fde_vector *sort;
+  } u;
+
+  union {
+    struct {
+      unsigned long sorted : 1;
+      unsigned long from_array : 1;
+      unsigned long mixed_encoding : 1;
+      unsigned long encoding : 8;
+      /* ??? Wish there was an easy way to detect a 64-bit host here;
+	 we've got 32 bits left to play with...  */
+      unsigned long count : 21;
+    } b;
+    size_t i;
+  } s;
+
+#ifdef DWARF2_OBJECT_END_PTR_EXTENSION
+  char *fde_end;
+#endif
+
+  struct object *next;
+};
+
+/* This is the original definition of struct object.  While the struct
+   itself was opaque to users, they did know how large it was, and
+   allocate one statically in crtbegin for each DSO.  Keep this around
+   so that we're aware of the static size limitations for the new struct.  */
+struct old_object
+{
+  void *pc_begin;
+  void *pc_end;
+  struct dwarf_fde *fde_begin;
+  struct dwarf_fde **fde_array;
+  size_t count;
+  struct old_object *next;
+};
+
+struct dwarf_eh_bases
+{
+  void *tbase;
+  void *dbase;
+  void *func;
+};
+
+
+extern void __register_frame_info_bases (const void *, struct object *,
+					 void *, void *);
+extern void __register_frame_info (const void *, struct object *);
+extern void __register_frame (void *);
+extern void __register_frame_info_table_bases (void *, struct object *,
+					       void *, void *);
+extern void __register_frame_info_table (void *, struct object *);
+extern void __register_frame_table (void *);
+extern void *__deregister_frame_info (const void *);
+extern void *__deregister_frame_info_bases (const void *);
+extern void __deregister_frame (void *);
+
+
+typedef          int  sword __attribute__ ((mode (SI)));
+typedef unsigned int  uword __attribute__ ((mode (SI)));
+typedef unsigned int  uaddr __attribute__ ((mode (pointer)));
+typedef          int  saddr __attribute__ ((mode (pointer)));
+typedef unsigned char ubyte;
+
+/* Terminology:
+   CIE - Common Information Element
+   FDE - Frame Descriptor Element
+
+   There is one per function, and it describes where the function code
+   is located, and what the register lifetimes and stack layout are
+   within the function.
+
+   The data structures are defined in the DWARF specification, although
+   not in a very readable way (see LITERATURE).
+
+   Every time an exception is thrown, the code needs to locate the FDE
+   for the current function, and starts to look for exception regions
+   from that FDE. This works in a two-level search:
+   a) in a linear search, find the shared image (i.e. DLL) containing
+      the PC
+   b) using the FDE table for that shared object, locate the FDE using
+      binary search (which requires the sorting).  */
+
+/* The first few fields of a CIE.  The CIE_id field is 0 for a CIE,
+   to distinguish it from a valid FDE.  FDEs are aligned to an addressing
+   unit boundary, but the fields within are unaligned.  */
+struct dwarf_cie
+{
+  uword length;
+  sword CIE_id;
+  ubyte version;
+  unsigned char augmentation[];
+} __attribute__ ((packed, aligned (__alignof__ (void *))));
+
+/* The first few fields of an FDE.  */
+struct dwarf_fde
+{
+  uword length;
+  sword CIE_delta;
+  unsigned char pc_begin[];
+} __attribute__ ((packed, aligned (__alignof__ (void *))));
+
+typedef struct dwarf_fde fde;
+
+/* Locate the CIE for a given FDE.  */
+
+static inline const struct dwarf_cie *
+get_cie (const struct dwarf_fde *f)
+{
+  return (void *)&f->CIE_delta - f->CIE_delta;
+}
+
+static inline const fde *
+next_fde (const fde *f)
+{
+  return (const fde *) ((char *) f + f->length + sizeof (f->length));
+}
+
+extern const fde * _Unwind_Find_FDE (void *, struct dwarf_eh_bases *);
+
+static inline int
+last_fde (struct object *obj __attribute__ ((__unused__)), const fde *f)
+{
+#ifdef DWARF2_OBJECT_END_PTR_EXTENSION
+  return (char *)f == obj->fde_end || f->length == 0;
+#else
+  return f->length == 0;
+#endif
+}
+
+#endif /* unwind-dw2-fde.h */
diff -urN linux-2.6.9_orig/lib/gcc/unwind-pe.h linux-2.6.9/lib/gcc/unwind-pe.h
--- linux-2.6.9_orig/lib/gcc/unwind-pe.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/gcc/unwind-pe.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,291 @@
+/* Exception handling and frame unwind runtime interface routines.
+   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   In addition to the permissions in the GNU General Public License, the
+   Free Software Foundation gives you unlimited permission to link the
+   compiled version of this file into combinations with other programs,
+   and to distribute those combinations without any restriction coming
+   from the use of this file.  (The General Public License restrictions
+   do apply in other respects; for example, they cover modification of
+   the file, and distribution when not linked into a combined
+   executable.)
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+/* @@@ Really this should be out of line, but this also causes link
+   compatibility problems with the base ABI.  This is slightly better
+   than duplicating code, however.  */
+
+#ifndef GCC_UNWIND_PE_H
+#define GCC_UNWIND_PE_H
+
+/* If using C++, references to abort have to be qualified with std::.  */
+#if __cplusplus
+#define __gxx_abort std::abort
+#else
+#define __gxx_abort abort
+#endif
+
+/* Pointer encodings, from dwarf2.h.  */
+#define DW_EH_PE_absptr         0x00
+#define DW_EH_PE_omit           0xff
+
+#define DW_EH_PE_uleb128        0x01
+#define DW_EH_PE_udata2         0x02
+#define DW_EH_PE_udata4         0x03
+#define DW_EH_PE_udata8         0x04
+#define DW_EH_PE_sleb128        0x09
+#define DW_EH_PE_sdata2         0x0A
+#define DW_EH_PE_sdata4         0x0B
+#define DW_EH_PE_sdata8         0x0C
+#define DW_EH_PE_signed         0x08
+
+#define DW_EH_PE_pcrel          0x10
+#define DW_EH_PE_textrel        0x20
+#define DW_EH_PE_datarel        0x30
+#define DW_EH_PE_funcrel        0x40
+#define DW_EH_PE_aligned        0x50
+
+#define DW_EH_PE_indirect	0x80
+
+
+#ifndef NO_SIZE_OF_ENCODED_VALUE
+
+/* Given an encoding, return the number of bytes the format occupies.
+   This is only defined for fixed-size encodings, and so does not
+   include leb128.  */
+
+static unsigned int
+size_of_encoded_value (unsigned char encoding)
+{
+  if (encoding == DW_EH_PE_omit)
+    return 0;
+
+  switch (encoding & 0x07)
+    {
+    case DW_EH_PE_absptr:
+      return sizeof (void *);
+    case DW_EH_PE_udata2:
+      return 2;
+    case DW_EH_PE_udata4:
+      return 4;
+    case DW_EH_PE_udata8:
+      return 8;
+    }
+  __gxx_abort ();
+}
+
+#endif
+
+#ifndef NO_BASE_OF_ENCODED_VALUE
+
+/* Given an encoding and an _Unwind_Context, return the base to which
+   the encoding is relative.  This base may then be passed to
+   read_encoded_value_with_base for use when the _Unwind_Context is
+   not available.  */
+
+static _Unwind_Ptr
+base_of_encoded_value (unsigned char encoding, struct _Unwind_Context *context)
+{
+  if (encoding == DW_EH_PE_omit)
+    return 0;
+
+  switch (encoding & 0x70)
+    {
+    case DW_EH_PE_absptr:
+    case DW_EH_PE_pcrel:
+    case DW_EH_PE_aligned:
+      return 0;
+
+    case DW_EH_PE_textrel:
+      return _Unwind_GetTextRelBase (context);
+    case DW_EH_PE_datarel:
+      return _Unwind_GetDataRelBase (context);
+    case DW_EH_PE_funcrel:
+      return _Unwind_GetRegionStart (context);
+    }
+  __gxx_abort ();
+}
+
+#endif
+
+/* Read an unsigned leb128 value from P, store the value in VAL, return
+   P incremented past the value.  We assume that a word is large enough to
+   hold any value so encoded; if it is smaller than a pointer on some target,
+   pointers should not be leb128 encoded on that target.  */
+
+static const unsigned char *
+read_uleb128 (const unsigned char *p, _Unwind_Word *val)
+{
+  unsigned int shift = 0;
+  unsigned char byte;
+  _Unwind_Word result;
+
+  result = 0;
+  do
+    {
+      byte = *p++;
+      result |= ((_Unwind_Word)byte & 0x7f) << shift;
+      shift += 7;
+    }
+  while (byte & 0x80);
+
+  *val = result;
+  return p;
+}
+
+/* Similar, but read a signed leb128 value.  */
+
+static const unsigned char *
+read_sleb128 (const unsigned char *p, _Unwind_Sword *val)
+{
+  unsigned int shift = 0;
+  unsigned char byte;
+  _Unwind_Word result;
+
+  result = 0;
+  do
+    {
+      byte = *p++;
+      result |= ((_Unwind_Word)byte & 0x7f) << shift;
+      shift += 7;
+    }
+  while (byte & 0x80);
+
+  /* Sign-extend a negative value.  */
+  if (shift < 8 * sizeof(result) && (byte & 0x40) != 0)
+    result |= -(((_Unwind_Word)1L) << shift);
+
+  *val = (_Unwind_Sword) result;
+  return p;
+}
+
+/* Load an encoded value from memory at P.  The value is returned in VAL;
+   The function returns P incremented past the value.  BASE is as given
+   by base_of_encoded_value for this encoding in the appropriate context.  */
+
+static const unsigned char *
+read_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,
+			      const unsigned char *p, _Unwind_Ptr *val)
+{
+  union unaligned
+    {
+      void *ptr;
+      unsigned u2 __attribute__ ((mode (HI)));
+      unsigned u4 __attribute__ ((mode (SI)));
+      unsigned u8 __attribute__ ((mode (DI)));
+      signed s2 __attribute__ ((mode (HI)));
+      signed s4 __attribute__ ((mode (SI)));
+      signed s8 __attribute__ ((mode (DI)));
+    } __attribute__((__packed__));
+
+  const union unaligned *u = (const union unaligned *) p;
+  _Unwind_Internal_Ptr result;
+
+  if (encoding == DW_EH_PE_aligned)
+    {
+      _Unwind_Internal_Ptr a = (_Unwind_Internal_Ptr) p;
+      a = (a + sizeof (void *) - 1) & - sizeof(void *);
+      result = *(_Unwind_Internal_Ptr *) a;
+      p = (const unsigned char *) (_Unwind_Internal_Ptr) (a + sizeof (void *));
+    }
+  else
+    {
+      switch (encoding & 0x0f)
+	{
+	case DW_EH_PE_absptr:
+	  result = (_Unwind_Internal_Ptr) u->ptr;
+	  p += sizeof (void *);
+	  break;
+
+	case DW_EH_PE_uleb128:
+	  {
+	    _Unwind_Word tmp;
+	    p = read_uleb128 (p, &tmp);
+	    result = (_Unwind_Internal_Ptr) tmp;
+	  }
+	  break;
+
+	case DW_EH_PE_sleb128:
+	  {
+	    _Unwind_Sword tmp;
+	    p = read_sleb128 (p, &tmp);
+	    result = (_Unwind_Internal_Ptr) tmp;
+	  }
+	  break;
+
+	case DW_EH_PE_udata2:
+	  result = u->u2;
+	  p += 2;
+	  break;
+	case DW_EH_PE_udata4:
+	  result = u->u4;
+	  p += 4;
+	  break;
+	case DW_EH_PE_udata8:
+	  result = u->u8;
+	  p += 8;
+	  break;
+
+	case DW_EH_PE_sdata2:
+	  result = u->s2;
+	  p += 2;
+	  break;
+	case DW_EH_PE_sdata4:
+	  result = u->s4;
+	  p += 4;
+	  break;
+	case DW_EH_PE_sdata8:
+	  result = u->s8;
+	  p += 8;
+	  break;
+
+	default:
+	  __gxx_abort ();
+	}
+
+      if (result != 0)
+	{
+	  result += ((encoding & 0x70) == DW_EH_PE_pcrel
+		     ? (_Unwind_Internal_Ptr) u : base);
+	  if (encoding & DW_EH_PE_indirect)
+	    result = *(_Unwind_Internal_Ptr *) result;
+	}
+    }
+
+  *val = result;
+  return p;
+}
+
+#ifndef NO_BASE_OF_ENCODED_VALUE
+
+/* Like read_encoded_value_with_base, but get the base from the context
+   rather than providing it directly.  */
+
+static inline const unsigned char *
+read_encoded_value (struct _Unwind_Context *context, unsigned char encoding,
+		    const unsigned char *p, _Unwind_Ptr *val)
+{
+  return read_encoded_value_with_base (encoding,
+		base_of_encoded_value (encoding, context),
+		p, val);
+}
+
+#endif
+
+#endif /* unwind-pe.h */
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/cxxabi.h linux-2.6.9/lib/libstdc++-v3/libsupc++/cxxabi.h
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/cxxabi.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/cxxabi.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,558 @@
+// new abi support -*- C++ -*-
+  
+// Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+// 
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+// Written by Nathan Sidwell, Codesourcery LLC, <nathan@codesourcery.com>
+ 
+/* This file declares the new abi entry points into the runtime. It is not
+   normally necessary for user programs to include this header, or use the
+   entry points directly. However, this header is available should that be
+   needed.
+   
+   Some of the entry points are intended for both C and C++, thus this header
+   is includable from both C and C++. Though the C++ specific parts are not
+   available in C, naturally enough.  */
+
+#ifndef _CXXABI_H
+#define _CXXABI_H 1
+
+#ifdef __cplusplus
+
+// We use the compiler builtins __SIZE_TYPE__ and __PTRDIFF_TYPE__ instead of
+// std::size_t and std::ptrdiff_t respectively. This makes us independent of
+// the conformance level of <cstddef> and whether -fhonor-std was supplied.
+// <cstddef> is not currently available during compiler building anyway.
+// Including <stddef.h> would be wrong, as that would rudely place size_t in
+// the global namespace.
+
+#include <typeinfo>
+
+namespace __cxxabiv1
+{
+
+/* type information for int, float etc */
+class __fundamental_type_info
+  : public std::type_info
+{
+public:
+  virtual ~__fundamental_type_info ();
+public:
+  explicit __fundamental_type_info (const char *__n)
+    : std::type_info (__n)
+    { }
+};
+
+/* type information for array objects */
+class __array_type_info
+  : public std::type_info
+{
+/* abi defined member functions */
+protected:
+  virtual ~__array_type_info ();
+public:
+  explicit __array_type_info (const char *__n)
+    : std::type_info (__n)
+    { }
+};
+
+/* type information for functions (both member and non-member) */
+class __function_type_info
+  : public std::type_info
+{
+/* abi defined member functions */
+public:
+  virtual ~__function_type_info ();
+public:
+  explicit __function_type_info (const char *__n)
+    : std::type_info (__n)
+    { }
+  
+/* implementation defined member functions */
+protected:
+  virtual bool __is_function_p () const;
+};
+
+/* type information for enumerations */
+class __enum_type_info
+  : public std::type_info
+{
+/* abi defined member functions */
+public:
+  virtual ~__enum_type_info ();
+public:
+  explicit __enum_type_info (const char *__n)
+    : std::type_info (__n)
+    { }
+};
+
+/* common type information for simple pointers and pointers to member */
+class __pbase_type_info
+  : public std::type_info
+{
+/* abi defined member variables */
+public:
+  unsigned int __flags; /* qualification of the target object */
+  const std::type_info *__pointee;   /* type of pointed to object */
+
+/* abi defined member functions */
+public:
+  virtual ~__pbase_type_info ();
+public:
+  explicit __pbase_type_info (const char *__n,
+                                int __quals,
+                                const std::type_info *__type)
+    : std::type_info (__n), __flags (__quals), __pointee (__type)
+    { }
+
+/* implementation defined types */
+public:
+  enum __masks {
+    __const_mask = 0x1,
+    __volatile_mask = 0x2,
+    __restrict_mask = 0x4,
+    __incomplete_mask = 0x8,
+    __incomplete_class_mask = 0x10
+  };
+
+/* implementation defined member functions */
+protected:
+  virtual bool __do_catch (const std::type_info *__thr_type,
+                           void **__thr_obj,
+                           unsigned __outer) const;
+protected:
+  inline virtual bool __pointer_catch (const __pbase_type_info *__thr_type,
+                                       void **__thr_obj,
+                                       unsigned __outer) const;
+};
+
+/* type information for simple pointers */
+class __pointer_type_info
+  : public __pbase_type_info
+{
+/* abi defined member functions */
+public:
+  virtual ~__pointer_type_info ();
+public:
+  explicit __pointer_type_info (const char *__n,
+                                int __quals,
+                                const std::type_info *__type)
+    : __pbase_type_info (__n, __quals, __type)
+    { }
+
+/* implementation defined member functions */
+protected:
+  virtual bool __is_pointer_p () const;
+
+protected:
+  virtual bool __pointer_catch (const __pbase_type_info *__thr_type,
+                                void **__thr_obj,
+                                unsigned __outer) const;
+};
+
+class __class_type_info;
+
+/* type information for a pointer to member variable */
+class __pointer_to_member_type_info
+  : public __pbase_type_info
+{
+/* abi defined member variables */
+public:
+  __class_type_info *__context;   /* class of the member */
+
+/* abi defined member functions */
+public:
+  virtual ~__pointer_to_member_type_info ();
+public:
+  explicit __pointer_to_member_type_info (const char *__n,
+                                          int __quals,
+                                          const std::type_info *__type,
+                                          __class_type_info *__klass)
+    : __pbase_type_info (__n, __quals, __type), __context (__klass)
+    { }
+
+/* implementation defined member functions */
+protected:
+  virtual bool __pointer_catch (const __pbase_type_info *__thr_type,
+                                void **__thr_obj,
+                                unsigned __outer) const;
+};
+
+/* helper class for __vmi_class_type */
+class __base_class_type_info
+{
+/* abi defined member variables */
+public:
+  const __class_type_info* __base_type;    /* base class type */
+  long __offset_flags;            /* offset and info */
+
+/* implementation defined types */
+public:
+  enum __offset_flags_masks {
+    __virtual_mask = 0x1,
+    __public_mask = 0x2,
+    __hwm_bit = 2,
+    __offset_shift = 8          /* bits to shift offset by */
+  };
+  
+/* implementation defined member functions */
+public:
+  bool __is_virtual_p () const
+    { return __offset_flags & __virtual_mask; }
+  bool __is_public_p () const
+    { return __offset_flags & __public_mask; }
+  __PTRDIFF_TYPE__ __offset () const
+    { 
+      // This shift, being of a signed type, is implementation defined. GCC
+      // implements such shifts as arithmetic, which is what we want.
+      return static_cast<__PTRDIFF_TYPE__> (__offset_flags) >> __offset_shift;
+    }
+};
+
+/* type information for a class */
+class __class_type_info
+  : public std::type_info
+{
+/* abi defined member functions */
+public:
+  virtual ~__class_type_info ();
+public:
+  explicit __class_type_info (const char *__n)
+    : type_info (__n)
+    { }
+
+/* implementation defined types */
+public:
+  /* sub_kind tells us about how a base object is contained within a derived
+     object. We often do this lazily, hence the UNKNOWN value. At other times
+     we may use NOT_CONTAINED to mean not publicly contained. */
+  enum __sub_kind
+  {
+    __unknown = 0,              /* we have no idea */
+    __not_contained,            /* not contained within us (in some */
+                                /* circumstances this might mean not contained */
+                                /* publicly) */
+    __contained_ambig,          /* contained ambiguously */
+    
+    __contained_virtual_mask = __base_class_type_info::__virtual_mask, /* via a virtual path */
+    __contained_public_mask = __base_class_type_info::__public_mask,   /* via a public path */
+    __contained_mask = 1 << __base_class_type_info::__hwm_bit,         /* contained within us */
+    
+    __contained_private = __contained_mask,
+    __contained_public = __contained_mask | __contained_public_mask
+  };
+
+public:  
+  struct __upcast_result;
+  struct __dyncast_result;
+
+/* implementation defined member functions */
+protected:
+  virtual bool __do_upcast (const __class_type_info *__dst_type, void **__obj_ptr) const;
+
+protected:
+  virtual bool __do_catch (const type_info *__thr_type, void **__thr_obj,
+                           unsigned __outer) const;
+
+
+public:
+  /* Helper for upcast. See if DST is us, or one of our bases. */
+  /* Return false if not found, true if found. */
+  virtual bool __do_upcast (const __class_type_info *__dst,
+                            const void *__obj,
+                            __upcast_result &__restrict __result) const;
+
+public:
+  /* Indicate whether SRC_PTR of type SRC_TYPE is contained publicly within
+     OBJ_PTR. OBJ_PTR points to a base object of our type, which is the
+     destination type. SRC2DST indicates how SRC objects might be contained
+     within this type.  If SRC_PTR is one of our SRC_TYPE bases, indicate the
+     virtuality. Returns not_contained for non containment or private
+     containment. */
+  inline __sub_kind __find_public_src (__PTRDIFF_TYPE__ __src2dst,
+                                       const void *__obj_ptr,
+                                       const __class_type_info *__src_type,
+                                       const void *__src_ptr) const;
+
+public:
+  /* dynamic cast helper. ACCESS_PATH gives the access from the most derived
+     object to this base. DST_TYPE indicates the desired type we want. OBJ_PTR
+     points to a base of our type within the complete object. SRC_TYPE
+     indicates the static type started from and SRC_PTR points to that base
+     within the most derived object. Fill in RESULT with what we find. Return
+     true if we have located an ambiguous match. */
+  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,
+                             __sub_kind __access_path,
+                             const __class_type_info *__dst_type,
+                             const void *__obj_ptr,
+                             const __class_type_info *__src_type,
+                             const void *__src_ptr,
+                             __dyncast_result &__result) const;
+public:
+  /* Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE bases are
+     inherited by the type started from -- which is not necessarily the
+     current type. The current type will be a base of the destination type.
+     OBJ_PTR points to the current base. */
+  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,
+                                           const void *__obj_ptr,
+                                           const __class_type_info *__src_type,
+                                           const void *__src_ptr) const;
+};
+
+/* type information for a class with a single non-virtual base */
+class __si_class_type_info
+  : public __class_type_info
+{
+/* abi defined member variables */
+public:
+  const __class_type_info *__base_type;
+
+/* abi defined member functions */
+public:
+  virtual ~__si_class_type_info ();
+public:
+  explicit __si_class_type_info (const char *__n,
+                                 const __class_type_info *__base)
+    : __class_type_info (__n), __base_type (__base)
+    { }
+
+/* implementation defined member functions */
+protected:
+  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,
+                             __sub_kind __access_path,
+                             const __class_type_info *__dst_type,
+                             const void *__obj_ptr,
+                             const __class_type_info *__src_type,
+                             const void *__src_ptr,
+                             __dyncast_result &__result) const;
+  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,
+                                           const void *__obj_ptr,
+                                           const __class_type_info *__src_type,
+                                           const void *__sub_ptr) const;
+  virtual bool __do_upcast (const __class_type_info *__dst,
+                            const void *__obj,
+                            __upcast_result &__restrict __result) const;
+};
+
+/* type information for a class with multiple and/or virtual bases */
+class __vmi_class_type_info : public __class_type_info {
+/* abi defined member variables */
+public:
+  unsigned int __flags;         /* details about the class hierarchy */
+  unsigned int __base_count;    /* number of direct bases */
+  __base_class_type_info __base_info[1]; /* array of bases */
+  /* The array of bases uses the trailing array struct hack
+     so this class is not constructable with a normal constructor. It is
+     internally generated by the compiler. */
+
+/* abi defined member functions */
+public:
+  virtual ~__vmi_class_type_info ();
+public:
+  explicit __vmi_class_type_info (const char *__n,
+                                  int ___flags)
+    : __class_type_info (__n), __flags (___flags), __base_count (0)
+    { }
+
+/* implementation defined types */
+public:
+  enum __flags_masks {
+    __non_diamond_repeat_mask = 0x1,   /* distinct instance of repeated base */
+    __diamond_shaped_mask = 0x2,       /* diamond shaped multiple inheritance */
+    __flags_unknown_mask = 0x10
+  };
+
+/* implementation defined member functions */
+protected:
+  virtual bool __do_dyncast (__PTRDIFF_TYPE__ __src2dst,
+                             __sub_kind __access_path,
+                             const __class_type_info *__dst_type,
+                             const void *__obj_ptr,
+                             const __class_type_info *__src_type,
+                             const void *__src_ptr,
+                             __dyncast_result &__result) const;
+  virtual __sub_kind __do_find_public_src (__PTRDIFF_TYPE__ __src2dst,
+                                           const void *__obj_ptr,
+                                           const __class_type_info *__src_type,
+                                           const void *__src_ptr) const;
+  virtual bool __do_upcast (const __class_type_info *__dst,
+                            const void *__obj,
+                            __upcast_result &__restrict __result) const;
+};
+
+/* dynamic cast runtime */
+extern "C"
+void *__dynamic_cast (const void *__src_ptr,    /* object started from */
+                      const __class_type_info *__src_type, /* static type of object */
+                      const __class_type_info *__dst_type, /* desired target type */
+                      __PTRDIFF_TYPE__ __src2dst); /* how src and dst are related */
+
+    /* src2dst has the following possible values
+       >= 0: src_type is a unique public non-virtual base of dst_type
+             dst_ptr + src2dst == src_ptr
+       -1: unspecified relationship
+       -2: src_type is not a public base of dst_type
+       -3: src_type is a multiple public non-virtual base of dst_type */
+
+/* array ctor/dtor routines */
+
+/* allocate and construct array */
+extern "C"
+void *__cxa_vec_new (__SIZE_TYPE__ __element_count,
+                     __SIZE_TYPE__ __element_size,
+                     __SIZE_TYPE__ __padding_size,
+                     void (*__constructor) (void *),
+                     void (*__destructor) (void *));
+
+extern "C"
+void *__cxa_vec_new2 (__SIZE_TYPE__ __element_count,
+                      __SIZE_TYPE__ __element_size,
+                      __SIZE_TYPE__ __padding_size,
+                      void (*__constructor) (void *),
+                      void (*__destructor) (void *),
+                      void *(*__alloc) (__SIZE_TYPE__),
+                      void (*__dealloc) (void *));
+
+extern "C"
+void *__cxa_vec_new3 (__SIZE_TYPE__ __element_count,
+                      __SIZE_TYPE__ __element_size,
+                      __SIZE_TYPE__ __padding_size,
+                      void (*__constructor) (void *),
+                      void (*__destructor) (void *),
+                      void *(*__alloc) (__SIZE_TYPE__),
+                      void (*__dealloc) (void *, __SIZE_TYPE__));
+
+/* construct array */
+extern "C"
+void __cxa_vec_ctor (void *__array_address,
+                     __SIZE_TYPE__ __element_count,
+                     __SIZE_TYPE__ __element_size,
+                     void (*__constructor) (void *),
+                     void (*__destructor) (void *));
+
+extern "C"
+void __cxa_vec_cctor (void *dest_array,
+		      void *src_array,
+		      __SIZE_TYPE__ element_count,
+		      __SIZE_TYPE__ element_size,
+		      void (*constructor) (void *, void *),
+		      void (*destructor) (void *));
+ 
+/* destruct array */
+extern "C"
+void __cxa_vec_dtor (void *__array_address,
+                     __SIZE_TYPE__ __element_count,
+                     __SIZE_TYPE__ __element_size,
+                     void (*__destructor) (void *));
+
+/* destruct array */
+extern "C"
+void __cxa_vec_cleanup (void *__array_address,
+			__SIZE_TYPE__ __element_count,
+			__SIZE_TYPE__ __element_size,
+			void (*__destructor) (void *));
+
+/* destruct and release array */
+extern "C"
+void __cxa_vec_delete (void *__array_address,
+                       __SIZE_TYPE__ __element_size,
+                       __SIZE_TYPE__ __padding_size,
+                       void (*__destructor) (void *));
+
+extern "C"
+void __cxa_vec_delete2 (void *__array_address,
+                        __SIZE_TYPE__ __element_size,
+                        __SIZE_TYPE__ __padding_size,
+                        void (*__destructor) (void *),
+                        void (*__dealloc) (void *));
+                  
+extern "C"
+void __cxa_vec_delete3 (void *__array_address,
+                        __SIZE_TYPE__ __element_size,
+                        __SIZE_TYPE__ __padding_size,
+                        void (*__destructor) (void *),
+                        void (*__dealloc) (void *, __SIZE_TYPE__));
+
+/* guard variables */
+
+/* The ABI requires a 64-bit type.  */
+__extension__ typedef int __guard __attribute__((mode (__DI__)));
+
+extern "C"
+int __cxa_guard_acquire (__guard *);
+
+extern "C"
+void __cxa_guard_release (__guard *);
+
+extern "C"
+void __cxa_guard_abort (__guard *);
+
+/* pure virtual functions */
+
+extern "C" void
+__cxa_pure_virtual (void);
+
+/* exception handling */
+
+extern "C" void
+__cxa_bad_cast ();
+
+extern "C" void
+__cxa_bad_typeid ();
+
+/* DSO destruction */
+
+extern "C" int
+__cxa_atexit (void (*)(void *), void *, void *);
+
+extern "C" int
+__cxa_finalize (void *);
+
+/* demangling routines */
+
+extern "C" 
+char *__cxa_demangle (const char *__mangled_name,
+		      char *__output_buffer,
+		      __SIZE_TYPE__ *__length,
+		      int *__status);
+
+// Returns the type_info for the currently handled exception [15.3/8], or
+// null if there is none.
+extern "C"
+std::type_info *__cxa_current_exception_type ();
+
+} /* namespace __cxxabiv1 */
+
+/* User programs should use the alias `abi'. */
+namespace abi = __cxxabiv1;
+
+#else
+#endif /* __cplusplus */
+
+
+#endif /* __CXXABI_H */
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/del_op.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/del_op.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/del_op.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/del_op.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,40 @@
+// Boilerplate support routines for -*- C++ -*- dynamic memory management.
+
+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+//
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include "new"
+
+extern "C" void free (void *);
+
+void
+operator delete (void *ptr) throw ()
+{
+  if (ptr)
+    free (ptr);
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/del_opnt.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/del_opnt.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/del_opnt.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/del_opnt.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,40 @@
+// Boilerplate support routines for -*- C++ -*- dynamic memory management.
+
+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+//
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include "new"
+
+extern "C" void free (void *);
+
+void
+operator delete (void *ptr, const std::nothrow_t&) throw ()
+{
+  if (ptr)
+    free (ptr);
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/del_opv.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/del_opv.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/del_opv.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/del_opv.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,37 @@
+// Boilerplate support routines for -*- C++ -*- dynamic memory management.
+
+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+//
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include "new"
+
+void
+operator delete[] (void *ptr) throw ()
+{
+  ::operator delete (ptr);
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/del_opvnt.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/del_opvnt.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/del_opvnt.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/del_opvnt.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,37 @@
+// Boilerplate support routines for -*- C++ -*- dynamic memory management.
+
+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+//
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include "new"
+
+void
+operator delete[] (void *ptr, const std::nothrow_t&) throw ()
+{
+  ::operator delete (ptr);
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_alloc.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_alloc.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_alloc.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_alloc.cc	2004-10-26 14:26:00.000000000 +0000
@@ -0,0 +1,162 @@
+// -*- C++ -*- Allocate exception objects.
+// Copyright (C) 2001 Free Software Foundation, Inc.
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+// This is derived from the C++ ABI for IA-64.  Where we diverge
+// for cross-architecture compatibility are noted with "@@@".
+
+#include <cstdlib>
+#include <cstring>
+#include <climits>
+#include <exception>
+#include "unwind-cxx.h" 
+#include "bits/c++config.h"
+#include "bits/gthr.h"
+
+using namespace __cxxabiv1;
+
+
+// ??? How to control these parameters.
+
+// Guess from the size of basic types how large a buffer is reasonable.
+// Note that the basic c++ exception header has 13 pointers and 2 ints,
+// so on a system with PSImode pointers we're talking about 56 bytes
+// just for overhead.
+
+#if INT_MAX == 32767
+# define EMERGENCY_OBJ_SIZE	128
+# define EMERGENCY_OBJ_COUNT	16
+#elif LONG_MAX == 2147483647
+# define EMERGENCY_OBJ_SIZE	512
+# define EMERGENCY_OBJ_COUNT	32
+#else
+# define EMERGENCY_OBJ_SIZE	1024
+# define EMERGENCY_OBJ_COUNT	64
+#endif
+
+#ifndef __GTHREADS
+# undef EMERGENCY_OBJ_COUNT
+# define EMERGENCY_OBJ_COUNT	4
+#endif
+
+#if INT_MAX == 32767 || EMERGENCY_OBJ_COUNT <= 32
+typedef unsigned int bitmask_type;
+#else
+typedef unsigned long bitmask_type;
+#endif
+
+
+typedef char one_buffer[EMERGENCY_OBJ_SIZE] __attribute__((aligned));
+static one_buffer emergency_buffer[EMERGENCY_OBJ_COUNT];
+static bitmask_type emergency_used;
+
+
+#ifdef __GTHREADS
+#ifdef __GTHREAD_MUTEX_INIT
+static __gthread_mutex_t emergency_mutex =__GTHREAD_MUTEX_INIT;
+#else 
+static __gthread_mutex_t emergency_mutex;
+#endif
+
+#ifdef __GTHREAD_MUTEX_INIT_FUNCTION
+static void
+emergency_mutex_init ()
+{
+  __GTHREAD_MUTEX_INIT_FUNCTION (&emergency_mutex);
+}
+#endif
+#endif
+
+
+extern "C" void *
+__cxa_allocate_exception(std::size_t thrown_size)
+{
+  void *ret;
+  thrown_size += sizeof (__cxa_exception);
+  ret = std::malloc (thrown_size);
+
+  if (! ret)
+    {
+#ifdef __GTHREADS
+#ifdef __GTHREAD_MUTEX_INIT_FUNCTION
+      static __gthread_once_t once = __GTHREAD_ONCE_INIT;
+      __gthread_once (&once, emergency_mutex_init);
+#endif
+      __gthread_mutex_lock (&emergency_mutex);
+#endif
+
+      bitmask_type used = emergency_used;
+      unsigned int which = 0;
+
+      if (thrown_size > EMERGENCY_OBJ_SIZE)
+	goto failed;
+      while (used & 1)
+	{
+	  used >>= 1;
+	  if (++which >= EMERGENCY_OBJ_COUNT)
+	    goto failed;
+	}
+
+      emergency_used |= (bitmask_type)1 << which;
+      ret = &emergency_buffer[which][0];
+
+    failed:;
+#ifdef __GTHREADS
+      __gthread_mutex_unlock (&emergency_mutex);
+#endif
+      if (!ret)
+	std::terminate ();
+    }
+
+  std::memset (ret, 0, sizeof (__cxa_exception));
+
+  return (void *)((char *)ret + sizeof (__cxa_exception));
+}
+
+
+extern "C" void
+__cxa_free_exception(void *vptr)
+{
+  char *ptr = (char *) vptr;
+  if (ptr >= &emergency_buffer[0][0]
+      && ptr < &emergency_buffer[0][0] + sizeof (emergency_buffer))
+    {
+      unsigned int which
+	= (unsigned)(ptr - &emergency_buffer[0][0]) / EMERGENCY_OBJ_SIZE;
+
+#ifdef __GTHREADS
+      __gthread_mutex_lock (&emergency_mutex);
+      emergency_used &= ~((bitmask_type)1 << which);
+      __gthread_mutex_unlock (&emergency_mutex);
+#else
+      emergency_used &= ~((bitmask_type)1 << which);
+#endif
+    }
+  else
+    std::free (ptr - sizeof (__cxa_exception));
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_aux_runtime.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_aux_runtime.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_aux_runtime.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_aux_runtime.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,57 @@
+// -*- C++ -*- Common throw conditions.
+// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001 
+// Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA. 
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include "typeinfo"
+#include "exception"
+#include <cstdlib>
+#include "unwind-cxx.h"
+#include "exception_defines.h"
+
+
+extern "C" void
+__cxa_bad_cast ()
+{
+#ifdef __EXCEPTIONS  
+  throw std::bad_cast();
+#else
+  std::abort();
+#endif
+}
+
+extern "C" void
+__cxa_bad_typeid ()
+{
+#ifdef __EXCEPTIONS  
+  throw std::bad_typeid();
+#else
+  std::abort();
+#endif
+}
+
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_catch.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_catch.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_catch.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_catch.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,133 @@
+// -*- C++ -*- Exception handling routines for catching.
+// Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+
+#include <cstdlib>
+#include "unwind-cxx.h"
+using namespace __cxxabiv1;
+
+
+extern "C" void *
+__cxa_begin_catch (void *exc_obj_in)
+{
+	
+  _Unwind_Exception *exceptionObject
+    = reinterpret_cast <_Unwind_Exception *>(exc_obj_in);
+  __cxa_eh_globals *globals = __cxa_get_globals ();
+  __cxa_exception *prev = globals->caughtExceptions;
+  __cxa_exception *header = __get_exception_header_from_ue (exceptionObject);
+  // Foreign exceptions can't be stacked here.  If the exception stack is
+  // empty, then fine.  Otherwise we really have no choice but to terminate.
+  // Note that this use of "header" is a lie.  It's fine so long as we only
+  // examine header->unwindHeader though.
+  if (header->unwindHeader.exception_class != __gxx_exception_class)
+    {
+      if (prev != 0)
+	std::terminate ();
+
+      // Remember for end_catch and rethrow.
+      globals->caughtExceptions = header;
+
+      // ??? No sensible value to return; we don't know what the 
+      // object is, much less where it is in relation to the header.
+      return 0;
+    }
+
+  int count = header->handlerCount;
+  if (count < 0)
+    // This exception was rethrown from an immediately enclosing region.
+    count = -count + 1;
+  else
+    {
+      count += 1;
+      globals->uncaughtExceptions -= 1;
+    }
+  header->handlerCount = count;
+
+  if (header != prev)
+    {
+      header->nextException = prev;
+      globals->caughtExceptions = header;
+    }
+  return header->adjustedPtr;
+}
+
+
+extern "C" void
+__cxa_end_catch ()
+{
+  __cxa_eh_globals *globals = __cxa_get_globals_fast ();
+  __cxa_exception *header = globals->caughtExceptions;
+
+  // A rethrow of a foreign exception will be removed from the
+  // the exception stack immediately by __cxa_rethrow.
+  if (!header)
+    return;
+
+  // A foreign exception couldn't have been stacked (see above),
+  // so by definition processing must be complete.
+  if (header->unwindHeader.exception_class != __gxx_exception_class)
+    {
+      globals->caughtExceptions = 0;
+      _Unwind_DeleteException (&header->unwindHeader);
+      return;
+    }
+
+  int count = header->handlerCount;
+  if (count < 0)
+    {
+      // This exception was rethrown.  Decrement the (inverted) catch
+      // count and remove it from the chain when it reaches zero.
+      if (++count == 0)
+	{
+	  globals->uncaughtExceptions += 1;
+	  globals->caughtExceptions = header->nextException;
+	}
+    }
+  else if (--count == 0)
+    {
+      // Handling for this exception is complete.  Destroy the object.
+      globals->caughtExceptions = header->nextException;
+      _Unwind_DeleteException (&header->unwindHeader);
+      return;
+    }
+  else if (count < 0)
+    // A bug in the exception handling library or compiler.
+    std::terminate ();
+
+  header->handlerCount = count;
+}
+
+
+bool
+std::uncaught_exception() throw()
+{
+  __cxa_eh_globals *globals = __cxa_get_globals ();
+  return globals->uncaughtExceptions != 0;
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_exception.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_exception.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_exception.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_exception.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,44 @@
+// -*- C++ -*- std::exception implementation.
+// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 
+// Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA. 
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+
+#include "typeinfo"
+#include "exception"
+#include "unwind-cxx.h"
+
+std::exception::~exception() throw() { }
+
+std::bad_exception::~bad_exception() throw() { }
+
+const char* 
+std::exception::what() const throw()
+{
+  return typeid (*this).name ();
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_globals.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_globals.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_globals.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_globals.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,133 @@
+// -*- C++ -*- Manage the thread-local exception globals.
+// Copyright (C) 2001 Free Software Foundation, Inc.
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+
+#include <exception>
+#include <cstdlib>
+#include "unwind-cxx.h"
+#include "bits/c++config.h"
+#include "bits/gthr.h"
+
+// The kernel doesn't have anything that could be used to implement
+// __gthread_getspecific, so the thread-specific bits are stored in
+// task_struct instead.
+#ifdef __KERNEL__
+#include <begin_include.h>
+#include <linux/sched.h>
+#include <end_include.h>
+#endif
+
+using namespace __cxxabiv1;
+
+
+#ifndef __KERNEL__
+// Single-threaded fallback buffer.
+static __cxa_eh_globals globals_static;
+
+#if __GTHREADS
+static __gthread_key_t globals_key;
+static int use_thread_key = -1;
+
+static void
+get_globals_dtor (void *ptr)
+{
+  if (ptr)
+    std::free (ptr);
+}
+
+static void
+get_globals_init ()
+{
+  use_thread_key =
+    (__gthread_key_create (&globals_key, get_globals_dtor) == 0);
+}
+
+static void
+get_globals_init_once ()
+{
+  static __gthread_once_t once = __GTHREAD_ONCE_INIT;
+  if (__gthread_once (&once, get_globals_init) != 0
+      || use_thread_key < 0)
+    use_thread_key = 0;
+}
+#endif
+#endif
+
+extern "C" __cxa_eh_globals *
+__cxa_get_globals_fast ()
+{
+#ifdef __KERNEL__
+  return reinterpret_cast<__cxa_eh_globals*>(&current->cxa_eh_globals);
+#elif __GTHREADS
+  if (use_thread_key)
+    return (__cxa_eh_globals *) __gthread_getspecific (globals_key);
+  else
+    return &globals_static;
+#else
+  return &globals_static;
+#endif
+}
+
+extern "C" __cxa_eh_globals *
+__cxa_get_globals ()
+{
+#ifdef __KERNEL__
+  BUG_ON(sizeof(current->cxa_eh_globals) < sizeof(__cxa_eh_globals));
+  return reinterpret_cast<__cxa_eh_globals*>(&current->cxa_eh_globals);
+#elif __GTHREADS
+  __cxa_eh_globals *g;
+
+  if (use_thread_key == 0)
+    return &globals_static;
+
+  if (use_thread_key < 0)
+    {
+      get_globals_init_once ();
+
+      // Make sure use_thread_key got initialized.
+      if (use_thread_key == 0)
+	return &globals_static;
+    }
+
+  g = (__cxa_eh_globals *) __gthread_getspecific (globals_key);
+  if (! g)
+    {
+      if ((g = (__cxa_eh_globals *)
+	   std::malloc (sizeof (__cxa_eh_globals))) == 0
+	  || __gthread_setspecific (globals_key, (void *) g) != 0)
+        std::terminate ();
+      g->caughtExceptions = 0;
+      g->uncaughtExceptions = 0;
+    }
+
+  return g;
+#else
+  return &globals_static;
+#endif
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_personality.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_personality.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_personality.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_personality.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,464 @@
+// -*- C++ -*- The GNU C++ exception personality routine.
+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+
+#include <bits/c++config.h>
+#include <cstdlib>
+#include <exception_defines.h>
+#include "unwind-cxx.h"
+
+using namespace __cxxabiv1;
+
+#include "unwind-pe.h"
+
+
+struct lsda_header_info
+{
+  _Unwind_Ptr Start;
+  _Unwind_Ptr LPStart;
+  _Unwind_Ptr ttype_base;
+  const unsigned char *TType;
+  const unsigned char *action_table;
+  unsigned char ttype_encoding;
+  unsigned char call_site_encoding;
+};
+
+static const unsigned char *
+parse_lsda_header (_Unwind_Context *context, const unsigned char *p,
+		   lsda_header_info *info)
+{
+  _Unwind_Word tmp;
+  unsigned char lpstart_encoding;
+
+  info->Start = (context ? _Unwind_GetRegionStart (context) : 0);
+
+  // Find @LPStart, the base to which landing pad offsets are relative.
+  lpstart_encoding = *p++;
+  if (lpstart_encoding != DW_EH_PE_omit)
+    p = read_encoded_value (context, lpstart_encoding, p, &info->LPStart);
+  else
+    info->LPStart = info->Start;
+
+  // Find @TType, the base of the handler and exception spec type data.
+  info->ttype_encoding = *p++;
+  if (info->ttype_encoding != DW_EH_PE_omit)
+    {
+      p = read_uleb128 (p, &tmp);
+      info->TType = p + tmp;
+    }
+  else
+    info->TType = 0;
+
+  // The encoding and length of the call-site table; the action table
+  // immediately follows.
+  info->call_site_encoding = *p++;
+  p = read_uleb128 (p, &tmp);
+  info->action_table = p + tmp;
+
+  return p;
+}
+
+static const std::type_info *
+get_ttype_entry (lsda_header_info *info, _Unwind_Word i)
+{
+  _Unwind_Ptr ptr;
+
+  i *= size_of_encoded_value (info->ttype_encoding);
+  read_encoded_value_with_base (info->ttype_encoding, info->ttype_base,
+				info->TType - i, &ptr);
+
+  return reinterpret_cast<const std::type_info *>(ptr);
+}
+
+// Given the thrown type THROW_TYPE, pointer to a variable containing a
+// pointer to the exception object THROWN_PTR_P and a type CATCH_TYPE to
+// compare against, return whether or not there is a match and if so,
+// update *THROWN_PTR_P.
+
+static bool
+get_adjusted_ptr (const std::type_info *catch_type,
+		  const std::type_info *throw_type,
+		  void **thrown_ptr_p)
+{
+  void *thrown_ptr = *thrown_ptr_p;
+
+  // Pointer types need to adjust the actual pointer, not
+  // the pointer to pointer that is the exception object.
+  // This also has the effect of passing pointer types
+  // "by value" through the __cxa_begin_catch return value.
+  if (throw_type->__is_pointer_p ())
+    thrown_ptr = *(void **) thrown_ptr;
+
+  if (catch_type->__do_catch (throw_type, &thrown_ptr, 1))
+    {
+      *thrown_ptr_p = thrown_ptr;
+      return true;
+    }
+
+  return false;
+}
+
+// Return true if THROW_TYPE matches one if the filter types.
+
+static bool
+check_exception_spec (lsda_header_info *info, const std::type_info *throw_type,
+		      void *thrown_ptr, _Unwind_Sword filter_value)
+{
+  const unsigned char *e = info->TType - filter_value - 1;
+
+  while (1)
+    {
+      const std::type_info *catch_type;
+      _Unwind_Word tmp;
+
+      e = read_uleb128 (e, &tmp);
+
+      // Zero signals the end of the list.  If we've not found
+      // a match by now, then we've failed the specification.
+      if (tmp == 0)
+        return false;
+
+      // Match a ttype entry.
+      catch_type = get_ttype_entry (info, tmp);
+
+      // ??? There is currently no way to ask the RTTI code about the
+      // relationship between two types without reference to a specific
+      // object.  There should be; then we wouldn't need to mess with
+      // thrown_ptr here.
+      if (get_adjusted_ptr (catch_type, throw_type, &thrown_ptr))
+	return true;
+    }
+}
+
+// Return true if the filter spec is empty, ie throw().
+
+static bool
+empty_exception_spec (lsda_header_info *info, _Unwind_Sword filter_value)
+{
+  const unsigned char *e = info->TType - filter_value - 1;
+  _Unwind_Word tmp;
+
+  e = read_uleb128 (e, &tmp);
+  return tmp == 0;
+}
+
+// Using a different personality function name causes link failures
+// when trying to mix code using different exception handling models.
+#ifdef _GLIBCXX_SJLJ_EXCEPTIONS
+#define PERSONALITY_FUNCTION	__gxx_personality_sj0
+#define __builtin_eh_return_data_regno(x) x
+#else
+#define PERSONALITY_FUNCTION	__gxx_personality_v0
+#endif
+
+
+//One phase unwind personality function
+extern "C" _Unwind_Reason_Code
+PERSONALITY_FUNCTION (int version,
+		      _Unwind_Action actions,
+		      _Unwind_Exception_Class exception_class,
+		      struct _Unwind_Exception *ue_header,
+		      struct _Unwind_Context *context)
+{
+  __cxa_exception *xh = __get_exception_header_from_ue (ue_header);
+
+  enum found_handler_type
+  {
+    found_nothing,
+    found_terminate,
+    found_cleanup,
+    found_handler
+  } found_type;
+
+  lsda_header_info info;
+  const unsigned char *language_specific_data;
+  const unsigned char *action_record;
+  const unsigned char *p;
+  _Unwind_Ptr landing_pad, ip;
+  int handler_switch_value;
+  void *thrown_ptr = xh + 1;
+
+  // Interface version check.
+  if (version != 1)
+    return _URC_FATAL_PHASE1_ERROR;
+
+
+  language_specific_data = (const unsigned char *)
+    _Unwind_GetLanguageSpecificData (context);
+
+  // If no LSDA, then there are no handlers or cleanups.
+  if (! language_specific_data)
+    return _URC_CONTINUE_UNWIND;
+
+  // Parse the LSDA header.
+  p = parse_lsda_header (context, language_specific_data, &info);
+  info.ttype_base = base_of_encoded_value (info.ttype_encoding, context);
+  ip = _Unwind_GetIP (context) - 1;
+  landing_pad = 0;
+  action_record = 0;
+  handler_switch_value = 0;
+
+
+  // Search the call-site table for the action associated with this IP.
+  while (p < info.action_table)
+    {
+      _Unwind_Ptr cs_start, cs_len, cs_lp;
+      _Unwind_Word cs_action;
+
+      // Note that all call-site encodings are "absolute" displacements.
+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_start);
+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_len);
+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_lp);
+      p = read_uleb128 (p, &cs_action);
+
+      // The table is sorted, so if we've passed the ip, stop.
+      if (ip < info.Start + cs_start)
+	p = info.action_table;
+      else if (ip < info.Start + cs_start + cs_len)
+	{
+	  if (cs_lp)
+	    landing_pad = info.LPStart + cs_lp;
+	  if (cs_action)
+	    action_record = info.action_table + cs_action - 1;
+	  goto found_something;
+	}
+    }
+
+
+  // If ip is not present in the table, call terminate.  This is for
+  // a destructor inside a cleanup, or a library routine the compiler
+  // was not expecting to throw.
+  found_type = found_terminate;
+  goto do_something;
+
+ found_something:
+  if (landing_pad == 0)
+    {
+      // If ip is present, and has a null landing pad, there are
+      // no cleanups or handlers to be run.
+      found_type = found_nothing;
+    }
+  else if (action_record == 0)
+    {
+      // If ip is present, has a non-null landing pad, and a null
+      // action table offset, then there are only cleanups present.
+      // Cleanups use a zero switch value, as set above.
+      found_type = found_cleanup;
+    }
+  else
+    {
+      // Otherwise we have a catch handler or exception specification.
+
+      _Unwind_Sword ar_filter, ar_disp;
+      const std::type_info *throw_type, *catch_type;
+      bool saw_cleanup = false;
+      bool saw_handler = false;
+
+      // During forced unwinding, we only run cleanups.  With a foreign
+      // exception class, there's no exception type.
+      // ??? What to do about GNU Java and GNU Ada exceptions.
+
+      if ((actions & _UA_FORCE_UNWIND)
+	  || exception_class != __gxx_exception_class)
+	throw_type = 0;
+      else
+	throw_type = xh->exceptionType;
+
+      while (1)
+	{
+	  p = action_record;
+	  p = read_sleb128 (p, &ar_filter);
+	  read_sleb128 (p, &ar_disp);
+
+	  if (ar_filter == 0)
+	    {
+	      // Zero filter values are cleanups.
+	      saw_cleanup = true;
+	    }
+	  else if (ar_filter > 0)
+	    {
+	      // Positive filter values are handlers.
+	      catch_type = get_ttype_entry (&info, ar_filter);
+
+	      // Null catch type is a catch-all handler; we can catch foreign
+	      // exceptions with this.  Otherwise we must match types.
+	      if (! catch_type
+		  || (throw_type
+		      && get_adjusted_ptr (catch_type, throw_type,
+					   &thrown_ptr)))
+		{
+		  saw_handler = true;
+		  break;
+		}
+	    }
+	  else
+	    {
+	      // Negative filter values are exception specifications.
+	      // ??? How do foreign exceptions fit in?  As far as I can
+	      // see we can't match because there's no __cxa_exception
+	      // object to stuff bits in for __cxa_call_unexpected to use.
+	      // Allow them iff the exception spec is non-empty.  I.e.
+	      // a throw() specification results in __unexpected.
+	      if (throw_type
+		  ? ! check_exception_spec (&info, throw_type, thrown_ptr,
+					    ar_filter)
+		  : empty_exception_spec (&info, ar_filter))
+		{
+		  saw_handler = true;
+		  break;
+		}
+	    }
+
+	  if (ar_disp == 0)
+	    break;
+	  action_record = p + ar_disp;
+	}
+
+      if (saw_handler)
+	{
+	  handler_switch_value = ar_filter;
+	  found_type = found_handler;
+	}
+      else
+	found_type = (saw_cleanup ? found_cleanup : found_nothing);
+    }
+
+ do_something:
+   if (found_type == found_nothing)
+     return _URC_CONTINUE_UNWIND;
+
+  
+
+ install_context:
+  // We can't use any of the cxa routines with foreign exceptions,
+  // because they all expect ue_header to be a struct __cxa_exception.
+  // So in that case, call terminate or unexpected directly.
+   // For domestic exceptions, we cache data from phase 1 for phase 2.
+     
+  if ((actions & _UA_FORCE_UNWIND)
+      || exception_class != __gxx_exception_class)
+    {
+      if (found_type == found_terminate)
+	std::terminate ();
+      else if (handler_switch_value < 0)
+	{
+	  try 
+	    { std::unexpected (); } 
+	  catch(...) 
+	    { std::terminate (); }
+	}
+    }
+  else
+    {
+      if (found_type == found_terminate)
+	{
+	  __cxa_begin_catch (&xh->unwindHeader);
+	  __terminate (xh->terminateHandler);
+	}
+
+      // Cache the TType base value for __cxa_call_unexpected, as we won't
+      // have an _Unwind_Context then.
+      if (handler_switch_value < 0)
+	{
+	  parse_lsda_header (context, language_specific_data, &info);
+	  xh->catchTemp = base_of_encoded_value (info.ttype_encoding, context);
+	}
+    }
+
+          xh->adjustedPtr = thrown_ptr;
+  /* For targets with pointers smaller than the word size, we must extend the
+     pointer, and this extension is target dependent.  */
+  _Unwind_SetGR (context, __builtin_eh_return_data_regno (0),
+		 __builtin_extend_pointer (&xh->unwindHeader));
+  _Unwind_SetGR (context, __builtin_eh_return_data_regno (1),
+		 handler_switch_value);
+  _Unwind_SetIP (context, landing_pad);
+  return _URC_INSTALL_CONTEXT;
+}
+
+extern "C" void
+__cxa_call_unexpected (void *exc_obj_in)
+{
+  _Unwind_Exception *exc_obj
+    = reinterpret_cast <_Unwind_Exception *>(exc_obj_in);
+
+  __cxa_begin_catch (exc_obj);
+
+  // This function is a handler for our exception argument.  If we exit
+  // by throwing a different exception, we'll need the original cleaned up.
+  struct end_catch_protect
+  {
+    end_catch_protect() { }
+    ~end_catch_protect() { __cxa_end_catch(); }
+  } end_catch_protect_obj;
+
+  lsda_header_info info;
+  __cxa_exception *xh = __get_exception_header_from_ue (exc_obj);
+  const unsigned char *xh_lsda;
+  _Unwind_Sword xh_switch_value;
+  std::terminate_handler xh_terminate_handler;
+
+  // If the unexpectedHandler rethrows the exception (e.g. to categorize it),
+  // it will clobber data about the current handler.  So copy the data out now.
+  xh_lsda = xh->languageSpecificData;
+  xh_switch_value = xh->handlerSwitchValue;
+  xh_terminate_handler = xh->terminateHandler;
+  info.ttype_base = (_Unwind_Ptr) xh->catchTemp;
+
+  try 
+    { __unexpected (xh->unexpectedHandler); } 
+  catch(...) 
+    {
+      // Get the exception thrown from unexpected.
+
+      __cxa_eh_globals *globals = __cxa_get_globals_fast ();
+      __cxa_exception *new_xh = globals->caughtExceptions;
+      void *new_ptr = new_xh + 1;
+
+      // We don't quite have enough stuff cached; re-parse the LSDA.
+      parse_lsda_header (0, xh_lsda, &info);
+
+      // If this new exception meets the exception spec, allow it.
+      if (check_exception_spec (&info, new_xh->exceptionType,
+				new_ptr, xh_switch_value))
+	__throw_exception_again;
+
+      // If the exception spec allows std::bad_exception, throw that.
+      // We don't have a thrown object to compare against, but since
+      // bad_exception doesn't have virtual bases, that's OK; just pass 0.
+#ifdef __EXCEPTIONS  
+      const std::type_info &bad_exc = typeid (std::bad_exception);
+      if (check_exception_spec (&info, &bad_exc, 0, xh_switch_value))
+	throw std::bad_exception();
+#endif   
+
+      // Otherwise, die.
+      __terminate (xh_terminate_handler);
+    }
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_term_handler.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_term_handler.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_term_handler.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_term_handler.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,51 @@
+// -*- C++ -*- std::terminate handler
+// Copyright (C) 2002, 2003 Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA. 
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include "unwind-cxx.h"
+#include <bits/c++config.h>
+
+/* We default to the talkative, informative handler in a normal hosted
+   library.  This pulls in the demangler, the dyn-string utilities, and
+   elements of the I/O library.  For a low-memory environment, you can return
+   to the earlier "silent death" handler by including <cstdlib>, initializing
+   to "std::abort", and rebuilding the library.  In a freestanding mode, we
+   default to this latter approach.  */
+
+#if ! _GLIBCXX_HOSTED
+# include <cstdlib>
+#endif
+
+/* The current installed user handler.  */
+std::terminate_handler __cxxabiv1::__terminate_handler =
+#if _GLIBCXX_HOSTED
+	__gnu_cxx::__verbose_terminate_handler;
+#else
+	std::abort;
+#endif
+
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_terminate.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_terminate.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_terminate.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_terminate.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,83 @@
+// -*- C++ -*- std::terminate, std::unexpected and friends.
+// Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
+// Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA. 
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include "typeinfo"
+#include "exception"
+#include <cstdlib>
+#include "unwind-cxx.h"
+#include "exception_defines.h"
+
+using namespace __cxxabiv1;
+
+void
+__cxxabiv1::__terminate (std::terminate_handler handler)
+{
+  try {
+    handler ();
+    std::abort ();
+  } catch (...) {
+    std::abort ();
+  }
+}
+
+void
+std::terminate ()
+{
+  __terminate (__terminate_handler);
+}
+
+void
+__cxxabiv1::__unexpected (std::unexpected_handler handler)
+{
+  handler();
+  std::terminate ();
+}
+
+void
+std::unexpected ()
+{
+  __unexpected (__unexpected_handler);
+}
+
+std::terminate_handler
+std::set_terminate (std::terminate_handler func) throw()
+{
+  std::terminate_handler old = __terminate_handler;
+  __terminate_handler = func;
+  return old;
+}
+
+std::unexpected_handler
+std::set_unexpected (std::unexpected_handler func) throw()
+{
+  std::unexpected_handler old = __unexpected_handler;
+  __unexpected_handler = func;
+  return old;
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_throw.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_throw.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_throw.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_throw.cc	2004-10-29 17:03:12.000000000 +0000
@@ -0,0 +1,290 @@
+// -*- C++ -*- Exception handling routines for throwing.
+// Copyright (C) 2001, 2003 Free Software Foundation, Inc.
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+
+#include <bits/c++config.h>
+#include "unwind-cxx.h"
+
+
+using namespace __cxxabiv1;
+
+
+static void
+__gxx_exception_cleanup (_Unwind_Reason_Code code, _Unwind_Exception *exc)
+{
+  __cxa_exception *header = __get_exception_header_from_ue (exc);
+
+  // If we haven't been caught by a foreign handler, then this is
+  // some sort of unwind error.  In that case just die immediately.
+  // _Unwind_DeleteException in the HP-UX IA64 libunwind library
+  //  returns _URC_NO_REASON and not _URC_FOREIGN_EXCEPTION_CAUGHT
+  // like the GCC _Unwind_DeleteException function does.
+  if (code != _URC_FOREIGN_EXCEPTION_CAUGHT && code != _URC_NO_REASON)
+    __terminate (header->terminateHandler);
+
+  if (header->exceptionDestructor)
+    header->exceptionDestructor (header + 1);
+
+  __cxa_free_exception (header + 1);
+}
+
+
+extern "C" 
+{
+struct dwarf_eh_bases
+{
+  void *tbase;
+  void *dbase;
+  void *func;
+};
+struct _Unwind_Context
+{
+  void *reg[17 +1];
+  void *cfa;
+  void *ra;
+  void *lsda;
+  struct dwarf_eh_bases bases;
+  _Unwind_Word args_size;
+};
+ void
+uw_init_context_1 (struct _Unwind_Context *context,
+                   void *outer_cfa, void *outer_ra);
+
+#define uw_init_context(CONTEXT)					   \
+  do									   \
+    {									   \
+      /* Do any necessary initialization to access arbitrary stack frames. \
+	 On the SPARC, this means flushing the register windows.  */	   \
+      __builtin_unwind_init ();						   \
+      uw_init_context_1 (CONTEXT, __builtin_dwarf_cfa (),		   \
+			 __builtin_return_address (0));			   \
+    }									   \
+  while (0)
+  
+typedef struct
+{
+
+
+  struct frame_state_reg_info
+  {
+    struct {
+      union {
+        _Unwind_Word reg;
+        _Unwind_Sword offset;
+        const unsigned char *exp;
+      } loc;
+      enum {
+        REG_UNSAVED,
+        REG_SAVED_OFFSET,
+        REG_SAVED_REG,
+        REG_SAVED_EXP
+      } how;
+    } reg[17 +1];
+
+
+    struct frame_state_reg_info *prev;
+  } regs;
+
+
+
+  _Unwind_Sword cfa_offset;
+  _Unwind_Word cfa_reg;
+  const unsigned char *cfa_exp;
+  enum {
+    CFA_UNSET,
+    CFA_REG_OFFSET,
+    CFA_EXP
+  } cfa_how;
+
+
+  void *pc;
+
+
+  _Unwind_Personality_Fn personality;
+  _Unwind_Sword data_align;
+  _Unwind_Word code_align;
+  unsigned char retaddr_column;
+  unsigned char fde_encoding;
+  unsigned char lsda_encoding;
+  unsigned char saw_z;
+  void *eh_ptr;
+} _Unwind_FrameState;
+ _Unwind_Reason_Code
+uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState **fs);  
+
+ void
+uw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs);
+ __inline__ __attribute__((always_inline)) _Unwind_Ptr
+uw_identify_context (struct _Unwind_Context *context);
+
+#define uw_install_context(CURRENT, TARGET)				 \
+  do									 \
+    {									 \
+      long offset = uw_install_context_1 ((CURRENT), (TARGET));		 \
+      void *handler = __builtin_frob_return_addr ((TARGET)->ra);	 \
+      __builtin_eh_return (offset, handler);				 \
+    }									 \
+  while (0)
+
+ long
+uw_install_context_1 (struct _Unwind_Context *myCurrent,
+                      struct _Unwind_Context *target);
+ _Unwind_Reason_Code
+_Unwind_RaiseException_Phase2(struct _Unwind_Exception *exc,
+			      struct _Unwind_Context *context);                      
+}
+
+ static inline  _Unwind_Reason_Code
+_Unwind_RaiseException_In_One_Phase(struct _Unwind_Exception *exc) __attribute__ ((always_inline));
+ 
+static inline  _Unwind_Reason_Code
+_Unwind_RaiseException_In_One_Phase(struct _Unwind_Exception *exc)  
+{
+//	 
+  struct _Unwind_Context this_context, cur_context;
+  _Unwind_Reason_Code code;
+  
+  /* Set up this_context to describe the current stack frame.  */
+ uw_init_context (&this_context);
+  cur_context = this_context;
+ 
+  /* Phase 1: Search.  Unwind the stack, calling the personality routine
+     with the _UA_SEARCH_PHASE flag set.  Do not modify the stack yet.  */
+  while (1)
+    {
+      _Unwind_FrameState *fs;
+      //count++;
+     // printk("Count nr: %u \n", count);
+      /* Set up fs to describe the FDE for the caller of cur_context.  The
+	 first time through the loop, that means __cxa_throw.  */
+      code = uw_frame_state_for (&cur_context, &fs);
+      if (code == _URC_END_OF_STACK)
+	/* Hit end of stack with no handler found.  */
+	return _URC_END_OF_STACK;
+
+      if (code != _URC_NO_REASON)
+	/* Some error encountered.  Ususally the unwinder doesn't
+	   diagnose these and merely crashes.  */
+	return _URC_FATAL_PHASE1_ERROR;
+
+      /* Unwind successful.  Run the personality routine, if any.  */
+      if (fs->personality)
+	{
+	  code = (*fs->personality) (1, _UA_CLEANUP_PHASE, exc->exception_class,
+				    exc, &cur_context);
+	  if (code == _URC_INSTALL_CONTEXT)
+	    break;
+	  else if (code != _URC_CONTINUE_UNWIND)
+	    return _URC_FATAL_PHASE1_ERROR;
+	}
+      
+      /* Update cur_context to describe the same frame as fs.  */
+      uw_update_context (&cur_context, fs);
+    }
+ 
+  /* Indicate to _Unwind_Resume and associated subroutines that this
+     is not a forced unwind.  Further, note where we found a handler.  */
+   if (code != _URC_INSTALL_CONTEXT)
+    return code;
+  uw_install_context (&this_context, &cur_context);
+
+
+
+  // Some sort of unwinding error.  Note that terminate is a handler.
+  __cxa_begin_catch (exc);
+  std::terminate ();
+} 
+
+
+extern "C" void
+__cxa_throw (void *obj, std::type_info *tinfo, void (*dest) (void *))
+{
+  struct _Unwind_Exception *exc;
+  struct _Unwind_Context this_context, cur_context;
+  _Unwind_Reason_Code code;
+  
+  __cxa_exception *header = __get_exception_header_from_obj (obj);
+  header->exceptionType = tinfo;
+  header->exceptionDestructor = dest;
+  header->unexpectedHandler = __unexpected_handler;
+  header->terminateHandler = __terminate_handler;
+  header->unwindHeader.exception_class = __gxx_exception_class;
+  header->unwindHeader.exception_cleanup = __gxx_exception_cleanup;
+
+
+  __cxa_eh_globals *globals = __cxa_get_globals ();
+  globals->uncaughtExceptions += 1;
+
+
+#ifdef _GLIBCXX_SJLJ_EXCEPTIONS
+  _Unwind_SjLj_RaiseException (&header->unwindHeader);
+#else
+  //INLINE THE METHOD TO SAVE ONE!!!
+_Unwind_RaiseException_In_One_Phase(&header->unwindHeader);
+#endif
+}
+
+void
+_Unwind_Resume (struct _Unwind_Exception *exc)
+{
+  struct _Unwind_Context this_context, cur_context;
+  _Unwind_Reason_Code code;
+_Unwind_RaiseException_In_One_Phase(exc);
+ 
+}
+extern "C" void
+__cxa_rethrow ()
+{
+  __cxa_eh_globals *globals = __cxa_get_globals ();
+  __cxa_exception *header = globals->caughtExceptions;
+
+  // Watch for luser rethrowing with no active exception.
+  if (header)
+    {
+      // Tell __cxa_end_catch this is a rethrow.
+      if (header->unwindHeader.exception_class != __gxx_exception_class)
+	globals->caughtExceptions = 0;
+      else
+	header->handlerCount = -header->handlerCount;
+
+#ifdef _GLIBCXX_SJLJ_EXCEPTIONS
+      _Unwind_SjLj_Resume_or_Rethrow (&header->unwindHeader);
+#else
+#ifdef _LIBUNWIND_STD_ABI
+      _Unwind_RaiseException_In_One_Phase (&header->unwindHeader);
+#else
+      _Unwind_RaiseException_In_One_Phase (&header->unwindHeader);
+#endif
+#endif
+  
+      // Some sort of unwinding error.  Note that terminate is a handler.
+      __cxa_begin_catch (&header->unwindHeader);
+    }
+  std::terminate ();
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_type.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_type.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_type.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_type.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,50 @@
+// -*- C++ -*- Exception handling routines for catching.
+// Copyright (C) 2001 Free Software Foundation, Inc.
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+
+#include <typeinfo>
+#include "unwind-cxx.h"
+
+namespace __cxxabiv1
+{
+
+// Returns the type_info for the currently handled exception [15.3/8], or
+// null if there is none.
+extern "C"
+std::type_info *__cxa_current_exception_type ()
+{
+  __cxa_eh_globals *globals = __cxa_get_globals ();
+  __cxa_exception *header = globals->caughtExceptions;
+  if (header)
+    return header->exceptionType;
+  else
+    return 0;
+}
+
+} // namespace __cxxabiv1
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_unex_handler.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_unex_handler.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/eh_unex_handler.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/eh_unex_handler.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,34 @@
+// -*- C++ -*- std::unexpected handler
+// Copyright (C) 2002 Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA. 
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include "unwind-cxx.h"
+
+/* The current installed user handler.  */
+std::unexpected_handler __cxxabiv1::__unexpected_handler = std::terminate;
+
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/exception linux-2.6.9/lib/libstdc++-v3/libsupc++/exception
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/exception	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/exception	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,120 @@
+// Exception Handling support header for -*- C++ -*-
+
+// Copyright (C) 1995, 1996, 1997, 1998, 2000, 2001, 2002
+// Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+// 
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+/** @file exception
+ *  This header defines several types and functions relating to the
+ *  handling of exceptions in a C++ program.
+ */
+
+#ifndef __EXCEPTION__
+#define __EXCEPTION__
+
+extern "C++" {
+
+namespace std 
+{
+  /**
+   *  @brief Base class for all library exceptions.
+   *
+   *  This is the base class for all exceptions thrown by the standard
+   *  library, and by certain language expressions.  You are free to derive
+   *  your own %exception classes, or use a different hierarchy, or to
+   *  throw non-class data (e.g., fundamental types).
+   */
+  class exception 
+  {
+  public:
+    exception() throw() { }
+    virtual ~exception() throw();
+    /** Returns a C-style character string describing the general cause
+     *  of the current error.  */
+    virtual const char* what() const throw();
+  };
+
+  /** If an %exception is thrown which is not listed in a function's
+   *  %exception specification, one of these may be thrown.  */
+  class bad_exception : public exception 
+  {
+  public:
+    bad_exception() throw() { }
+    // This declaration is not useless:
+    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
+    virtual ~bad_exception() throw();
+  };
+
+  /// If you write a replacement %terminate handler, it must be of this type.
+  typedef void (*terminate_handler) ();
+  /// If you write a replacement %unexpected handler, it must be of this type.
+  typedef void (*unexpected_handler) ();
+
+  /// Takes a new handler function as an argument, returns the old function.
+  terminate_handler set_terminate(terminate_handler) throw();
+  /** The runtime will call this function if %exception handling must be
+   *  abandoned for any reason.  It can also be called by the user.  */
+  void terminate() __attribute__ ((__noreturn__));
+
+  /// Takes a new handler function as an argument, returns the old function.
+  unexpected_handler set_unexpected(unexpected_handler) throw();
+  /** The runtime will call this function if an %exception is thrown which
+   *  violates the function's %exception specification.  */
+  void unexpected() __attribute__ ((__noreturn__));
+
+  /** [18.6.4]/1:  "Returns true after completing evaluation of a
+   *  throw-expression until either completing initialization of the
+   *  exception-declaration in the matching handler or entering @c unexpected()
+   *  due to the throw; or after entering @c terminate() for any reason
+   *  other than an explicit call to @c terminate().  [Note: This includes
+   *  stack unwinding [15.2].  end note]"
+   *
+   *  2:  "When @c uncaught_exception() is true, throwing an %exception can
+   *  result in a call of @c terminate() (15.5.1)."
+   */
+  bool uncaught_exception() throw();
+} // namespace std
+
+namespace __gnu_cxx
+{
+  /** A replacement for the standard terminate_handler which prints more
+      information about the terminating exception (if any) on stderr.  Call
+      @code
+        std::set_terminate (__gnu_cxx::__verbose_terminate_handler)
+      @endcode
+      to use.  For more info, see
+      http://gcc.gnu.org/onlinedocs/libstdc++/19_diagnostics/howto.html#4
+
+      In 3.4 and later, this is on by default.
+  */
+  void __verbose_terminate_handler ();
+} // namespace __gnu_cxx
+  
+} // extern "C++"
+
+#endif
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/exception_defines.h linux-2.6.9/lib/libstdc++-v3/libsupc++/exception_defines.h
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/exception_defines.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/exception_defines.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,47 @@
+// -fno-exceptions Support -*- C++ -*-
+
+// Copyright (C) 2001, 2003 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+//
+// ISO C++ 14882: 19.1  Exception classes
+//
+
+#ifndef _EXCEPTION_DEFINES_H
+#define _EXCEPTION_DEFINES_H 1
+
+#ifndef __EXCEPTIONS
+// Iff -fno-exceptions, transform error handling code to work without it.
+# define try      if (true)
+# define catch(X) if (false)
+# define __throw_exception_again
+#else
+// Else proceed normally.
+# define __throw_exception_again throw
+#endif
+
+#endif
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/guard.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/guard.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/guard.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/guard.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,51 @@
+// Copyright (C) 2002 Free Software Foundation, Inc.
+//  
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA. 
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+// Written by Mark Mitchell, CodeSourcery LLC, <mark@codesourcery.com>
+
+#include <cxxabi.h>
+
+namespace __cxxabiv1 
+{
+  extern "C"
+  int __cxa_guard_acquire (__guard *g) 
+  {
+    return !*(char *)(g);
+  }
+
+  extern "C"
+  void __cxa_guard_release (__guard *g)
+  {
+    *(char *)g = 1;
+  }
+
+  extern "C"
+  void __cxa_guard_abort (__guard *)
+  {
+  }
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/libsupcxx_syms.c linux-2.6.9/lib/libstdc++-v3/libsupc++/libsupcxx_syms.c
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/libsupcxx_syms.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/libsupcxx_syms.c	2004-10-29 17:34:16.000000000 +0000
@@ -0,0 +1,44 @@
+#include <linux/module.h>
+
+#define EXPORT(sym) \
+extern void sym (void); \
+EXPORT_SYMBOL(sym)
+
+EXPORT(__cxa_allocate_exception);
+EXPORT(__cxa_free_exception);
+EXPORT(__cxa_bad_typeid);
+EXPORT(__cxa_begin_catch);
+EXPORT(__cxa_end_catch);
+EXPORT(__cxa_pure_virtual);
+EXPORT(__cxa_throw);
+EXPORT(__cxa_rethrow);
+EXPORT(__dynamic_cast);
+EXPORT(__gxx_personality_v0);
+EXPORT(_ZTVN10__cxxabiv117__class_type_infoE);
+EXPORT(_ZTVN10__cxxabiv120__si_class_type_infoE);
+EXPORT(_ZTVN10__cxxabiv121__vmi_class_type_infoE);
+EXPORT(_ZNKSt9type_infoeqERKS_);
+EXPORT(_ZNSt9bad_allocD1Ev);
+EXPORT(_ZTVSt9bad_alloc);
+EXPORT(_ZTISt9bad_alloc);
+EXPORT(_ZTISt10bad_typeid);
+EXPORT(_ZTISt9exception);
+
+EXPORT(_ZTIh);
+EXPORT(_ZTIb);
+EXPORT(_ZTIa);
+EXPORT(_ZTIc);
+EXPORT(_ZTIw);
+EXPORT(_ZTIi);
+EXPORT(_ZTIs);
+EXPORT(_ZTIj);
+EXPORT(_ZTIt);
+EXPORT(_ZTIl);
+EXPORT(_ZTIm);
+EXPORT(_ZTIx);
+EXPORT(_ZTIy);
+
+EXPORT(_Znwj);
+EXPORT(_Znaj);
+EXPORT(_ZdlPv);
+EXPORT(_ZdaPv);
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/Makefile linux-2.6.9/lib/libstdc++-v3/libsupc++/Makefile
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/Makefile	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,19 @@
+#
+# Makefile for C++ runtime library (libsupc++)
+# libsupc++ is imported from gcc-3.4.0
+#
+
+EXTRA_CXXFLAGS	+= -I$(src)/../../gcc -include $(src)/../../gcc/fixdefines.h
+
+
+
+obj-y += test/
+
+obj-$(CONFIG_CXX_RUNTIME)	+= libsupcxx.o
+
+libsupcxx-objs	:= del_op.o del_opnt.o del_opv.o del_opvnt.o \
+	eh_alloc.o eh_aux_runtime.o eh_catch.o eh_exception.o eh_globals.o \
+	eh_personality.o eh_term_handler.o eh_terminate.o eh_throw.o \
+	eh_type.o eh_unex_handler.o guard.o new_handler.o new_op.o \
+	new_opnt.o new_opv.o new_opvnt.o pure.o tinfo2.o tinfo.o vec.o \
+	libsupcxx_syms.o
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/new linux-2.6.9/lib/libstdc++-v3/libsupc++/new
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/new	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/new	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,101 @@
+// The -*- C++ -*- dynamic memory management header.
+
+// Copyright (C) 1994, 1996, 1997, 1998, 2000, 2001, 2002
+// Free Software Foundation
+
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+// 
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+/** @file new
+ *  The header @c new defines several functions to manage dynamic memory and
+ *  handling memory allocation errors; see
+ *  http://gcc.gnu.org/onlinedocs/libstdc++/18_support/howto.html#4 for more.
+ */
+
+#ifndef _NEW
+#define _NEW
+
+#include <cstddef>
+#include <exception>
+
+extern "C++" {
+
+namespace std 
+{
+  /**
+   *  @brief  Exception possibly thrown by @c new.
+   *
+   *  @c bad_alloc (or classes derived from it) is used to report allocation
+   *  errors from the throwing forms of @c new.  */
+  class bad_alloc : public exception 
+  {
+  public:
+    bad_alloc() throw() { }
+    // This declaration is not useless:
+    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
+    virtual ~bad_alloc() throw();
+  };
+
+  struct nothrow_t { };
+  extern const nothrow_t nothrow;
+  /** If you write your own error handler to be called by @c new, it must
+   *  be of this type.  */
+  typedef void (*new_handler)();
+  /// Takes a replacement handler as the argument, returns the previous handler.
+  new_handler set_new_handler(new_handler) throw();
+} // namespace std
+
+//@{
+/** These are replaceable signatures:
+ *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
+ *  - normal array new and delete (same)
+ *  - @c nothrow single new and delete (take a @c nothrow argument, return
+ *    @c NULL on error)
+ *  - @c nothrow array new and delete (same)
+ *
+ *  Placement new and delete signatures (take a memory address argument,
+ *  does nothing) may not be replaced by a user's program.
+*/
+void* operator new(std::size_t) throw (std::bad_alloc);
+void* operator new[](std::size_t) throw (std::bad_alloc);
+void operator delete(void*) throw();
+void operator delete[](void*) throw();
+void* operator new(std::size_t, const std::nothrow_t&) throw();
+void* operator new[](std::size_t, const std::nothrow_t&) throw();
+void operator delete(void*, const std::nothrow_t&) throw();
+void operator delete[](void*, const std::nothrow_t&) throw();
+
+// Default placement versions of operator new.
+inline void* operator new(std::size_t, void* __p) throw() { return __p; }
+inline void* operator new[](std::size_t, void* __p) throw() { return __p; }
+
+// Default placement versions of operator delete.
+inline void  operator delete  (void*, void*) throw() { }
+inline void  operator delete[](void*, void*) throw() { }
+//@}
+} // extern "C++"
+
+#endif
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/new_handler.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/new_handler.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/new_handler.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/new_handler.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,47 @@
+// Implementation file for the -*- C++ -*- dynamic memory management header.
+
+// Copyright (C) 1996, 1997, 1998, 2000, 2001, 2002
+// Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA. 
+//
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include "new"
+
+const std::nothrow_t std::nothrow = { };
+
+using std::new_handler;
+new_handler __new_handler;
+
+new_handler
+std::set_new_handler (new_handler handler) throw()
+{
+  new_handler prev_handler = __new_handler;
+  __new_handler = handler;
+  return prev_handler;
+}
+
+std::bad_alloc::~bad_alloc() throw() { }
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/new_op.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/new_op.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/new_op.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/new_op.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,63 @@
+// Support routines for the -*- C++ -*- dynamic memory management.
+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+//
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include "new"
+#include <cstdlib>
+#include <exception_defines.h>
+
+using std::new_handler;
+using std::bad_alloc;
+using std::malloc;
+
+extern new_handler __new_handler;
+
+void *
+operator new (std::size_t sz) throw (std::bad_alloc)
+{
+  void *p;
+
+  /* malloc (0) is unpredictable; avoid it.  */
+  if (sz == 0)
+    sz = 1;
+  p = (void *) malloc (sz);
+  while (p == 0)
+    {
+      new_handler handler = __new_handler;
+      if (! handler)
+#ifdef __EXCEPTIONS
+	throw bad_alloc();
+#else
+        std::abort();
+#endif
+      handler ();
+      p = (void *) malloc (sz);
+    }
+
+  return p;
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/new_opnt.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/new_opnt.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/new_opnt.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/new_opnt.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,66 @@
+// Support routines for the -*- C++ -*- dynamic memory management.
+// Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+//
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include "new"
+#include <exception_defines.h>
+
+using std::new_handler;
+using std::bad_alloc;
+
+extern "C" void *malloc (std::size_t);
+extern new_handler __new_handler;
+
+void *
+operator new (std::size_t sz, const std::nothrow_t&) throw()
+{
+  void *p;
+
+  /* malloc (0) is unpredictable; avoid it.  */
+  if (sz == 0)
+    sz = 1;
+  p = (void *) malloc (sz);
+  while (p == 0)
+    {
+      new_handler handler = __new_handler;
+      if (! handler)
+	return 0;
+      try
+	{
+	  handler ();
+	}
+      catch (bad_alloc &)
+	{
+	  return 0;
+	}
+
+      p = (void *) malloc (sz);
+    }
+
+  return p;
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/new_opv.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/new_opv.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/new_opv.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/new_opv.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,37 @@
+// Boilerplate support routines for -*- C++ -*- dynamic memory management.
+
+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+//
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include "new"
+
+void *
+operator new[] (std::size_t sz) throw (std::bad_alloc)
+{
+  return ::operator new(sz);
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/new_opvnt.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/new_opvnt.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/new_opvnt.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/new_opvnt.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,37 @@
+// Boilerplate support routines for -*- C++ -*- dynamic memory management.
+
+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+//
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include "new"
+
+void *
+operator new[] (std::size_t sz, const std::nothrow_t& nothrow) throw()
+{
+  return ::operator new(sz, nothrow);
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/pure.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/pure.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/pure.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/pure.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,58 @@
+// -*- C++ -*- 
+// Copyright (C) 2000, 2001 Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+//
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include <bits/c++config.h>
+#include "unwind-cxx.h"
+
+#ifdef __KERNEL__
+// write and fputs are not available in the kernel, use printk instead.
+# include <begin_include.h>
+# include <linux/kernel.h>
+# include <end_include.h>
+
+# define writestr(str) printk(KERN_ERR "%s", str);
+#elif defined(_GLIBCXX_HAVE_UNISTD_H)
+# include <unistd.h>
+# define writestr(str)	write(2, str, sizeof(str) - 1)
+# ifdef __GNU_LIBRARY__
+  /* Avoid forcing the library's meaning of `write' on the user program
+     by using the "internal" name (for use within the library).  */
+/*#  define write(fd, buf, n)	__write((fd), (buf), (n))*/
+# endif
+#else
+# include <cstdio>
+# define writestr(str)	std::fputs(str, stderr)
+#endif
+
+extern "C" void
+__cxa_pure_virtual (void)
+{
+  writestr ("pure virtual method called\n");
+  std::terminate ();
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/test/Makefile linux-2.6.9/lib/libstdc++-v3/libsupc++/test/Makefile
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/test/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/test/Makefile	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,10 @@
+
+
+obj-$(CONFIG_CXX_RUNTIME_TEST) += test_exception.o
+
+obj-$(CONFIG_CXX_RUNTIME_TEST) += test_dynamic_cast.o
+
+test_exception-objs := test_exception_imp.o
+
+test_dynamic_cast-objs := test_dynamic_cast_imp.o
+
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/test/test_dynamic_cast_imp.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/test/test_dynamic_cast_imp.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/test/test_dynamic_cast_imp.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/test/test_dynamic_cast_imp.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,59 @@
+#include <begin_include.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <end_include.h>
+
+
+class A
+{
+public:
+	virtual void speak();	
+};
+
+void A::speak() { printk("Class A is speaking!\n");}
+
+class B : public A
+{
+public:
+	virtual void speak();	
+};
+
+void B::speak() { printk("Class B is speaking!\n");}
+
+
+void doDynamicCast(A* a)
+{
+   B* b = dynamic_cast<B*>(a);
+   if(b)
+   {
+   	  printk("Dynamic cast succeeded\n");
+   }
+   else
+   {
+   	  printk("Dynamic cast did not succeed\n");
+   }	
+}
+
+void testDynamicCast()
+{
+   B b;
+   doDynamicCast(&b);
+}
+
+extern "C" {
+static int __init test_dynamic_cast_init()
+{
+   printk("Exception dynamic_cast installed\n");
+   testDynamicCast();
+   return 0;
+}
+
+static void __exit test_dynamic_cast_fini()
+{
+    printk("Exception dynamic_cast removed\n");
+}
+
+module_init(test_dynamic_cast_init);
+module_exit(test_dynamic_cast_fini);
+}
\ No newline at end of file
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/test/test_exception_imp.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/test/test_exception_imp.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/test/test_exception_imp.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/test/test_exception_imp.cc	2004-10-29 17:31:40.000000000 +0000
@@ -0,0 +1,90 @@
+#include <begin_include.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <end_include.h>
+
+
+class A
+{
+public:
+	A(){printk("Constructor class A\n");}
+	~A(){printk("Destructor class A\n");}
+	virtual void speak();	
+};
+
+A globalobject;
+
+void A::speak() { printk("Class A is speaking!\n");}
+
+void throwInteger()
+{
+   throw 3;	
+}
+
+void throwObject()
+{
+	throw A();
+}
+
+void doReThrow2()
+{
+    throw;	
+}
+
+void doReThrow()
+{
+	A a;
+    doReThrow2();	
+}
+
+void testInteger()
+{
+   try
+   {
+   	  throwInteger();
+   }
+   catch(int i)
+   {
+   	   printk("Caught integer %u\n",i);
+   	   try
+   	   {
+   	   	  doReThrow();
+   	   }
+   	   catch(int j)
+   	   {
+   	   	  printk("Rethrow works!\n");
+   	   }
+   }	
+}
+
+void testObject()
+{
+   try
+   {
+   	  throwObject();
+   }
+   catch(A& ob)
+   {
+   	   printk("Caught object\n");
+   	   ob.speak();   	   
+   }	
+}
+
+extern "C" {
+static int __init test_exception_init()
+{
+   printk("Exception test module installed\n");
+   testInteger();
+   testObject();
+   return 0;
+}
+
+static void __exit test_exception_fini()
+{
+    printk("Exception test module removed\n");
+}
+
+module_init(test_exception_init);
+module_exit(test_exception_fini);
+}
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/tinfo2.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/tinfo2.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/tinfo2.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/tinfo2.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,172 @@
+// Methods for type_info for -*- C++ -*- Run Time Type Identification.
+
+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002
+// Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA. 
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include <cstddef>
+#include "tinfo.h"
+#include "new"			// for placement new
+
+// We can't rely on having stdlib.h if we're freestanding.
+extern "C" void abort ();
+
+using std::type_info;
+
+#if !__GXX_MERGED_TYPEINFO_NAMES
+
+bool
+type_info::before (const type_info &arg) const
+{
+  return __builtin_strcmp (name (), arg.name ()) < 0;
+}
+#else
+bool
+type_info::before (const type_info &arg) const
+{ 
+	return __name < arg.__name; 
+}
+#endif
+
+#include <cxxabi.h>
+
+namespace __cxxabiv1 {
+
+using namespace std;
+
+// This has special meaning to the compiler, and will cause it
+// to emit the type_info structures for the fundamental types which are
+// mandated to exist in the runtime.
+__fundamental_type_info::
+~__fundamental_type_info ()
+{}
+
+__array_type_info::
+~__array_type_info ()
+{}
+
+__function_type_info::
+~__function_type_info ()
+{}
+
+__enum_type_info::
+~__enum_type_info ()
+{}
+
+__pbase_type_info::
+~__pbase_type_info ()
+{}
+
+__pointer_type_info::
+~__pointer_type_info ()
+{}
+
+__pointer_to_member_type_info::
+~__pointer_to_member_type_info ()
+{}
+
+bool __pointer_type_info::
+__is_pointer_p () const
+{
+  return true;
+}
+
+bool __function_type_info::
+__is_function_p () const
+{
+  return true;
+}
+
+bool __pbase_type_info::
+__do_catch (const type_info *thr_type,
+            void **thr_obj,
+            unsigned outer) const
+{
+  if (*this == *thr_type)
+    return true;      // same type
+  if (typeid (*this) != typeid (*thr_type))
+    return false;     // not both same kind of pointers
+  
+  if (!(outer & 1))
+    // We're not the same and our outer pointers are not all const qualified
+    // Therefore there must at least be a qualification conversion involved
+    // But for that to be valid, our outer pointers must be const qualified.
+    return false;
+  
+  const __pbase_type_info *thrown_type =
+    static_cast <const __pbase_type_info *> (thr_type);
+  
+  if (thrown_type->__flags & ~__flags)
+    // We're less qualified.
+    return false;
+  
+  if (!(__flags & __const_mask))
+    outer &= ~1;
+  
+  return __pointer_catch (thrown_type, thr_obj, outer);
+}
+
+inline bool __pbase_type_info::
+__pointer_catch (const __pbase_type_info *thrown_type,
+                 void **thr_obj,
+                 unsigned outer) const
+{
+  return __pointee->__do_catch (thrown_type->__pointee, thr_obj, outer + 2);
+}
+
+bool __pointer_type_info::
+__pointer_catch (const __pbase_type_info *thrown_type,
+                 void **thr_obj,
+                 unsigned outer) const
+{
+  if (outer < 2 && *__pointee == typeid (void))
+    {
+      // conversion to void
+      return !thrown_type->__pointee->__is_function_p ();
+    }
+  
+  return __pbase_type_info::__pointer_catch (thrown_type, thr_obj, outer);
+}
+
+bool __pointer_to_member_type_info::
+__pointer_catch (const __pbase_type_info *thr_type,
+                 void **thr_obj,
+                 unsigned outer) const
+{
+  // This static cast is always valid, as our caller will have determined that
+  // thr_type is really a __pointer_to_member_type_info.
+  const __pointer_to_member_type_info *thrown_type =
+    static_cast <const __pointer_to_member_type_info *> (thr_type);
+  
+  if (*__context != *thrown_type->__context)
+    return false;     // not pointers to member of same class
+  
+  return __pbase_type_info::__pointer_catch (thrown_type, thr_obj, outer);
+}
+
+} // namespace std
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/tinfo.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/tinfo.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/tinfo.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/tinfo.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,745 @@
+// Methods for type_info for -*- C++ -*- Run Time Type Identification.
+// Copyright (C) 1994, 1996, 1998, 1999, 2000, 2001, 2002, 2003
+// Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA. 
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#include <bits/c++config.h>
+#include <cstddef>
+#include "tinfo.h"
+#include "new"			// for placement new
+
+// This file contains the minimal working set necessary to link with code
+// that uses virtual functions and -frtti but does not actually use RTTI
+// functionality.
+
+std::type_info::
+~type_info ()
+{ }
+
+std::bad_cast::~bad_cast() throw() { }
+std::bad_typeid::~bad_typeid() throw() { }
+
+#if !__GXX_MERGED_TYPEINFO_NAMES
+
+// We can't rely on common symbols being shared between shared objects.
+bool std::type_info::
+operator== (const std::type_info& arg) const
+{
+  return (&arg == this) || (__builtin_strcmp (name (), arg.name ()) == 0);
+}
+#else
+
+bool std::type_info::
+operator== (const std::type_info& arg) const
+{ 
+	return __name == arg.__name; 
+}
+#endif
+
+namespace std {
+
+// return true if this is a type_info for a pointer type
+bool type_info::
+__is_pointer_p () const
+{
+  return false;
+}
+
+// return true if this is a type_info for a function type
+bool type_info::
+__is_function_p () const
+{
+  return false;
+}
+
+// try and catch a thrown object.
+bool type_info::
+__do_catch (const type_info *thr_type, void **, unsigned) const
+{
+  return *this == *thr_type;
+}
+
+// upcast from this type to the target. __class_type_info will override
+bool type_info::
+__do_upcast (const abi::__class_type_info *, void **) const
+{
+  return false;
+}
+
+}
+
+namespace {
+
+using namespace std;
+using namespace abi;
+
+// Initial part of a vtable, this structure is used with offsetof, so we don't
+// have to keep alignments consistent manually.
+struct vtable_prefix 
+{
+  // Offset to most derived object.
+  ptrdiff_t whole_object;
+
+  // Additional padding if necessary.
+#ifdef _GLIBCXX_VTABLE_PADDING
+  ptrdiff_t padding1;               
+#endif
+
+  // Pointer to most derived type_info.
+  const __class_type_info *whole_type;  
+
+  // Additional padding if necessary.
+#ifdef _GLIBCXX_VTABLE_PADDING
+  ptrdiff_t padding2;               
+#endif
+
+  // What a class's vptr points to.
+  const void *origin;               
+};
+
+template <typename T>
+inline const T *
+adjust_pointer (const void *base, ptrdiff_t offset)
+{
+  return reinterpret_cast <const T *>
+    (reinterpret_cast <const char *> (base) + offset);
+}
+
+// ADDR is a pointer to an object.  Convert it to a pointer to a base,
+// using OFFSET. IS_VIRTUAL is true, if we are getting a virtual base.
+inline void const *
+convert_to_base (void const *addr, bool is_virtual, ptrdiff_t offset)
+{
+  if (is_virtual)
+    {
+      const void *vtable = *static_cast <const void *const *> (addr);
+      
+      offset = *adjust_pointer<ptrdiff_t> (vtable, offset);
+    }
+
+  return adjust_pointer<void> (addr, offset);
+}
+
+// some predicate functions for __class_type_info::__sub_kind
+inline bool contained_p (__class_type_info::__sub_kind access_path)
+{
+  return access_path >= __class_type_info::__contained_mask;
+}
+inline bool public_p (__class_type_info::__sub_kind access_path)
+{
+  return access_path & __class_type_info::__contained_public_mask;
+}
+inline bool virtual_p (__class_type_info::__sub_kind access_path)
+{
+  return (access_path & __class_type_info::__contained_virtual_mask);
+}
+inline bool contained_public_p (__class_type_info::__sub_kind access_path)
+{
+  return ((access_path & __class_type_info::__contained_public)
+          == __class_type_info::__contained_public);
+}
+inline bool contained_nonpublic_p (__class_type_info::__sub_kind access_path)
+{
+  return ((access_path & __class_type_info::__contained_public)
+          == __class_type_info::__contained_mask);
+}
+inline bool contained_nonvirtual_p (__class_type_info::__sub_kind access_path)
+{
+  return ((access_path & (__class_type_info::__contained_mask
+                          | __class_type_info::__contained_virtual_mask))
+          == __class_type_info::__contained_mask);
+}
+
+static const __class_type_info *const nonvirtual_base_type =
+    static_cast <const __class_type_info *> (0) + 1;
+
+} // namespace
+
+namespace __cxxabiv1
+{
+
+__class_type_info::
+~__class_type_info ()
+{}
+
+__si_class_type_info::
+~__si_class_type_info ()
+{}
+
+__vmi_class_type_info::
+~__vmi_class_type_info ()
+{}
+
+// __upcast_result is used to hold information during traversal of a class
+// hierarchy when catch matching.
+struct __class_type_info::__upcast_result
+{
+  const void *dst_ptr;        // pointer to caught object
+  __sub_kind part2dst;        // path from current base to target
+  int src_details;            // hints about the source type hierarchy
+  const __class_type_info *base_type; // where we found the target,
+                              // if in vbase the __class_type_info of vbase
+                              // if a non-virtual base then 1
+                              // else NULL
+  public:
+  __upcast_result (int d)
+    :dst_ptr (NULL), part2dst (__unknown), src_details (d), base_type (NULL)
+    {}
+};
+
+// __dyncast_result is used to hold information during traversal of a class
+// hierarchy when dynamic casting.
+struct __class_type_info::__dyncast_result
+{
+  const void *dst_ptr;        // pointer to target object or NULL
+  __sub_kind whole2dst;       // path from most derived object to target
+  __sub_kind whole2src;       // path from most derived object to sub object
+  __sub_kind dst2src;         // path from target to sub object
+  int whole_details;          // details of the whole class hierarchy
+  
+  public:
+  __dyncast_result (int details_ = __vmi_class_type_info::__flags_unknown_mask)
+    :dst_ptr (NULL), whole2dst (__unknown),
+     whole2src (__unknown), dst2src (__unknown),
+     whole_details (details_)
+    {}
+};
+
+bool __class_type_info::
+__do_catch (const type_info *thr_type,
+            void **thr_obj,
+            unsigned outer) const
+{
+  if (*this == *thr_type)
+    return true;
+  if (outer >= 4)
+    // Neither `A' nor `A *'.
+    return false;
+  return thr_type->__do_upcast (this, thr_obj);
+}
+
+bool __class_type_info::
+__do_upcast (const __class_type_info *dst_type,
+             void **obj_ptr) const
+{
+  __upcast_result result (__vmi_class_type_info::__flags_unknown_mask);
+  
+  __do_upcast (dst_type, *obj_ptr, result);
+  if (!contained_public_p (result.part2dst))
+    return false;
+  *obj_ptr = const_cast <void *> (result.dst_ptr);
+  return true;
+}
+
+inline __class_type_info::__sub_kind __class_type_info::
+__find_public_src (ptrdiff_t src2dst,
+                   const void *obj_ptr,
+                   const __class_type_info *src_type,
+                   const void *src_ptr) const
+{
+  if (src2dst >= 0)
+    return adjust_pointer <void> (obj_ptr, src2dst) == src_ptr
+            ? __contained_public : __not_contained;
+  if (src2dst == -2)
+    return __not_contained;
+  return __do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);
+}
+
+__class_type_info::__sub_kind __class_type_info::
+__do_find_public_src (ptrdiff_t,
+                      const void *obj_ptr,
+                      const __class_type_info *,
+                      const void *src_ptr) const
+{
+  if (src_ptr == obj_ptr)
+    // Must be our type, as the pointers match.
+    return __contained_public;
+  return __not_contained;
+}
+
+__class_type_info::__sub_kind __si_class_type_info::
+__do_find_public_src (ptrdiff_t src2dst,
+                      const void *obj_ptr,
+                      const __class_type_info *src_type,
+                      const void *src_ptr) const
+{
+  if (src_ptr == obj_ptr && *this == *src_type)
+    return __contained_public;
+  return __base_type->__do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);
+}
+
+__class_type_info::__sub_kind __vmi_class_type_info::
+__do_find_public_src (ptrdiff_t src2dst,
+                      const void *obj_ptr,
+                      const __class_type_info *src_type,
+                      const void *src_ptr) const
+{
+  if (obj_ptr == src_ptr && *this == *src_type)
+    return __contained_public;
+  
+  for (std::size_t i = __base_count; i--;)
+    {
+      if (!__base_info[i].__is_public_p ())
+        continue; // Not public, can't be here.
+      
+      const void *base = obj_ptr;
+      ptrdiff_t offset = __base_info[i].__offset ();
+      bool is_virtual = __base_info[i].__is_virtual_p ();
+      
+      if (is_virtual)
+        {
+          if (src2dst == -3)
+            continue; // Not a virtual base, so can't be here.
+        }
+      base = convert_to_base (base, is_virtual, offset);
+      
+      __sub_kind base_kind = __base_info[i].__base_type->__do_find_public_src
+                              (src2dst, base, src_type, src_ptr);
+      if (contained_p (base_kind))
+        {
+          if (is_virtual)
+            base_kind = __sub_kind (base_kind | __contained_virtual_mask);
+          return base_kind;
+        }
+    }
+  
+  return __not_contained;
+}
+
+bool __class_type_info::
+__do_dyncast (ptrdiff_t,
+              __sub_kind access_path,
+              const __class_type_info *dst_type,
+              const void *obj_ptr,
+              const __class_type_info *src_type,
+              const void *src_ptr,
+              __dyncast_result &__restrict result) const
+{
+  if (obj_ptr == src_ptr && *this == *src_type)
+    {
+      // The src object we started from. Indicate how we are accessible from
+      // the most derived object.
+      result.whole2src = access_path;
+      return false;
+    }
+  if (*this == *dst_type)
+    {
+      result.dst_ptr = obj_ptr;
+      result.whole2dst = access_path;
+      result.dst2src = __not_contained;
+      return false;
+    }
+  return false;
+}
+
+bool __si_class_type_info::
+__do_dyncast (ptrdiff_t src2dst,
+              __sub_kind access_path,
+              const __class_type_info *dst_type,
+              const void *obj_ptr,
+              const __class_type_info *src_type,
+              const void *src_ptr,
+              __dyncast_result &__restrict result) const
+{
+  if (*this == *dst_type)
+    {
+      result.dst_ptr = obj_ptr;
+      result.whole2dst = access_path;
+      if (src2dst >= 0)
+        result.dst2src = adjust_pointer <void> (obj_ptr, src2dst) == src_ptr
+              ? __contained_public : __not_contained;
+      else if (src2dst == -2)
+        result.dst2src = __not_contained;
+      return false;
+    }
+  if (obj_ptr == src_ptr && *this == *src_type)
+    {
+      // The src object we started from. Indicate how we are accessible from
+      // the most derived object.
+      result.whole2src = access_path;
+      return false;
+    }
+  return __base_type->__do_dyncast (src2dst, access_path, dst_type, obj_ptr,
+                             src_type, src_ptr, result);
+}
+
+// This is a big hairy function. Although the run-time behaviour of
+// dynamic_cast is simple to describe, it gives rise to some non-obvious
+// behaviour. We also desire to determine as early as possible any definite
+// answer we can get. Because it is unknown what the run-time ratio of
+// succeeding to failing dynamic casts is, we do not know in which direction
+// to bias any optimizations. To that end we make no particular effort towards
+// early fail answers or early success answers. Instead we try to minimize
+// work by filling in things lazily (when we know we need the information),
+// and opportunisticly take early success or failure results.
+bool __vmi_class_type_info::
+__do_dyncast (ptrdiff_t src2dst,
+              __sub_kind access_path,
+              const __class_type_info *dst_type,
+              const void *obj_ptr,
+              const __class_type_info *src_type,
+              const void *src_ptr,
+              __dyncast_result &__restrict result) const
+{
+  if (result.whole_details & __flags_unknown_mask)
+    result.whole_details = __flags;
+  
+  if (obj_ptr == src_ptr && *this == *src_type)
+    {
+      // The src object we started from. Indicate how we are accessible from
+      // the most derived object.
+      result.whole2src = access_path;
+      return false;
+    }
+  if (*this == *dst_type)
+    {
+      result.dst_ptr = obj_ptr;
+      result.whole2dst = access_path;
+      if (src2dst >= 0)
+        result.dst2src = adjust_pointer <void> (obj_ptr, src2dst) == src_ptr
+              ? __contained_public : __not_contained;
+      else if (src2dst == -2)
+        result.dst2src = __not_contained;
+      return false;
+    }
+
+  bool result_ambig = false;
+  for (std::size_t i = __base_count; i--;)
+    {
+      __dyncast_result result2 (result.whole_details);
+      void const *base = obj_ptr;
+      __sub_kind base_access = access_path;
+      ptrdiff_t offset = __base_info[i].__offset ();
+      bool is_virtual = __base_info[i].__is_virtual_p ();
+      
+      if (is_virtual)
+        base_access = __sub_kind (base_access | __contained_virtual_mask);
+      base = convert_to_base (base, is_virtual, offset);
+
+      if (!__base_info[i].__is_public_p ())
+        {
+          if (src2dst == -2 &&
+              !(result.whole_details
+                & (__non_diamond_repeat_mask | __diamond_shaped_mask)))
+            // The hierarchy has no duplicate bases (which might ambiguate
+            // things) and where we started is not a public base of what we
+            // want (so it cannot be a downcast). There is nothing of interest
+            // hiding in a non-public base.
+            continue;
+          base_access = __sub_kind (base_access & ~__contained_public_mask);
+        }
+      
+      bool result2_ambig
+          = __base_info[i].__base_type->__do_dyncast (src2dst, base_access,
+                                             dst_type, base,
+                                             src_type, src_ptr, result2);
+      result.whole2src = __sub_kind (result.whole2src | result2.whole2src);
+      if (result2.dst2src == __contained_public
+          || result2.dst2src == __contained_ambig)
+        {
+          result.dst_ptr = result2.dst_ptr;
+          result.whole2dst = result2.whole2dst;
+          result.dst2src = result2.dst2src;
+          // Found a downcast which can't be bettered or an ambiguous downcast
+          // which can't be disambiguated
+          return result2_ambig;
+        }
+      
+      if (!result_ambig && !result.dst_ptr)
+        {
+          // Not found anything yet.
+          result.dst_ptr = result2.dst_ptr;
+          result.whole2dst = result2.whole2dst;
+          result_ambig = result2_ambig;
+          if (result.dst_ptr && result.whole2src != __unknown
+              && !(__flags & __non_diamond_repeat_mask))
+            // Found dst and src and we don't have repeated bases.
+            return result_ambig;
+        }
+      else if (result.dst_ptr && result.dst_ptr == result2.dst_ptr)
+        {
+          // Found at same address, must be via virtual.  Pick the most
+          // accessible path.
+          result.whole2dst =
+              __sub_kind (result.whole2dst | result2.whole2dst);
+        }
+      else if ((result.dst_ptr != 0 & result2.dst_ptr != 0)
+	       || (result.dst_ptr != 0 & result2_ambig)
+	       || (result2.dst_ptr != 0 & result_ambig))
+        {
+          // Found two different DST_TYPE bases, or a valid one and a set of
+          // ambiguous ones, must disambiguate. See whether SRC_PTR is
+          // contained publicly within one of the non-ambiguous choices. If it
+          // is in only one, then that's the choice. If it is in both, then
+          // we're ambiguous and fail. If it is in neither, we're ambiguous,
+          // but don't yet fail as we might later find a third base which does
+          // contain SRC_PTR.
+        
+          __sub_kind new_sub_kind = result2.dst2src;
+          __sub_kind old_sub_kind = result.dst2src;
+          
+          if (contained_p (result.whole2src)
+              && (!virtual_p (result.whole2src)
+                  || !(result.whole_details & __diamond_shaped_mask)))
+            {
+              // We already found SRC_PTR as a base of most derived, and
+              // either it was non-virtual, or the whole hierarchy is
+              // not-diamond shaped. Therefore if it is in either choice, it
+              // can only be in one of them, and we will already know.
+              if (old_sub_kind == __unknown)
+                old_sub_kind = __not_contained;
+              if (new_sub_kind == __unknown)
+                new_sub_kind = __not_contained;
+            }
+          else
+            {
+              if (old_sub_kind >= __not_contained)
+                ;// already calculated
+              else if (contained_p (new_sub_kind)
+                       && (!virtual_p (new_sub_kind)
+                           || !(__flags & __diamond_shaped_mask)))
+                // Already found inside the other choice, and it was
+                // non-virtual or we are not diamond shaped.
+                old_sub_kind = __not_contained;
+              else
+                old_sub_kind = dst_type->__find_public_src
+                                (src2dst, result.dst_ptr, src_type, src_ptr);
+          
+              if (new_sub_kind >= __not_contained)
+                ;// already calculated
+              else if (contained_p (old_sub_kind)
+                       && (!virtual_p (old_sub_kind)
+                           || !(__flags & __diamond_shaped_mask)))
+                // Already found inside the other choice, and it was
+                // non-virtual or we are not diamond shaped.
+                new_sub_kind = __not_contained;
+              else
+                new_sub_kind = dst_type->__find_public_src
+                                (src2dst, result2.dst_ptr, src_type, src_ptr);
+            }
+          
+          // Neither sub_kind can be contained_ambig -- we bail out early
+          // when we find those.
+          if (contained_p (__sub_kind (new_sub_kind ^ old_sub_kind)))
+            {
+              // Only on one choice, not ambiguous.
+              if (contained_p (new_sub_kind))
+                {
+                  // Only in new.
+                  result.dst_ptr = result2.dst_ptr;
+                  result.whole2dst = result2.whole2dst;
+                  result_ambig = false;
+                  old_sub_kind = new_sub_kind;
+                }
+              result.dst2src = old_sub_kind;
+              if (public_p (result.dst2src))
+                return false; // Can't be an ambiguating downcast for later discovery.
+              if (!virtual_p (result.dst2src))
+                return false; // Found non-virtually can't be bettered
+            }
+          else if (contained_p (__sub_kind (new_sub_kind & old_sub_kind)))
+            {
+              // In both.
+              result.dst_ptr = NULL;
+              result.dst2src = __contained_ambig;
+              return true;  // Fail.
+            }
+          else
+            {
+              // In neither publicly, ambiguous for the moment, but keep
+              // looking. It is possible that it was private in one or
+              // both and therefore we should fail, but that's just tough.
+              result.dst_ptr = NULL;
+              result.dst2src = __not_contained;
+              result_ambig = true;
+            }
+        }
+      
+      if (result.whole2src == __contained_private)
+        // We found SRC_PTR as a private non-virtual base, therefore all
+        // cross casts will fail. We have already found a down cast, if
+        // there is one.
+        return result_ambig;
+    }
+
+  return result_ambig;
+}
+
+bool __class_type_info::
+__do_upcast (const __class_type_info *dst, const void *obj,
+             __upcast_result &__restrict result) const
+{
+  if (*this == *dst)
+    {
+      result.dst_ptr = obj;
+      result.base_type = nonvirtual_base_type;
+      result.part2dst = __contained_public;
+      return true;
+    }
+  return false;
+}
+
+bool __si_class_type_info::
+__do_upcast (const __class_type_info *dst, const void *obj_ptr,
+             __upcast_result &__restrict result) const
+{
+  if (__class_type_info::__do_upcast (dst, obj_ptr, result))
+    return true;
+  
+  return __base_type->__do_upcast (dst, obj_ptr, result);
+}
+
+bool __vmi_class_type_info::
+__do_upcast (const __class_type_info *dst, const void *obj_ptr,
+             __upcast_result &__restrict result) const
+{
+  if (__class_type_info::__do_upcast (dst, obj_ptr, result))
+    return true;
+  
+  int src_details = result.src_details;
+  if (src_details & __flags_unknown_mask)
+    src_details = __flags;
+  
+  for (std::size_t i = __base_count; i--;)
+    {
+      __upcast_result result2 (src_details);
+      const void *base = obj_ptr;
+      ptrdiff_t offset = __base_info[i].__offset ();
+      bool is_virtual = __base_info[i].__is_virtual_p ();
+      bool is_public = __base_info[i].__is_public_p ();
+      
+      if (!is_public && !(src_details & __non_diamond_repeat_mask))
+        // original cannot have an ambiguous base, so skip private bases
+        continue;
+
+      if (base)
+        base = convert_to_base (base, is_virtual, offset);
+      
+      if (__base_info[i].__base_type->__do_upcast (dst, base, result2))
+        {
+          if (result2.base_type == nonvirtual_base_type && is_virtual)
+            result2.base_type = __base_info[i].__base_type;
+          if (contained_p (result2.part2dst) && !is_public)
+            result2.part2dst = __sub_kind (result2.part2dst & ~__contained_public_mask);
+          
+          if (!result.base_type)
+            {
+              result = result2;
+              if (!contained_p (result.part2dst))
+                return true; // found ambiguously
+              
+              if (result.part2dst & __contained_public_mask)
+                {
+                  if (!(__flags & __non_diamond_repeat_mask))
+                    return true;  // cannot have an ambiguous other base
+                }
+              else
+                {
+                  if (!virtual_p (result.part2dst))
+                    return true; // cannot have another path
+                  if (!(__flags & __diamond_shaped_mask))
+                    return true; // cannot have a more accessible path
+                }
+            }
+          else if (result.dst_ptr != result2.dst_ptr)
+            {
+              // Found an ambiguity.
+	      result.dst_ptr = NULL;
+	      result.part2dst = __contained_ambig;
+	      return true;
+            }
+          else if (result.dst_ptr)
+            {
+              // Ok, found real object via a virtual path.
+              result.part2dst
+                  = __sub_kind (result.part2dst | result2.part2dst);
+            }
+          else
+            {
+              // Dealing with a null pointer, need to check vbase
+              // containing each of the two choices.
+              if (result2.base_type == nonvirtual_base_type
+                  || result.base_type == nonvirtual_base_type
+                  || !(*result2.base_type == *result.base_type))
+                {
+                  // Already ambiguous, not virtual or via different virtuals.
+                  // Cannot match.
+                  result.part2dst = __contained_ambig;
+                  return true;
+                }
+              result.part2dst
+                  = __sub_kind (result.part2dst | result2.part2dst);
+            }
+        }
+    }
+  return result.part2dst != __unknown;
+}
+
+// this is the external interface to the dynamic cast machinery
+extern "C" void *
+__dynamic_cast (const void *src_ptr,    // object started from
+                const __class_type_info *src_type, // type of the starting object
+                const __class_type_info *dst_type, // desired target type
+                ptrdiff_t src2dst) // how src and dst are related
+{
+  const void *vtable = *static_cast <const void *const *> (src_ptr);
+  const vtable_prefix *prefix =
+      adjust_pointer <vtable_prefix> (vtable, 
+				      -offsetof (vtable_prefix, origin));
+  const void *whole_ptr =
+      adjust_pointer <void> (src_ptr, prefix->whole_object);
+  const __class_type_info *whole_type = prefix->whole_type;
+  __class_type_info::__dyncast_result result;
+  
+  whole_type->__do_dyncast (src2dst, __class_type_info::__contained_public,
+                            dst_type, whole_ptr, src_type, src_ptr, result);
+  if (!result.dst_ptr)
+    return NULL;
+  if (contained_public_p (result.dst2src))
+    // Src is known to be a public base of dst.
+    return const_cast <void *> (result.dst_ptr);
+  if (contained_public_p (__class_type_info::__sub_kind (result.whole2src & result.whole2dst)))
+    // Both src and dst are known to be public bases of whole. Found a valid
+    // cross cast.
+    return const_cast <void *> (result.dst_ptr);
+  if (contained_nonvirtual_p (result.whole2src))
+    // Src is known to be a non-public nonvirtual base of whole, and not a
+    // base of dst. Found an invalid cross cast, which cannot also be a down
+    // cast
+    return NULL;
+  if (result.dst2src == __class_type_info::__unknown)
+    result.dst2src = dst_type->__find_public_src (src2dst, result.dst_ptr,
+                                                  src_type, src_ptr);
+  if (contained_public_p (result.dst2src))
+    // Found a valid down cast
+    return const_cast <void *> (result.dst_ptr);
+  // Must be an invalid down cast, or the cross cast wasn't bettered
+  return NULL;
+}
+
+} // namespace __cxxabiv1
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/tinfo.h linux-2.6.9/lib/libstdc++-v3/libsupc++/tinfo.h
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/tinfo.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/tinfo.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,10 @@
+// RTTI support internals for -*- C++ -*-
+// Copyright (C) 1994, 1995, 1996, 1998, 1999, 2000, 2001 
+// Free Software Foundation
+
+#include "typeinfo"
+#include <cstddef>
+
+// Class declarations shared between the typeinfo implementation files.
+
+#include <cxxabi.h>
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/typeinfo linux-2.6.9/lib/libstdc++-v3/libsupc++/typeinfo
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/typeinfo	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/typeinfo	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,157 @@
+// RTTI support for -*- C++ -*-
+// Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002
+// Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+// 
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+// 
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+/** @file typeinfo
+ *  This header provides RTTI support.
+ */
+
+#ifndef _TYPEINFO
+#define _TYPEINFO
+
+#include <exception>
+
+extern "C++" {
+
+namespace __cxxabiv1
+{
+  class __class_type_info;
+} // namespace __cxxabiv1
+
+// Even though the compiler supports weak symbols on linux, the module
+// loader doesn't merge symbols from modules with symbols from the kernel
+// or other modules, so use strcmp for typeinfo comparisons.
+#if !__GXX_WEAK__
+  // If weak symbols are not supported, typeinfo names are not merged.
+  #define __GXX_MERGED_TYPEINFO_NAMES 0
+#else
+  // On platforms that support weak symbols, typeinfo names are merged.
+  #define __GXX_MERGED_TYPEINFO_NAMES 1
+#endif
+
+namespace std 
+{
+  /**
+   *  @brief  Part of RTTI.
+   *
+   *  The @c type_info class describes type information generated by
+   *  an implementation.
+  */
+  class type_info 
+  {
+  public:
+    /** Destructor. Being the first non-inline virtual function, this
+     *  controls in which translation unit the vtable is emitted. The
+     *  compiler makes use of that information to know where to emit
+     *  the runtime-mandated type_info structures in the new-abi.  */
+    virtual ~type_info();
+
+  private:
+    /// Assigning type_info is not supported.  Made private.
+    type_info& operator=(const type_info&);
+    type_info(const type_info&);
+    
+  protected:
+    const char *__name;
+    
+  protected:
+    explicit type_info(const char *__n): __name(__n) { }
+    
+  public:
+    // the public interface
+    /** Returns an @e implementation-defined byte string; this is not
+     *  portable between compilers!  */
+    const char* name() const
+    { return __name; }
+
+#if !__GXX_MERGED_TYPEINFO_NAMES
+    bool before(const type_info& __arg) const;
+    // In old abi, or when weak symbols are not supported, there can
+    // be multiple instances of a type_info object for one
+    // type. Uniqueness must use the _name value, not object address.
+    bool operator==(const type_info& __arg) const;
+#else
+    /** Returns true if @c *this precedes @c __arg in the implementation's
+     *  collation order.  */
+    // In new abi we can rely on type_info's NTBS being unique,
+    // and therefore address comparisons are sufficient.
+    bool before(const type_info& __arg) const;
+    bool operator==(const type_info& __arg) const;
+#endif
+    bool operator!=(const type_info& __arg) const
+    { return !operator==(__arg); }
+    
+    // the internal interface
+  public:
+    // return true if this is a pointer type of some kind
+    virtual bool __is_pointer_p() const;
+    // return true if this is a function type
+    virtual bool __is_function_p() const;
+
+    // Try and catch a thrown type. Store an adjusted pointer to the
+    // caught type in THR_OBJ. If THR_TYPE is not a pointer type, then
+    // THR_OBJ points to the thrown object. If THR_TYPE is a pointer
+    // type, then THR_OBJ is the pointer itself. OUTER indicates the
+    // number of outer pointers, and whether they were const
+    // qualified.
+    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
+			    unsigned __outer) const;
+
+    // internally used during catch matching
+    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
+			     void **__obj_ptr) const;
+  };
+
+  /**
+   *  @brief  Thrown during incorrect typecasting.
+   *
+   *  If you attempt an invalid @c dynamic_cast expression, an instance of
+   *  this class (or something derived from this class) is thrown.  */
+  class bad_cast : public exception 
+  {
+  public:
+    bad_cast() throw() { }
+    // This declaration is not useless:
+    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
+    virtual ~bad_cast() throw();
+  };
+  
+  /** If you use a NULL pointer in a @c typeid expression, this is thrown.  */
+  class bad_typeid : public exception 
+  {
+  public:
+    bad_typeid () throw() { }
+    // This declaration is not useless:
+    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
+    virtual ~bad_typeid() throw();
+  };
+} // namespace std
+
+} // extern "C++"
+#endif
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/unwind-cxx.h linux-2.6.9/lib/libstdc++-v3/libsupc++/unwind-cxx.h
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/unwind-cxx.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/unwind-cxx.h	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,171 @@
+// -*- C++ -*- Exception handling and frame unwind runtime interface routines.
+// Copyright (C) 2001 Free Software Foundation, Inc.
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+// This is derived from the C++ ABI for IA-64.  Where we diverge
+// for cross-architecture compatibility are noted with "@@@".
+
+#ifndef _UNWIND_CXX_H
+#define _UNWIND_CXX_H 1
+
+// Level 2: C++ ABI
+
+#include <typeinfo>
+#include <exception>
+#include <cstddef>
+#include "unwind.h"
+
+namespace __cxxabiv1
+{
+
+// A C++ exception object consists of a header, which is a wrapper around
+// an unwind object header with additional C++ specific information,
+// followed by the exception object itself.
+
+struct __cxa_exception
+{ 
+  // Manage the exception object itself.
+  std::type_info *exceptionType;
+  void (*exceptionDestructor)(void *); 
+
+  // The C++ standard has entertaining rules wrt calling set_terminate
+  // and set_unexpected in the middle of the exception cleanup process.
+  std::unexpected_handler unexpectedHandler;
+  std::terminate_handler terminateHandler;
+
+  // The caught exception stack threads through here.
+  __cxa_exception *nextException;
+
+  // How many nested handlers have caught this exception.  A negated
+  // value is a signal that this object has been rethrown.
+  int handlerCount;
+
+  // Cache parsed handler data from the personality routine Phase 1
+  // for Phase 2 and __cxa_call_unexpected.
+  int handlerSwitchValue;
+  const unsigned char *actionRecord;
+  const unsigned char *languageSpecificData;
+  _Unwind_Ptr catchTemp;
+  void *adjustedPtr;
+
+  // The generic exception header.  Must be last.
+  _Unwind_Exception unwindHeader;
+};
+
+// Each thread in a C++ program has access to a __cxa_eh_globals object.
+struct __cxa_eh_globals
+{
+  __cxa_exception *caughtExceptions;
+  unsigned int uncaughtExceptions;
+};
+
+
+// The __cxa_eh_globals for the current thread can be obtained by using
+// either of the following functions.  The "fast" version assumes at least
+// one prior call of __cxa_get_globals has been made from the current
+// thread, so no initialization is necessary.
+extern "C" __cxa_eh_globals *__cxa_get_globals () throw();
+extern "C" __cxa_eh_globals *__cxa_get_globals_fast () throw();
+
+// Allocate memory for the exception plus the thown object.
+extern "C" void *__cxa_allocate_exception(std::size_t thrown_size) throw();
+
+// Free the space allocated for the exception.
+extern "C" void __cxa_free_exception(void *thrown_exception) throw();
+
+// Throw the exception.
+extern "C" void __cxa_throw (void *thrown_exception,
+			     std::type_info *tinfo,
+			     void (*dest) (void *))
+     __attribute__((noreturn));
+
+// Used to implement exception handlers.
+extern "C" void *__cxa_begin_catch (void *) throw();
+extern "C" void __cxa_end_catch ();
+extern "C" void __cxa_rethrow () __attribute__((noreturn));
+
+// These facilitate code generation for recurring situations.
+extern "C" void __cxa_bad_cast ();
+extern "C" void __cxa_bad_typeid ();
+
+// @@@ These are not directly specified by the IA-64 C++ ABI.
+
+// Handles re-checking the exception specification if unexpectedHandler
+// throws, and if bad_exception needs to be thrown.  Called from the
+// compiler.
+extern "C" void __cxa_call_unexpected (void *) __attribute__((noreturn));
+
+// Invokes given handler, dying appropriately if the user handler was
+// so inconsiderate as to return.
+extern void __terminate(std::terminate_handler) __attribute__((noreturn));
+extern void __unexpected(std::unexpected_handler) __attribute__((noreturn));
+
+// The current installed user handlers.
+extern std::terminate_handler __terminate_handler;
+extern std::unexpected_handler __unexpected_handler;
+
+// These are explicitly GNU C++ specific.
+
+// This is the exception class we report -- "GNUCC++\0".
+const _Unwind_Exception_Class __gxx_exception_class
+= ((((((((_Unwind_Exception_Class) 'G' 
+	 << 8 | (_Unwind_Exception_Class) 'N')
+	<< 8 | (_Unwind_Exception_Class) 'U')
+       << 8 | (_Unwind_Exception_Class) 'C')
+      << 8 | (_Unwind_Exception_Class) 'C')
+     << 8 | (_Unwind_Exception_Class) '+')
+    << 8 | (_Unwind_Exception_Class) '+')
+   << 8 | (_Unwind_Exception_Class) '\0');
+
+// GNU C++ personality routine, Version 0.
+extern "C" _Unwind_Reason_Code __gxx_personality_v0
+     (int, _Unwind_Action, _Unwind_Exception_Class,
+      struct _Unwind_Exception *, struct _Unwind_Context *);
+
+// GNU C++ sjlj personality routine, Version 0.
+extern "C" _Unwind_Reason_Code __gxx_personality_sj0
+     (int, _Unwind_Action, _Unwind_Exception_Class,
+      struct _Unwind_Exception *, struct _Unwind_Context *);
+
+// Acquire the C++ exception header from the C++ object.
+static inline __cxa_exception *
+__get_exception_header_from_obj (void *ptr)
+{
+  return reinterpret_cast<__cxa_exception *>(ptr) - 1;
+}
+
+// Acquire the C++ exception header from the generic exception header.
+static inline __cxa_exception *
+__get_exception_header_from_ue (_Unwind_Exception *exc)
+{
+  return reinterpret_cast<__cxa_exception *>(exc + 1) - 1;
+}
+
+} /* namespace __cxxabiv1 */
+
+#endif // _UNWIND_CXX_H
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/vec.cc linux-2.6.9/lib/libstdc++-v3/libsupc++/vec.cc
--- linux-2.6.9_orig/lib/libstdc++-v3/libsupc++/vec.cc	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/libsupc++/vec.cc	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,346 @@
+// New abi Support -*- C++ -*-
+
+// Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.
+//  
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License
+// along with GCC; see the file COPYING.  If not, write to
+// the Free Software Foundation, 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA. 
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+// Written by Nathan Sidwell, Codesourcery LLC, <nathan@codesourcery.com>
+
+#include <cxxabi.h>
+#include <new>
+#include <exception>
+#include <exception_defines.h>
+#include "unwind-cxx.h"
+
+namespace __cxxabiv1
+{
+  namespace 
+  {
+    struct uncatch_exception 
+    {
+      uncatch_exception ();
+      ~uncatch_exception () { __cxa_begin_catch (&p->unwindHeader); }
+      
+      __cxa_exception *p;
+    };
+
+    uncatch_exception::uncatch_exception ()
+    {
+      __cxa_eh_globals *globals = __cxa_get_globals_fast ();
+
+      p = globals->caughtExceptions;
+      p->handlerCount -= 1;
+      globals->caughtExceptions = p->nextException;
+      globals->uncaughtExceptions += 1;
+    }
+  }
+
+  // Allocate and construct array.
+  extern "C" void *
+  __cxa_vec_new(std::size_t element_count,
+		std::size_t element_size,
+		std::size_t padding_size,
+		void (*constructor) (void *),
+		void (*destructor) (void *))
+  {
+    return __cxa_vec_new2(element_count, element_size, padding_size,
+			   constructor, destructor,
+			   &operator new[], &operator delete []);
+  }
+
+  extern "C" void *
+  __cxa_vec_new2(std::size_t element_count,
+		 std::size_t element_size,
+		 std::size_t padding_size,
+		 void (*constructor) (void *),
+		 void (*destructor) (void *),
+		 void *(*alloc) (std::size_t),
+		 void (*dealloc) (void *))
+  {
+    std::size_t size = element_count * element_size + padding_size;
+    char *base = static_cast <char *> (alloc (size));
+    if (!base)
+      return base;
+
+    if (padding_size)
+      {
+	base += padding_size;
+	reinterpret_cast <std::size_t *> (base)[-1] = element_count;
+      }
+    try
+      {
+	__cxa_vec_ctor(base, element_count, element_size,
+		       constructor, destructor);
+      }
+    catch (...)
+      {
+	{
+	  uncatch_exception ue;
+	  dealloc(base - padding_size);
+	}
+	__throw_exception_again;
+      }
+    return base;
+  }
+  
+  extern "C" void *
+  __cxa_vec_new3(std::size_t element_count,
+		 std::size_t element_size,
+		 std::size_t padding_size,
+		 void (*constructor) (void *),
+		 void (*destructor) (void *),
+		 void *(*alloc) (std::size_t),
+		 void (*dealloc) (void *, std::size_t))
+  {
+    std::size_t size = element_count * element_size + padding_size;
+    char *base = static_cast<char *>(alloc (size));
+    if (!base)
+      return base;
+    
+    if (padding_size)
+      {
+	base += padding_size;
+	reinterpret_cast<std::size_t *>(base)[-1] = element_count;
+      }
+    try
+      {
+	__cxa_vec_ctor(base, element_count, element_size,
+		       constructor, destructor);
+      }
+    catch (...)
+      {
+	{
+	  uncatch_exception ue;
+	  dealloc(base - padding_size, size);
+	}
+	__throw_exception_again;
+      }
+    return base;
+  }
+  
+  // Construct array.
+  extern "C" void
+  __cxa_vec_ctor(void *array_address,
+		 std::size_t element_count,
+		 std::size_t element_size,
+		 void (*constructor) (void *),
+		 void (*destructor) (void *))
+  {
+    std::size_t ix = 0;
+    char *ptr = static_cast<char *>(array_address);
+    
+    try
+      {
+	if (constructor)
+	  for (; ix != element_count; ix++, ptr += element_size)
+	    constructor(ptr);
+      }
+    catch (...)
+      {
+	{
+	  uncatch_exception ue;
+	  __cxa_vec_cleanup(array_address, ix, element_size, destructor);
+	}
+	__throw_exception_again;
+      }
+  }
+  
+  // Construct an array by copying.
+  extern "C" void
+  __cxa_vec_cctor(void *dest_array,
+		  void *src_array,
+		  std::size_t element_count,
+		  std::size_t element_size,
+		  void (*constructor) (void *, void *),
+		  void (*destructor) (void *))
+  {
+    std::size_t ix = 0;
+    char *dest_ptr = static_cast<char *>(dest_array);
+    char *src_ptr = static_cast<char *>(src_array);
+    
+    try
+      {
+	if (constructor)
+	  for (; ix != element_count; 
+	       ix++, src_ptr += element_size, dest_ptr += element_size)
+	    constructor(dest_ptr, src_ptr);
+      }
+    catch (...)
+      {
+	{
+	  uncatch_exception ue;
+	  __cxa_vec_cleanup(dest_array, ix, element_size, destructor);
+	}
+	__throw_exception_again;
+      }
+  }
+  
+  // Destruct array.
+  extern "C" void
+  __cxa_vec_dtor(void *array_address,
+		 std::size_t element_count,
+		 std::size_t element_size,
+		 void (*destructor) (void *))
+  {
+    if (destructor)
+      {
+	char *ptr = static_cast<char *>(array_address);
+	std::size_t ix = element_count;
+
+	ptr += element_count * element_size;
+
+	try
+	  {
+	    while (ix--)
+	      {
+		ptr -= element_size;
+		destructor(ptr);
+	      }
+	  }
+	catch (...)
+	  {
+	    {
+	      uncatch_exception ue;
+	      __cxa_vec_cleanup(array_address, ix, element_size, destructor);
+	    }
+	    __throw_exception_again;
+	  }
+      }
+  }
+
+  // Destruct array as a result of throwing an exception.
+  // [except.ctor]/3 If a destructor called during stack unwinding
+  // exits with an exception, terminate is called.
+  extern "C" void
+  __cxa_vec_cleanup(void *array_address,
+		    std::size_t element_count,
+		    std::size_t element_size,
+		    void (*destructor) (void *))
+  {
+    if (destructor)
+      {
+	char *ptr = static_cast <char *> (array_address);
+	std::size_t ix = element_count;
+
+	ptr += element_count * element_size;
+
+	try
+	  {
+	    while (ix--)
+	      {
+		ptr -= element_size;
+		destructor(ptr);
+	      }
+	  }
+	catch (...)
+	  {
+	    std::terminate();
+	  }
+      }
+  }
+
+  // Destruct and release array.
+  extern "C" void
+  __cxa_vec_delete(void *array_address,
+		   std::size_t element_size,
+		   std::size_t padding_size,
+		   void (*destructor) (void *))
+  {
+    __cxa_vec_delete2(array_address, element_size, padding_size,
+		       destructor,
+		       &operator delete []);
+  }
+
+  extern "C" void
+  __cxa_vec_delete2(void *array_address,
+		    std::size_t element_size,
+		    std::size_t padding_size,
+		    void (*destructor) (void *),
+		    void (*dealloc) (void *))
+  {
+    if (!array_address)
+      return;
+
+    char* base = static_cast<char *>(array_address);
+  
+    if (padding_size)
+      {
+	std::size_t element_count = reinterpret_cast<std::size_t *>(base)[-1];
+	base -= padding_size;
+	try
+	  {
+	    __cxa_vec_dtor(array_address, element_count, element_size,
+			   destructor);
+	  }
+	catch (...)
+	  {
+	    {
+	      uncatch_exception ue;
+	      dealloc(base);
+	    }
+	    __throw_exception_again;
+	  }
+      }
+    dealloc(base);
+  }
+
+  extern "C" void
+  __cxa_vec_delete3(void *array_address,
+		    std::size_t element_size,
+		    std::size_t padding_size,
+		     void (*destructor) (void *),
+		    void (*dealloc) (void *, std::size_t))
+  {
+    if (!array_address)
+      return;
+
+    char* base = static_cast <char *> (array_address);
+    std::size_t size = 0;
+
+    if (padding_size)
+      {
+	std::size_t element_count = reinterpret_cast<std::size_t *> (base)[-1];
+	base -= padding_size;
+	size = element_count * element_size + padding_size;
+	try
+	  {
+	    __cxa_vec_dtor(array_address, element_count, element_size,
+			   destructor);
+	  }
+	catch (...)
+	  {
+	    {
+	      uncatch_exception ue;
+	      dealloc(base, size);
+	    }
+	    __throw_exception_again;
+	  }
+      }
+    dealloc(base, size);
+  }
+} // namespace __cxxabiv1
+
diff -urN linux-2.6.9_orig/lib/libstdc++-v3/Makefile linux-2.6.9/lib/libstdc++-v3/Makefile
--- linux-2.6.9_orig/lib/libstdc++-v3/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/lib/libstdc++-v3/Makefile	2004-10-26 13:26:04.000000000 +0000
@@ -0,0 +1,5 @@
+#
+# Makefile for libstdc++-v3.
+#
+
+obj-y	:= libsupc++/
diff -urN linux-2.6.9_orig/lib/Makefile linux-2.6.9/lib/Makefile
--- linux-2.6.9_orig/lib/Makefile	2004-10-26 13:20:14.000000000 +0000
+++ linux-2.6.9/lib/Makefile	2004-10-26 13:43:03.000000000 +0000
@@ -23,6 +23,10 @@
 obj-$(CONFIG_ZLIB_INFLATE) += zlib_inflate/
 obj-$(CONFIG_ZLIB_DEFLATE) += zlib_deflate/
 
+obj-$(CONFIG_CXX_RUNTIME) += cxa_atexit.o
+obj-$(CONFIG_CXX_RUNTIME) += gcc/
+obj-$(CONFIG_CXX_RUNTIME) += libstdc++-v3/
+
 hostprogs-y	:= gen_crc32table
 clean-files	:= crc32table.h
 
diff -urN linux-2.6.9_orig/Makefile linux-2.6.9/Makefile
--- linux-2.6.9_orig/Makefile	2004-10-26 18:46:48.000000000 +0000
+++ linux-2.6.9/Makefile	2004-10-26 19:17:15.000000000 +0000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 9
-EXTRAVERSION =-original
+EXTRAVERSION =-cxx_runtime_support
 NAME=Zonked Quokka
 
 # *DOCUMENTATION*
@@ -203,7 +203,7 @@
 
 HOSTCC  	= gcc
 HOSTCXX  	= g++
-HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
+HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer 
 HOSTCXXFLAGS	= -O2
 
 # 	Decide whether to build built-in, modular, or both.
@@ -314,6 +314,7 @@
 AS		= $(CROSS_COMPILE)as
 LD		= $(CROSS_COMPILE)ld
 CC		= $(CROSS_COMPILE)gcc
+CXX		= $(CROSS_COMPILE)g++
 CPP		= $(CC) -E
 AR		= $(CROSS_COMPILE)ar
 NM		= $(CROSS_COMPILE)nm
@@ -336,6 +337,9 @@
 
 NOSTDINC_FLAGS  = -nostdinc -iwithprefix include
 
+NOSTDINCXX_FLAGS = $(NOSTDINC_FLAGS) -nostdinc++
+
+
 # Use LINUXINCLUDE when you must reference the include/ directory.
 # Needed to be compatible with the O= option
 LINUXINCLUDE    := -Iinclude \
@@ -345,15 +349,20 @@
 
 CFLAGS 		:= -Wall -Wstrict-prototypes -Wno-trigraphs \
 	  	   -fno-strict-aliasing -fno-common
+	  	   
+CXXFLAGS	:= -fno-strict-aliasing -fno-common \
+ 		   -fpermissive -w 
+	  	   
 AFLAGS		:= -D__ASSEMBLY__
 
 export	VERSION PATCHLEVEL SUBLEVEL EXTRAVERSION LOCALVERSION KERNELRELEASE \
 	ARCH CONFIG_SHELL HOSTCC HOSTCFLAGS CROSS_COMPILE AS LD CC \
 	CPP AR NM STRIP OBJCOPY OBJDUMP MAKE AWK GENKSYMS PERL UTS_MACHINE \
-	HOSTCXX HOSTCXXFLAGS LDFLAGS_MODULE CHECK CHECKFLAGS
+	HOSTCXX HOSTCXXFLAGS LDFLAGS_MODULE CHECK CHECKFLAGS CXX
 
 export CPPFLAGS NOSTDINC_FLAGS LINUXINCLUDE OBJCOPYFLAGS LDFLAGS
 export CFLAGS CFLAGS_KERNEL CFLAGS_MODULE 
+export CXXFLAGS NOSTDINCXX_FLAGS
 export AFLAGS AFLAGS_KERNEL AFLAGS_MODULE
 
 # When compiling out-of-tree modules, put MODVERDIR in the module
@@ -482,16 +491,27 @@
 
 ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
 CFLAGS		+= -Os
+CXXFLAGS	+= -Os
 else
 CFLAGS		+= -O2
+CXXFLAGS	+= -O2
 endif
 
 ifndef CONFIG_FRAME_POINTER
 CFLAGS		+= -fomit-frame-pointer
+CXXFLAGS	+= -fomit-frame-pointer
 endif
 
 ifdef CONFIG_DEBUG_INFO
 CFLAGS		+= -g
+CXXFLAGS	+= -g
+endif
+
+ifdef CONFIG_CXX_RUNTIME
+CXXFLAGS	+= -I$(srctree)/include/c++ -I$(objtree)/include/c++ \
+	-fexceptions -frtti 
+else
+CXXFLAGS	+= -I$(srctree)/include/c++ -fno-exceptions -fno-rtti
 endif
 
 # warn about C99 declaration after statement
@@ -543,6 +563,33 @@
 libs-y2		:= $(patsubst %/, %/built-in.o, $(libs-y))
 libs-y		:= $(libs-y1) $(libs-y2)
 
+ifdef CONFIG_CXX_RUNTIME
+crtobj		:= $(objtree)/lib/gcc
+
+crtbegin.o	:= $(crtobj)/crtbegin.o
+crtend.o	:= $(crtobj)/crtend.o
+ifdef CONFIG_MODULES
+crtbeginM.o	:= $(crtobj)/crtbeginM.o
+crtendM.o	:= $(crtobj)/crtendM.o
+
+export crtbeginM.o crtendM.o
+endif
+
+crtobjects	:= $(crtbegin.o) $(crtend.o) $(crtbeginM.o) $(crtendM.o)
+
+$(crtobjects): $(srctree)/lib/gcc/crtstuff.c
+	$(Q)$(MAKE) $(build)=$(crtobj) build_crt=1 $@
+endif
+
+libsupcxx_headers	:= cxxabi.h exception exception_defines.h new typeinfo
+
+cxx_headers	:= $(patsubst %,include/c++/%,$(libsupcxx_headers))
+
+$(cxx_headers):
+	$(Q)set -e; \
+	if [ ! -d include/c++ ]; then mkdir -p include/c++; fi; \
+	ln -fsn $(srctree)/lib/libstdc++-v3/libsupc++/$(@F) $@
+
 # Build vmlinux
 # ---------------------------------------------------------------------------
 # vmlinux is build from the objects selected by $(vmlinux-init) and
@@ -580,9 +627,11 @@
 quiet_cmd_vmlinux__ ?= LD      $@
       cmd_vmlinux__ ?= $(LD) $(LDFLAGS) $(LDFLAGS_vmlinux) -o $@ \
       -T $(vmlinux-lds) $(vmlinux-init)                          \
+      $(crtbegin.o) 											\
       --start-group $(vmlinux-main) --end-group                  \
-      $(filter-out $(vmlinux-lds) $(vmlinux-init) $(vmlinux-main) FORCE ,$^)
-
+      $(crtend.o)  												  \
+      $(filter .tmp_kallsyms%,$^) 
+    
 # Generate new vmlinux version
 quiet_cmd_vmlinux_version = GEN     .version
       cmd_vmlinux_version = set -e;                     \
@@ -687,7 +736,7 @@
 endif # ifdef CONFIG_KALLSYMS
 
 # vmlinux image - including updated kernel symbols
-vmlinux: $(vmlinux-lds) $(vmlinux-init) $(vmlinux-main) $(kallsyms.o) FORCE
+vmlinux: $(vmlinux-lds) $(vmlinux-init) $(vmlinux-main) $(crtobjects) $(kallsyms.o) FORCE
 	$(call if_changed_rule,vmlinux__)
 
 # The actual objects are generated when descending, 
@@ -744,8 +793,10 @@
 	$(Q)mkdir -p $(MODVERDIR)
 endif
 
+prepare-crt: $(crtobjects) $(cxx_headers)
+
 # All the preparing..
-prepare-all: prepare0 prepare
+prepare-all: prepare0 prepare prepare-crt
 
 #	Leave this as default for preprocessing vmlinux.lds.S, which is now
 #	done in arch/$(ARCH)/kernel/Makefile
@@ -761,6 +812,8 @@
 	$(Q)$(MAKE) $(build)=$(@D) $@
 %.o: %.c scripts FORCE
 	$(Q)$(MAKE) $(build)=$(@D) $@
+%.o: %.cc scripts FORCE
+	$(Q)$(MAKE) $(build)=$(@D) $@
 %/:      scripts prepare FORCE
 	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) $(build)=$(@D)
 %.lst: %.c scripts FORCE
diff -urN linux-2.6.9_orig/scripts/Makefile.build linux-2.6.9/scripts/Makefile.build
--- linux-2.6.9_orig/scripts/Makefile.build	2004-10-26 13:20:23.000000000 +0000
+++ linux-2.6.9/scripts/Makefile.build	2004-10-26 13:47:43.000000000 +0000
@@ -93,7 +93,7 @@
 endif
 
 
-# Compile C sources (.c)
+# Compile C or C++ sources (.c or .cc)
 # ---------------------------------------------------------------------------
 
 # Default is built-in, unless we know otherwise
@@ -124,12 +124,15 @@
 $(multi-objs-y:.o=.s)   : modname = $(modname-multi)
 $(multi-objs-y:.o=.lst) : modname = $(modname-multi)
 
-quiet_cmd_cc_s_c = CC $(quiet_modtag)  $@
-cmd_cc_s_c       = $(CC) $(c_flags) -S -o $@ $< 
+quiet_cmd_cc_s_c   = CC $(quiet_modtag)  $@
+cmd_cc_s_c         = $(CC) $(c_flags) -S -o $@ $< 
 
 %.s: %.c FORCE
 	$(call if_changed_dep,cc_s_c)
 
+%.s: %.cc FORCE
+	$(call if_changed_dep,cxx_s_cc)
+
 quiet_cmd_cc_i_c = CPP $(quiet_modtag) $@
 cmd_cc_i_c       = $(CPP) $(c_flags)   -o $@ $<
 
@@ -141,9 +144,11 @@
 # (See cmd_cc_o_c + relevant part of rule_cc_o_c)
 
 quiet_cmd_cc_o_c = CC $(quiet_modtag)  $@
+quiet_cmd_cxx_o_cc = CXX $(quiet_modtag) $@
 
 ifndef CONFIG_MODVERSIONS
 cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $<
+cmd_cxx_o_cc = $(CXX) $(cxx_flags) -c -o $@ $<
 
 else
 # When module versioning is enabled the following steps are executed:
@@ -184,12 +189,29 @@
 	mv -f $(@D)/.$(@F).tmp $(@D)/.$(@F).cmd
 endef
 
+define rule_cxx_o_cc
+ 	$(if $($(quiet)cmd_checksrc),echo '  $($(quiet)cmd_checksrc)';)   \
+ 	$(cmd_checksrc)							  \
+ 	$(if $($(quiet)cmd_cxx_o_cc),echo '  $($(quiet)cmd_cxx_o_cc)';)	  \
+ 	$(cmd_cxx_o_cc);						  \
+ 	$(cmd_modversions)						  \
+ 	scripts/basic/fixdep $(depfile) $@ '$(cmd_cxx_o_cc)' > $(@D)/.$(@F).tmp;  \
+ 	rm -f $(depfile);						  \
+ 	mv -f $(@D)/.$(@F).tmp $(@D)/.$(@F).cmd
+endef
+ 
+
 # Built-in and composite module parts
 
 %.o: %.c FORCE
 	$(call cmd,force_checksrc)
 	$(call if_changed_rule,cc_o_c)
 
+%.o: %.cc FORCE
+	$(call cmd,force_checksrc)
+	$(call if_changed_rule,cxx_o_cc)
+
+
 # Single-part modules are special since we need to mark them in $(MODVERDIR)
 
 $(single-used-m): %.o: %.c FORCE
@@ -197,11 +219,21 @@
 	$(call if_changed_rule,cc_o_c)
 	@{ echo $(@:.o=.ko); echo $@; } > $(MODVERDIR)/$(@F:.o=.mod)
 
+
 quiet_cmd_cc_lst_c = MKLST   $@
       cmd_cc_lst_c = $(CC) $(c_flags) -g -c -o $*.o $< && \
 		     $(CONFIG_SHELL) $(srctree)/scripts/makelst $*.o \
 				     System.map $(OBJDUMP) > $@
 
+quiet_cmd_cxx_lst_cc = MKLST   $@
+       cmd_cxx_lst_cc = $(CXX) $(cxx_flags) -g -c -o $*.o $< && \
+ 		     $(CONFIG_SHELL) $(srctree)/scripts/makelst $*.o \
+ 				     System.map $(OBJDUMP) > $@
+ 
+%.lst: %.cc FORCE
+	$(call if_changed_dep,cxx_lst_cc)
+  
+
 %.lst: %.c FORCE
 	$(call if_changed_dep,cc_lst_c)
 
@@ -287,7 +319,8 @@
 cmd_link_multi-y = $(LD) $(ld_flags) -r -o $@ $(link_multi_deps)
 
 quiet_cmd_link_multi-m = LD [M]  $@
-cmd_link_multi-m = $(LD) $(ld_flags) $(LDFLAGS_MODULE) -o $@ $(link_multi_deps)
+cmd_link_multi-m = $(LD) $(ld_flags) $(LDFLAGS_MODULE) -o $@ \
+	$(crtbeginM.o) $(link_multi_deps) $(crtendM.o)
 
 # We would rather have a list of rules like
 # 	foo.o: $(foo-objs)
diff -urN linux-2.6.9_orig/scripts/Makefile.lib linux-2.6.9/scripts/Makefile.lib
--- linux-2.6.9_orig/scripts/Makefile.lib	2004-10-26 13:20:23.000000000 +0000
+++ linux-2.6.9/scripts/Makefile.lib	2004-10-26 13:26:04.000000000 +0000
@@ -99,6 +99,7 @@
 modname_flags  = $(if $(filter 1,$(words $(modname))),-DKBUILD_MODNAME=$(subst $(comma),_,$(subst -,_,$(modname))))
 
 _c_flags       = $(CFLAGS) $(EXTRA_CFLAGS) $(CFLAGS_$(*F).o)
+_cxx_flags     = $(CXXFLAGS) $(EXTRA_CXXFLAGS) $(CXXFLAGS_$(*F).o)
 _a_flags       = $(AFLAGS) $(EXTRA_AFLAGS) $(AFLAGS_$(*F).o)
 _cpp_flags     = $(CPPFLAGS) $(EXTRA_CPPFLAGS) $(CPPFLAGS_$(@F))
 
@@ -107,6 +108,7 @@
 
 ifeq ($(KBUILD_SRC),)
 __c_flags	= $(_c_flags)
+__cxx_flags	= $(_cxx_flags)
 __a_flags	= $(_a_flags)
 __cpp_flags     = $(_cpp_flags)
 else
@@ -121,6 +123,7 @@
 #   and locates generated .h files
 # FIXME: Replace both with specific CFLAGS* statements in the makefiles
 __c_flags	= $(call addtree,-I$(obj)) $(call flags,_c_flags)
+__cxx_flags	= $(call addtree,-I$(obj)) $(call flags,_cxx_flags)
 __a_flags	=                          $(call flags,_a_flags)
 __cpp_flags     =                          $(call flags,_cpp_flags)
 endif
@@ -129,6 +132,10 @@
 		 $(__c_flags) $(modkern_cflags) \
 		 $(basename_flags) $(modname_flags)
 
+cxx_flags      = -Wp,-MD,$(depfile) $(NOSTDINCXX_FLAGS) $(CPPFLAGS) \
+		 $(__cxx_flags) $(modkern_cflags) \
+		 $(basename_flags) $(modname_flags)
+
 a_flags        = -Wp,-MD,$(depfile) $(NOSTDINC_FLAGS) $(CPPFLAGS) \
 		 $(__a_flags) $(modkern_aflags)
 
diff -urN linux-2.6.9_orig/test.pre linux-2.6.9/test.pre
--- linux-2.6.9_orig/test.pre	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.9/test.pre	2004-10-26 14:26:27.000000000 +0000
@@ -0,0 +1,5326 @@
+# 1 "lib/libstdc++-v3/libsupc++/eh_alloc.cc"
+# 1 "<built-in>"
+# 1 "<command line>"
+# 9 "<command line>"
+# 1 "lib/gcc/fixdefines.h" 1
+# 10 "lib/gcc/fixdefines.h"
+# 1 "include/c++/begin_include.h" 1
+# 17 "include/c++/begin_include.h"
+extern "C" {
+# 11 "lib/gcc/fixdefines.h" 2
+# 1 "include/linux/slab.h" 1
+# 12 "include/linux/slab.h"
+typedef struct kmem_cache_s kmem_cache_t;
+
+# 1 "include/linux/config.h" 1
+
+
+
+# 1 "include/linux/autoconf.h" 1
+# 5 "include/linux/config.h" 2
+# 15 "include/linux/slab.h" 2
+# 1 "include/linux/gfp.h" 1
+
+
+
+# 1 "include/linux/mmzone.h" 1
+
+
+
+
+
+
+
+# 1 "include/linux/spinlock.h" 1
+# 9 "include/linux/spinlock.h"
+# 1 "include/linux/preempt.h" 1
+# 10 "include/linux/preempt.h"
+# 1 "include/linux/linkage.h" 1
+
+
+
+
+# 1 "include/asm/linkage.h" 1
+# 6 "include/linux/linkage.h" 2
+# 11 "include/linux/preempt.h" 2
+# 26 "include/linux/preempt.h"
+extern "C" __attribute__((regparm(0))) void preempt_schedule(void);
+# 10 "include/linux/spinlock.h" 2
+
+# 1 "include/linux/compiler.h" 1
+# 28 "include/linux/compiler.h"
+# 1 "include/linux/compiler-gcc3.h" 1
+
+
+
+# 1 "include/linux/compiler-gcc.h" 1
+# 5 "include/linux/compiler-gcc3.h" 2
+# 29 "include/linux/compiler.h" 2
+# 12 "include/linux/spinlock.h" 2
+# 1 "include/linux/thread_info.h" 1
+# 13 "include/linux/thread_info.h"
+struct restart_block {
+        long (*fn)(struct restart_block *);
+        unsigned long arg0, arg1, arg2, arg3;
+};
+
+extern long do_no_restart_syscall(struct restart_block *parm);
+
+# 1 "include/linux/bitops.h" 1
+
+
+# 1 "include/asm/types.h" 1
+
+
+
+
+
+typedef unsigned short umode_t;
+
+
+
+
+
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+# 40 "include/asm/types.h"
+typedef signed char s8;
+typedef unsigned char u8;
+
+typedef signed short s16;
+typedef unsigned short u16;
+
+typedef signed int s32;
+typedef unsigned int u32;
+
+typedef signed long long s64;
+typedef unsigned long long u64;
+
+
+
+
+
+
+typedef u32 dma_addr_t;
+
+typedef u64 dma64_addr_t;
+
+
+typedef u64 sector_t;
+
+
+
+typedef unsigned short kmem_bufctl_t;
+# 4 "include/linux/bitops.h" 2
+# 1 "include/asm/bitops.h" 1
+# 42 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) void set_bit(int nr, volatile unsigned long * addr)
+{
+        __asm__ __volatile__( "lock ; "
+                "btsl %1,%0"
+                :"=m" ((*(volatile long *) addr))
+                :"Ir" (nr));
+}
+# 59 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) void __set_bit(int nr, volatile unsigned long * addr)
+{
+        __asm__(
+                "btsl %1,%0"
+                :"=m" ((*(volatile long *) addr))
+                :"Ir" (nr));
+}
+# 77 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) void clear_bit(int nr, volatile unsigned long * addr)
+{
+        __asm__ __volatile__( "lock ; "
+                "btrl %1,%0"
+                :"=m" ((*(volatile long *) addr))
+                :"Ir" (nr));
+}
+
+static inline __attribute__((always_inline)) void __clear_bit(int nr, volatile unsigned long * addr)
+{
+        __asm__ __volatile__(
+                "btrl %1,%0"
+                :"=m" ((*(volatile long *) addr))
+                :"Ir" (nr));
+}
+# 104 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) void __change_bit(int nr, volatile unsigned long * addr)
+{
+        __asm__ __volatile__(
+                "btcl %1,%0"
+                :"=m" ((*(volatile long *) addr))
+                :"Ir" (nr));
+}
+# 122 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) void change_bit(int nr, volatile unsigned long * addr)
+{
+        __asm__ __volatile__( "lock ; "
+                "btcl %1,%0"
+                :"=m" ((*(volatile long *) addr))
+                :"Ir" (nr));
+}
+# 139 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) int test_and_set_bit(int nr, volatile unsigned long * addr)
+{
+        int oldbit;
+
+        __asm__ __volatile__( "lock ; "
+                "btsl %2,%1\n\tsbbl %0,%0"
+                :"=r" (oldbit),"=m" ((*(volatile long *) addr))
+                :"Ir" (nr) : "memory");
+        return oldbit;
+}
+# 159 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) int __test_and_set_bit(int nr, volatile unsigned long * addr)
+{
+        int oldbit;
+
+        __asm__(
+                "btsl %2,%1\n\tsbbl %0,%0"
+                :"=r" (oldbit),"=m" ((*(volatile long *) addr))
+                :"Ir" (nr));
+        return oldbit;
+}
+# 179 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) int test_and_clear_bit(int nr, volatile unsigned long * addr)
+{
+        int oldbit;
+
+        __asm__ __volatile__( "lock ; "
+                "btrl %2,%1\n\tsbbl %0,%0"
+                :"=r" (oldbit),"=m" ((*(volatile long *) addr))
+                :"Ir" (nr) : "memory");
+        return oldbit;
+}
+# 199 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) int __test_and_clear_bit(int nr, volatile unsigned long *addr)
+{
+        int oldbit;
+
+        __asm__(
+                "btrl %2,%1\n\tsbbl %0,%0"
+                :"=r" (oldbit),"=m" ((*(volatile long *) addr))
+                :"Ir" (nr));
+        return oldbit;
+}
+
+
+static inline __attribute__((always_inline)) int __test_and_change_bit(int nr, volatile unsigned long *addr)
+{
+        int oldbit;
+
+        __asm__ __volatile__(
+                "btcl %2,%1\n\tsbbl %0,%0"
+                :"=r" (oldbit),"=m" ((*(volatile long *) addr))
+                :"Ir" (nr) : "memory");
+        return oldbit;
+}
+# 230 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) int test_and_change_bit(int nr, volatile unsigned long* addr)
+{
+        int oldbit;
+
+        __asm__ __volatile__( "lock ; "
+                "btcl %2,%1\n\tsbbl %0,%0"
+                :"=r" (oldbit),"=m" ((*(volatile long *) addr))
+                :"Ir" (nr) : "memory");
+        return oldbit;
+}
+# 250 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) int constant_test_bit(int nr, const volatile unsigned long *addr)
+{
+        return ((1UL << (nr & 31)) & (addr[nr >> 5])) != 0;
+}
+
+static inline __attribute__((always_inline)) int variable_test_bit(int nr, const volatile unsigned long * addr)
+{
+        int oldbit;
+
+        __asm__ __volatile__(
+                "btl %2,%1\n\tsbbl %0,%0"
+                :"=r" (oldbit)
+                :"m" ((*(volatile long *) addr)),"Ir" (nr));
+        return oldbit;
+}
+# 281 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) int find_first_zero_bit(const unsigned long *addr, unsigned size)
+{
+        int d0, d1, d2;
+        int res;
+
+        if (!size)
+                return 0;
+
+        __asm__ __volatile__(
+                "movl $-1,%%eax\n\t"
+                "xorl %%edx,%%edx\n\t"
+                "repe; scasl\n\t"
+                "je 1f\n\t"
+                "xorl -4(%%edi),%%eax\n\t"
+                "subl $4,%%edi\n\t"
+                "bsfl %%eax,%%edx\n"
+                "1:\tsubl %%ebx,%%edi\n\t"
+                "shll $3,%%edi\n\t"
+                "addl %%edi,%%edx"
+                :"=d" (res), "=&c" (d0), "=&D" (d1), "=&a" (d2)
+                :"1" ((size + 31) >> 5), "2" (addr), "b" (addr) : "memory");
+        return res;
+}
+
+
+
+
+
+
+
+int find_next_zero_bit(const unsigned long *addr, int size, int offset);
+# 321 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) int find_first_bit(const unsigned long *addr, unsigned size)
+{
+        int d0, d1;
+        int res;
+
+
+        __asm__ __volatile__(
+                "xorl %%eax,%%eax\n\t"
+                "repe; scasl\n\t"
+                "jz 1f\n\t"
+                "leal -4(%%edi),%%edi\n\t"
+                "bsfl (%%edi),%%eax\n"
+                "1:\tsubl %%ebx,%%edi\n\t"
+                "shll $3,%%edi\n\t"
+                "addl %%edi,%%eax"
+                :"=a" (res), "=&c" (d0), "=&D" (d1)
+                :"1" ((size + 31) >> 5), "2" (addr), "b" (addr) : "memory");
+        return res;
+}
+
+
+
+
+
+
+
+int find_next_bit(const unsigned long *addr, int size, int offset);
+
+
+
+
+
+
+
+static inline __attribute__((always_inline)) unsigned long ffz(unsigned long word)
+{
+        __asm__("bsfl %1,%0"
+                :"=r" (word)
+                :"r" (~word));
+        return word;
+}
+
+
+
+
+
+
+
+static inline __attribute__((always_inline)) unsigned long __ffs(unsigned long word)
+{
+        __asm__("bsfl %1,%0"
+                :"=r" (word)
+                :"rm" (word));
+        return word;
+}
+# 391 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) int sched_find_first_bit(const unsigned long *b)
+{
+        if (__builtin_expect(!!(b[0]), 0))
+                return __ffs(b[0]);
+        if (__builtin_expect(!!(b[1]), 0))
+                return __ffs(b[1]) + 32;
+        if (__builtin_expect(!!(b[2]), 0))
+                return __ffs(b[2]) + 64;
+        if (b[3])
+                return __ffs(b[3]) + 96;
+        return __ffs(b[4]) + 128;
+}
+# 412 "include/asm/bitops.h"
+static inline __attribute__((always_inline)) int ffs(int x)
+{
+        int r;
+
+        __asm__("bsfl %1,%0\n\t"
+                "jnz 1f\n\t"
+                "movl $-1,%0\n"
+                "1:" : "=r" (r) : "rm" (x));
+        return r+1;
+}
+# 5 "include/linux/bitops.h" 2
+
+
+
+
+
+
+
+static inline __attribute__((always_inline)) int generic_ffs(int x)
+{
+        int r = 1;
+
+        if (!x)
+                return 0;
+        if (!(x & 0xffff)) {
+                x >>= 16;
+                r += 16;
+        }
+        if (!(x & 0xff)) {
+                x >>= 8;
+                r += 8;
+        }
+        if (!(x & 0xf)) {
+                x >>= 4;
+                r += 4;
+        }
+        if (!(x & 3)) {
+                x >>= 2;
+                r += 2;
+        }
+        if (!(x & 1)) {
+                x >>= 1;
+                r += 1;
+        }
+        return r;
+}
+
+
+
+
+
+extern __inline__ __attribute__((always_inline)) int generic_fls(int x)
+{
+        int r = 32;
+
+        if (!x)
+                return 0;
+        if (!(x & 0xffff0000u)) {
+                x <<= 16;
+                r -= 16;
+        }
+        if (!(x & 0xff000000u)) {
+                x <<= 8;
+                r -= 8;
+        }
+        if (!(x & 0xf0000000u)) {
+                x <<= 4;
+                r -= 4;
+        }
+        if (!(x & 0xc0000000u)) {
+                x <<= 2;
+                r -= 2;
+        }
+        if (!(x & 0x80000000u)) {
+                x <<= 1;
+                r -= 1;
+        }
+        return r;
+}
+
+extern __inline__ __attribute__((always_inline)) int get_bitmask_order(unsigned int count)
+{
+        int order;
+
+        order = generic_fls(count);
+        return order;
+}
+
+
+
+
+
+
+static inline __attribute__((always_inline)) unsigned int generic_hweight32(unsigned int w)
+{
+        unsigned int res = (w & 0x55555555) + ((w >> 1) & 0x55555555);
+        res = (res & 0x33333333) + ((res >> 2) & 0x33333333);
+        res = (res & 0x0F0F0F0F) + ((res >> 4) & 0x0F0F0F0F);
+        res = (res & 0x00FF00FF) + ((res >> 8) & 0x00FF00FF);
+        return (res & 0x0000FFFF) + ((res >> 16) & 0x0000FFFF);
+}
+
+static inline __attribute__((always_inline)) unsigned int generic_hweight16(unsigned int w)
+{
+        unsigned int res = (w & 0x5555) + ((w >> 1) & 0x5555);
+        res = (res & 0x3333) + ((res >> 2) & 0x3333);
+        res = (res & 0x0F0F) + ((res >> 4) & 0x0F0F);
+        return (res & 0x00FF) + ((res >> 8) & 0x00FF);
+}
+
+static inline __attribute__((always_inline)) unsigned int generic_hweight8(unsigned int w)
+{
+        unsigned int res = (w & 0x55) + ((w >> 1) & 0x55);
+        res = (res & 0x33) + ((res >> 2) & 0x33);
+        return (res & 0x0F) + ((res >> 4) & 0x0F);
+}
+
+static inline __attribute__((always_inline)) unsigned long generic_hweight64(__u64 w)
+{
+
+        return generic_hweight32((unsigned int)(w >> 32)) +
+                                generic_hweight32((unsigned int)w);
+# 125 "include/linux/bitops.h"
+}
+
+static inline __attribute__((always_inline)) unsigned long hweight_long(unsigned long w)
+{
+        return sizeof(w) == 4 ? generic_hweight32(w) : generic_hweight64(w);
+}
+# 21 "include/linux/thread_info.h" 2
+# 1 "include/asm/thread_info.h" 1
+# 13 "include/asm/thread_info.h"
+# 1 "include/asm/page.h" 1
+# 53 "include/asm/page.h"
+typedef struct { unsigned long pte_low; } pte_t;
+typedef struct { unsigned long pmd; } pmd_t;
+typedef struct { unsigned long pgd; } pgd_t;
+typedef struct { unsigned long pgprot; } pgprot_t;
+# 103 "include/asm/page.h"
+extern unsigned int __VMALLOC_RESERVE;
+
+
+static __inline__ __attribute__((always_inline)) int get_order(unsigned long size)
+{
+        int order;
+
+        size = (size-1) >> (12 -1);
+        order = -1;
+        do {
+                size >>= 1;
+                order++;
+        } while (size);
+        return order;
+}
+
+extern int sysctl_legacy_va_layout;
+# 14 "include/asm/thread_info.h" 2
+
+
+# 1 "include/asm/processor.h" 1
+# 10 "include/asm/processor.h"
+# 1 "include/asm/vm86.h" 1
+# 68 "include/asm/vm86.h"
+struct vm86_regs {
+
+
+
+        long ebx;
+        long ecx;
+        long edx;
+        long esi;
+        long edi;
+        long ebp;
+        long eax;
+        long __null_ds;
+        long __null_es;
+        long __null_fs;
+        long __null_gs;
+        long orig_eax;
+        long eip;
+        unsigned short cs, __csh;
+        long eflags;
+        long esp;
+        unsigned short ss, __ssh;
+
+
+
+        unsigned short es, __esh;
+        unsigned short ds, __dsh;
+        unsigned short fs, __fsh;
+        unsigned short gs, __gsh;
+};
+
+struct revectored_struct {
+        unsigned long __map[8];
+};
+
+struct vm86_struct {
+        struct vm86_regs regs;
+        unsigned long flags;
+        unsigned long screen_bitmap;
+        unsigned long cpu_type;
+        struct revectored_struct int_revectored;
+        struct revectored_struct int21_revectored;
+};
+
+
+
+
+
+
+struct vm86plus_info_struct {
+        unsigned long force_return_for_pic:1;
+        unsigned long vm86dbg_active:1;
+        unsigned long vm86dbg_TFpendig:1;
+        unsigned long unused:28;
+        unsigned long is_vm86pus:1;
+        unsigned char vm86dbg_intxxtab[32];
+};
+
+struct vm86plus_struct {
+        struct vm86_regs regs;
+        unsigned long flags;
+        unsigned long screen_bitmap;
+        unsigned long cpu_type;
+        struct revectored_struct int_revectored;
+        struct revectored_struct int21_revectored;
+        struct vm86plus_info_struct vm86plus;
+};
+# 145 "include/asm/vm86.h"
+struct kernel_vm86_regs {
+
+
+
+        long ebx;
+        long ecx;
+        long edx;
+        long esi;
+        long edi;
+        long ebp;
+        long eax;
+        long __null_ds;
+        long __null_es;
+        long orig_eax;
+        long eip;
+        unsigned short cs, __csh;
+        long eflags;
+        long esp;
+        unsigned short ss, __ssh;
+
+
+
+        unsigned short es, __esh;
+        unsigned short ds, __dsh;
+        unsigned short fs, __fsh;
+        unsigned short gs, __gsh;
+};
+
+struct kernel_vm86_struct {
+        struct kernel_vm86_regs regs;
+# 184 "include/asm/vm86.h"
+        unsigned long flags;
+        unsigned long screen_bitmap;
+        unsigned long cpu_type;
+        struct revectored_struct int_revectored;
+        struct revectored_struct int21_revectored;
+        struct vm86plus_info_struct vm86plus;
+        struct pt_regs *regs32;
+# 201 "include/asm/vm86.h"
+};
+
+void handle_vm86_fault(struct kernel_vm86_regs *, long);
+int handle_vm86_trap(struct kernel_vm86_regs *, long, int);
+# 11 "include/asm/processor.h" 2
+# 1 "include/asm/math_emu.h" 1
+
+
+
+# 1 "include/asm/sigcontext.h" 1
+# 20 "include/asm/sigcontext.h"
+struct _fpreg {
+        unsigned short significand[4];
+        unsigned short exponent;
+};
+
+struct _fpxreg {
+        unsigned short significand[4];
+        unsigned short exponent;
+        unsigned short padding[3];
+};
+
+struct _xmmreg {
+        unsigned long element[4];
+};
+
+struct _fpstate {
+
+        unsigned long cw;
+        unsigned long sw;
+        unsigned long tag;
+        unsigned long ipoff;
+        unsigned long cssel;
+        unsigned long dataoff;
+        unsigned long datasel;
+        struct _fpreg _st[8];
+        unsigned short status;
+        unsigned short magic;
+
+
+        unsigned long _fxsr_env[6];
+        unsigned long mxcsr;
+        unsigned long reserved;
+        struct _fpxreg _fxsr_st[8];
+        struct _xmmreg _xmm[8];
+        unsigned long padding[56];
+};
+
+
+
+struct sigcontext {
+        unsigned short gs, __gsh;
+        unsigned short fs, __fsh;
+        unsigned short es, __esh;
+        unsigned short ds, __dsh;
+        unsigned long edi;
+        unsigned long esi;
+        unsigned long ebp;
+        unsigned long esp;
+        unsigned long ebx;
+        unsigned long edx;
+        unsigned long ecx;
+        unsigned long eax;
+        unsigned long trapno;
+        unsigned long err;
+        unsigned long eip;
+        unsigned short cs, __csh;
+        unsigned long eflags;
+        unsigned long esp_at_signal;
+        unsigned short ss, __ssh;
+        struct _fpstate * fpstate;
+        unsigned long oldmask;
+        unsigned long cr2;
+};
+# 5 "include/asm/math_emu.h" 2
+
+int restore_i387_soft(void *s387, struct _fpstate *buf);
+int save_i387_soft(void *s387, struct _fpstate *buf);
+
+
+
+
+
+struct info {
+        long ___orig_eip;
+        long ___ebx;
+        long ___ecx;
+        long ___edx;
+        long ___esi;
+        long ___edi;
+        long ___ebp;
+        long ___eax;
+        long ___ds;
+        long ___es;
+        long ___orig_eax;
+        long ___eip;
+        long ___cs;
+        long ___eflags;
+        long ___esp;
+        long ___ss;
+        long ___vm86_es;
+        long ___vm86_ds;
+        long ___vm86_fs;
+        long ___vm86_gs;
+};
+# 12 "include/asm/processor.h" 2
+# 1 "include/asm/segment.h" 1
+# 13 "include/asm/processor.h" 2
+
+
+
+# 1 "include/asm/cpufeature.h" 1
+# 17 "include/asm/processor.h" 2
+# 1 "include/asm/msr.h" 1
+# 27 "include/asm/msr.h"
+static inline __attribute__((always_inline)) void wrmsrl (unsigned long msr, unsigned long long val)
+{
+        unsigned long lo, hi;
+        lo = (unsigned long) val;
+        hi = val >> 32;
+        __asm__ __volatile__("wrmsr" : : "c" (msr), "a" (lo), "d" (hi));
+}
+# 18 "include/asm/processor.h" 2
+# 1 "include/asm/system.h" 1
+
+
+
+
+# 1 "include/linux/kernel.h" 1
+# 10 "include/linux/kernel.h"
+# 1 "/usr/lib/gcc-lib/i386-redhat-linux/3.3.3/include/stdarg.h" 1 3 4
+# 43 "/usr/lib/gcc-lib/i386-redhat-linux/3.3.3/include/stdarg.h" 3 4
+typedef __builtin_va_list __gnuc_va_list;
+# 105 "/usr/lib/gcc-lib/i386-redhat-linux/3.3.3/include/stdarg.h" 3 4
+typedef __gnuc_va_list va_list;
+# 11 "include/linux/kernel.h" 2
+
+# 1 "include/linux/stddef.h" 1
+# 13 "include/linux/kernel.h" 2
+# 1 "include/linux/types.h" 1
+# 13 "include/linux/types.h"
+# 1 "include/linux/posix_types.h" 1
+# 36 "include/linux/posix_types.h"
+typedef struct {
+        unsigned long fds_bits [(1024/(8 * sizeof(unsigned long)))];
+} __kernel_fd_set;
+
+
+typedef void (*__kernel_sighandler_t)(int);
+
+
+typedef int __kernel_key_t;
+typedef int __kernel_mqd_t;
+
+# 1 "include/asm/posix_types.h" 1
+# 10 "include/asm/posix_types.h"
+typedef unsigned long __kernel_ino_t;
+typedef unsigned short __kernel_mode_t;
+typedef unsigned short __kernel_nlink_t;
+typedef long __kernel_off_t;
+typedef int __kernel_pid_t;
+typedef unsigned short __kernel_ipc_pid_t;
+typedef unsigned short __kernel_uid_t;
+typedef unsigned short __kernel_gid_t;
+typedef unsigned int __kernel_size_t;
+typedef int __kernel_ssize_t;
+typedef int __kernel_ptrdiff_t;
+typedef long __kernel_time_t;
+typedef long __kernel_suseconds_t;
+typedef long __kernel_clock_t;
+typedef int __kernel_timer_t;
+typedef int __kernel_clockid_t;
+typedef int __kernel_daddr_t;
+typedef char * __kernel_caddr_t;
+typedef unsigned short __kernel_uid16_t;
+typedef unsigned short __kernel_gid16_t;
+typedef unsigned int __kernel_uid32_t;
+typedef unsigned int __kernel_gid32_t;
+
+typedef unsigned short __kernel_old_uid_t;
+typedef unsigned short __kernel_old_gid_t;
+typedef unsigned short __kernel_old_dev_t;
+
+
+typedef long long __kernel_loff_t;
+
+
+typedef struct {
+
+        int val[2];
+
+
+
+} __kernel_fsid_t;
+# 48 "include/linux/posix_types.h" 2
+# 14 "include/linux/types.h" 2
+
+
+
+
+typedef __u32 __kernel_dev_t;
+
+typedef __kernel_fd_set fd_set;
+typedef __kernel_dev_t dev_t;
+typedef __kernel_ino_t ino_t;
+typedef __kernel_mode_t mode_t;
+typedef __kernel_nlink_t nlink_t;
+typedef __kernel_off_t off_t;
+typedef __kernel_pid_t pid_t;
+typedef __kernel_daddr_t daddr_t;
+typedef __kernel_key_t key_t;
+typedef __kernel_suseconds_t suseconds_t;
+typedef __kernel_timer_t timer_t;
+typedef __kernel_clockid_t clockid_t;
+typedef __kernel_mqd_t mqd_t;
+
+
+typedef __kernel_uid32_t uid_t;
+typedef __kernel_gid32_t gid_t;
+typedef __kernel_uid16_t uid16_t;
+typedef __kernel_gid16_t gid16_t;
+
+
+
+typedef __kernel_old_uid_t old_uid_t;
+typedef __kernel_old_gid_t old_gid_t;
+# 55 "include/linux/types.h"
+typedef __kernel_loff_t loff_t;
+# 64 "include/linux/types.h"
+typedef __kernel_size_t size_t;
+
+
+
+
+typedef __kernel_ssize_t ssize_t;
+
+
+
+
+typedef __kernel_ptrdiff_t ptrdiff_t;
+
+
+
+
+typedef __kernel_time_t time_t;
+
+
+
+
+typedef __kernel_clock_t clock_t;
+
+
+
+
+typedef __kernel_caddr_t caddr_t;
+
+
+
+typedef unsigned char u_char;
+typedef unsigned short u_short;
+typedef unsigned int u_int;
+typedef unsigned long u_long;
+
+
+typedef unsigned char unchar;
+typedef unsigned short ushort;
+typedef unsigned int uint;
+typedef unsigned long ulong;
+
+
+
+
+typedef __u8 u_int8_t;
+typedef __s8 int8_t;
+typedef __u16 u_int16_t;
+typedef __s16 int16_t;
+typedef __u32 u_int32_t;
+typedef __s32 int32_t;
+
+
+
+typedef __u8 uint8_t;
+typedef __u16 uint16_t;
+typedef __u32 uint32_t;
+
+
+typedef __u64 uint64_t;
+typedef __u64 u_int64_t;
+typedef __s64 int64_t;
+# 149 "include/linux/types.h"
+typedef __u16 __le16;
+typedef __u16 __be16;
+typedef __u32 __le32;
+typedef __u32 __be32;
+typedef __u64 __le64;
+typedef __u64 __be64;
+# 163 "include/linux/types.h"
+struct ustat {
+        __kernel_daddr_t f_tfree;
+        __kernel_ino_t f_tinode;
+        char f_fname[6];
+        char f_fpack[6];
+};
+# 14 "include/linux/kernel.h" 2
+
+
+# 1 "include/asm/byteorder.h" 1
+# 14 "include/asm/byteorder.h"
+static __inline__ __attribute__((always_inline)) __attribute__((__const__)) __u32 ___arch__swab32(__u32 x)
+{
+
+        __asm__("bswap %0" : "=r" (x) : "0" (x));
+
+
+
+
+
+
+
+        return x;
+}
+
+static __inline__ __attribute__((always_inline)) __attribute__((__const__)) __u64 ___arch__swab64(__u64 val)
+{
+        union {
+                struct { __u32 a,b; } s;
+                __u64 u;
+        } v;
+        v.u = val;
+
+        asm("bswapl %0 ; bswapl %1 ; xchgl %0,%1"
+            : "=r" (v.s.a), "=r" (v.s.b)
+            : "0" (v.s.a), "1" (v.s.b));
+
+
+
+
+
+        return v.u;
+}
+# 57 "include/asm/byteorder.h"
+# 1 "include/linux/byteorder/little_endian.h" 1
+# 12 "include/linux/byteorder/little_endian.h"
+# 1 "include/linux/byteorder/swab.h" 1
+# 133 "include/linux/byteorder/swab.h"
+static __inline__ __attribute__((always_inline)) __attribute__((__const__)) __u16 __fswab16(__u16 x)
+{
+        return ({ __u16 __tmp = (x) ; ({ __u16 __x = (__tmp); ((__u16)( (((__u16)(__x) & (__u16)0x00ffU) << 8) | (((__u16)(__x) & (__u16)0xff00U) >> 8) )); }); });
+}
+static __inline__ __attribute__((always_inline)) __u16 __swab16p(const __u16 *x)
+{
+        return ({ __u16 __tmp = (*(x)) ; ({ __u16 __x = (__tmp); ((__u16)( (((__u16)(__x) & (__u16)0x00ffU) << 8) | (((__u16)(__x) & (__u16)0xff00U) >> 8) )); }); });
+}
+static __inline__ __attribute__((always_inline)) void __swab16s(__u16 *addr)
+{
+        do { *(addr) = ({ __u16 __tmp = (*((addr))) ; ({ __u16 __x = (__tmp); ((__u16)( (((__u16)(__x) & (__u16)0x00ffU) << 8) | (((__u16)(__x) & (__u16)0xff00U) >> 8) )); }); }); } while (0);
+}
+
+static __inline__ __attribute__((always_inline)) __attribute__((__const__)) __u32 __fswab32(__u32 x)
+{
+        return ___arch__swab32(x);
+}
+static __inline__ __attribute__((always_inline)) __u32 __swab32p(const __u32 *x)
+{
+        return ___arch__swab32(*(x));
+}
+static __inline__ __attribute__((always_inline)) void __swab32s(__u32 *addr)
+{
+        do { *(addr) = ___arch__swab32(*((addr))); } while (0);
+}
+
+
+static __inline__ __attribute__((always_inline)) __attribute__((__const__)) __u64 __fswab64(__u64 x)
+{
+
+
+
+
+
+        return ___arch__swab64(x);
+
+}
+static __inline__ __attribute__((always_inline)) __u64 __swab64p(const __u64 *x)
+{
+        return ___arch__swab64(*(x));
+}
+static __inline__ __attribute__((always_inline)) void __swab64s(__u64 *addr)
+{
+        do { *(addr) = ___arch__swab64(*((addr))); } while (0);
+}
+# 13 "include/linux/byteorder/little_endian.h" 2
+# 43 "include/linux/byteorder/little_endian.h"
+static inline __attribute__((always_inline)) __le64 __cpu_to_le64p(const __u64 *p)
+{
+        return ( __le64)*p;
+}
+static inline __attribute__((always_inline)) __u64 __le64_to_cpup(const __le64 *p)
+{
+        return ( __u64)*p;
+}
+static inline __attribute__((always_inline)) __le32 __cpu_to_le32p(const __u32 *p)
+{
+        return ( __le32)*p;
+}
+static inline __attribute__((always_inline)) __u32 __le32_to_cpup(const __le32 *p)
+{
+        return ( __u32)*p;
+}
+static inline __attribute__((always_inline)) __le16 __cpu_to_le16p(const __u16 *p)
+{
+        return ( __le16)*p;
+}
+static inline __attribute__((always_inline)) __u16 __le16_to_cpup(const __le16 *p)
+{
+        return ( __u16)*p;
+}
+static inline __attribute__((always_inline)) __be64 __cpu_to_be64p(const __u64 *p)
+{
+        return ( __be64)__swab64p(p);
+}
+static inline __attribute__((always_inline)) __u64 __be64_to_cpup(const __be64 *p)
+{
+        return __swab64p((__u64 *)p);
+}
+static inline __attribute__((always_inline)) __be32 __cpu_to_be32p(const __u32 *p)
+{
+        return ( __be32)__swab32p(p);
+}
+static inline __attribute__((always_inline)) __u32 __be32_to_cpup(const __be32 *p)
+{
+        return __swab32p((__u32 *)p);
+}
+static inline __attribute__((always_inline)) __be16 __cpu_to_be16p(const __u16 *p)
+{
+        return ( __be16)__swab16p(p);
+}
+static inline __attribute__((always_inline)) __u16 __be16_to_cpup(const __be16 *p)
+{
+        return __swab16p((__u16 *)p);
+}
+# 104 "include/linux/byteorder/little_endian.h"
+# 1 "include/linux/byteorder/generic.h" 1
+# 150 "include/linux/byteorder/generic.h"
+extern __u32 ntohl(__be32);
+extern __be32 htonl(__u32);
+extern __u16 ntohs(__be16);
+extern __be16 htons(__u16);
+# 105 "include/linux/byteorder/little_endian.h" 2
+# 58 "include/asm/byteorder.h" 2
+# 17 "include/linux/kernel.h" 2
+# 1 "include/asm/bug.h" 1
+# 23 "include/asm/bug.h"
+# 1 "include/asm-generic/bug.h" 1
+# 24 "include/asm/bug.h" 2
+# 18 "include/linux/kernel.h" 2
+# 40 "include/linux/kernel.h"
+extern int console_printk[];
+
+
+
+
+
+
+struct completion;
+# 68 "include/linux/kernel.h"
+extern struct notifier_block *panic_notifier_list;
+ void panic(const char * fmt, ...)
+        __attribute__ ((noreturn, format (printf, 1, 2)));
+extern "C" __attribute__((regparm(0))) void do_exit(long error_code)
+        __attribute__((noreturn));
+ void complete_and_exit(struct completion *, long)
+        __attribute__((noreturn));
+extern unsigned long simple_strtoul(const char *,char **,unsigned int);
+extern long simple_strtol(const char *,char **,unsigned int);
+extern unsigned long long simple_strtoull(const char *,char **,unsigned int);
+extern long long simple_strtoll(const char *,char **,unsigned int);
+extern int sprintf(char * buf, const char * fmt, ...)
+        __attribute__ ((format (printf, 2, 3)));
+extern int vsprintf(char *buf, const char *, va_list);
+extern int snprintf(char * buf, size_t size, const char * fmt, ...)
+        __attribute__ ((format (printf, 3, 4)));
+extern int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
+extern int scnprintf(char * buf, size_t size, const char * fmt, ...)
+        __attribute__ ((format (printf, 3, 4)));
+extern int vscnprintf(char *buf, size_t size, const char *fmt, va_list args);
+
+extern int sscanf(const char *, const char *, ...)
+        __attribute__ ((format (scanf,2,3)));
+extern int vsscanf(const char *, const char *, va_list);
+
+extern int get_option(char **str, int *pint);
+extern char *get_options(const char *str, int nints, int *ints);
+extern unsigned long long memparse(char *ptr, char **retptr);
+
+extern int __kernel_text_address(unsigned long addr);
+extern int kernel_text_address(unsigned long addr);
+extern int session_of_pgrp(int pgrp);
+
+extern "C" __attribute__((regparm(0))) int vprintk(const char *fmt, va_list args);
+extern "C" __attribute__((regparm(0))) int printk(const char * fmt, ...)
+        __attribute__ ((format (printf, 1, 2)));
+
+unsigned long int_sqrt(unsigned long);
+
+static inline __attribute__((always_inline)) int __attribute__((pure)) long_log2(unsigned long x)
+{
+        int r = 0;
+        for (x >>= 1; x > 0; x >>= 1)
+                r++;
+        return r;
+}
+
+static inline __attribute__((always_inline)) unsigned long __attribute__((__const__)) roundup_pow_of_two(unsigned long x)
+{
+        return (1UL << generic_fls(x - 1));
+}
+
+extern int printk_ratelimit(void);
+extern int __printk_ratelimit(int ratelimit_jiffies, int ratelimit_burst);
+
+static inline __attribute__((always_inline)) void console_silent(void)
+{
+        (console_printk[0]) = 0;
+}
+
+static inline __attribute__((always_inline)) void console_verbose(void)
+{
+        if ((console_printk[0]))
+                (console_printk[0]) = 15;
+}
+
+extern void bust_spinlocks(int yes);
+extern int oops_in_progress;
+extern int panic_on_oops;
+extern int tainted;
+extern const char *print_tainted(void);
+
+
+extern enum system_states {
+        SYSTEM_BOOTING,
+        SYSTEM_RUNNING,
+        SYSTEM_HALT,
+        SYSTEM_POWER_OFF,
+        SYSTEM_RESTART,
+} system_state;
+
+
+
+
+
+
+extern void dump_stack(void);
+# 254 "include/linux/kernel.h"
+struct sysinfo {
+        long uptime;
+        unsigned long loads[3];
+        unsigned long totalram;
+        unsigned long freeram;
+        unsigned long sharedram;
+        unsigned long bufferram;
+        unsigned long totalswap;
+        unsigned long freeswap;
+        unsigned short procs;
+        unsigned short pad;
+        unsigned long totalhigh;
+        unsigned long freehigh;
+        unsigned int mem_unit;
+        char _f[20-2*sizeof(long)-sizeof(int)];
+};
+
+extern void BUILD_BUG(void);
+# 6 "include/asm/system.h" 2
+
+
+
+
+
+
+struct task_struct;
+extern struct task_struct * __switch_to(struct task_struct *prev, struct task_struct *next) __attribute__((regparm(3)));
+# 61 "include/asm/system.h"
+static inline __attribute__((always_inline)) unsigned long _get_base(char * addr)
+{
+        unsigned long __base;
+        __asm__("movb %3,%%dh\n\t"
+                "movb %2,%%dl\n\t"
+                "shll $16,%%edx\n\t"
+                "movw %1,%%dx"
+                :"=&d" (__base)
+                :"m" (*((addr)+2)),
+                 "m" (*((addr)+4)),
+                 "m" (*((addr)+7)));
+        return __base;
+}
+# 134 "include/asm/system.h"
+static inline __attribute__((always_inline)) unsigned long get_limit(unsigned long segment)
+{
+        unsigned long __limit;
+        __asm__("lsll %1,%0"
+                :"=r" (__limit):"r" (segment));
+        return __limit+1;
+}
+
+
+
+
+
+
+
+struct __xchg_dummy { unsigned long a[100]; };
+# 166 "include/asm/system.h"
+static inline __attribute__((always_inline)) void __set_64bit (unsigned long long * ptr,
+                unsigned int low, unsigned int high)
+{
+        __asm__ __volatile__ (
+                "\n1:\t"
+                "movl (%0), %%eax\n\t"
+                "movl 4(%0), %%edx\n\t"
+                "lock cmpxchg8b (%0)\n\t"
+                "jnz 1b"
+                :
+                : "D"(ptr),
+                        "b"(low),
+                        "c"(high)
+                : "ax","dx","memory");
+}
+
+static inline __attribute__((always_inline)) void __set_64bit_constant (unsigned long long *ptr,
+                                                 unsigned long long value)
+{
+        __set_64bit(ptr,(unsigned int)(value), (unsigned int)((value)>>32ULL));
+}
+
+
+
+static inline __attribute__((always_inline)) void __set_64bit_var (unsigned long long *ptr,
+                         unsigned long long value)
+{
+        __set_64bit(ptr,*(((unsigned int*)&(value))+0), *(((unsigned int*)&(value))+1));
+}
+# 211 "include/asm/system.h"
+static inline __attribute__((always_inline)) unsigned long __xchg(unsigned long x, volatile void * ptr, int size)
+{
+        switch (size) {
+                case 1:
+                        __asm__ __volatile__("xchgb %b0,%1"
+                                :"=q" (x)
+                                :"m" (*((struct __xchg_dummy *)(ptr))), "0" (x)
+                                :"memory");
+                        break;
+                case 2:
+                        __asm__ __volatile__("xchgw %w0,%1"
+                                :"=r" (x)
+                                :"m" (*((struct __xchg_dummy *)(ptr))), "0" (x)
+                                :"memory");
+                        break;
+                case 4:
+                        __asm__ __volatile__("xchgl %0,%1"
+                                :"=r" (x)
+                                :"m" (*((struct __xchg_dummy *)(ptr))), "0" (x)
+                                :"memory");
+                        break;
+        }
+        return x;
+}
+# 246 "include/asm/system.h"
+static inline __attribute__((always_inline)) unsigned long __cmpxchg(volatile void *ptr, unsigned long old,
+                                      unsigned long newx, int size)
+{
+        unsigned long prev;
+        switch (size) {
+        case 1:
+                __asm__ __volatile__("lock ; " "cmpxchgb %b1,%2"
+                                     : "=a"(prev)
+                                     : "q"(newx), "m"(*((struct __xchg_dummy *)(ptr))), "0"(old)
+                                     : "memory");
+                return prev;
+        case 2:
+                __asm__ __volatile__("lock ; " "cmpxchgw %w1,%2"
+                                     : "=a"(prev)
+                                     : "q"(newx), "m"(*((struct __xchg_dummy *)(ptr))), "0"(old)
+                                     : "memory");
+                return prev;
+        case 4:
+                __asm__ __volatile__("lock ; " "cmpxchgl %1,%2"
+                                     : "=a"(prev)
+                                     : "q"(newx), "m"(*((struct __xchg_dummy *)(ptr))), "0"(old)
+                                     : "memory");
+                return prev;
+        }
+        return old;
+}
+
+
+
+
+
+
+struct alt_instr {
+        __u8 *instr;
+        __u8 *replacement;
+        __u8 cpuid;
+        __u8 instrlen;
+        __u8 replacementlen;
+        __u8 pad;
+};
+# 465 "include/asm/system.h"
+void disable_hlt(void);
+void enable_hlt(void);
+
+extern int es7000_plat;
+# 19 "include/asm/processor.h" 2
+# 1 "include/linux/cache.h" 1
+
+
+
+
+
+# 1 "include/asm/cache.h" 1
+# 7 "include/linux/cache.h" 2
+# 20 "include/asm/processor.h" 2
+
+# 1 "include/linux/threads.h" 1
+# 22 "include/asm/processor.h" 2
+# 1 "include/asm/percpu.h" 1
+
+
+
+# 1 "include/asm-generic/percpu.h" 1
+
+
+
+
+
+
+
+extern unsigned long __per_cpu_offset[8];
+# 5 "include/asm/percpu.h" 2
+# 23 "include/asm/processor.h" 2
+
+
+extern int tsc_disable;
+
+struct desc_struct {
+        unsigned long a,b;
+};
+# 48 "include/asm/processor.h"
+struct cpuinfo_x86 {
+        __u8 x86;
+        __u8 x86_vendor;
+        __u8 x86_model;
+        __u8 x86_mask;
+        char wp_works_ok;
+        char hlt_works_ok;
+        char hard_math;
+        char rfu;
+        int cpuid_level;
+        unsigned long x86_capability[6];
+        char x86_vendor_id[16];
+        char x86_model_id[64];
+        int x86_cache_size;
+
+        int x86_cache_alignment;
+        int fdiv_bug;
+        int f00f_bug;
+        int coma_bug;
+        unsigned long loops_per_jiffy;
+} __attribute__((__aligned__((1 << (7)))));
+# 86 "include/asm/processor.h"
+extern struct cpuinfo_x86 boot_cpu_data;
+extern struct cpuinfo_x86 new_cpu_data;
+extern struct tss_struct doublefault_tss;
+extern __typeof__(struct tss_struct) per_cpu__init_tss;
+
+
+extern struct cpuinfo_x86 cpu_data[];
+
+
+
+
+
+
+extern char ignore_fpu_irq;
+
+extern void identify_cpu(struct cpuinfo_x86 *);
+extern void print_cpu_info(struct cpuinfo_x86 *);
+extern void dodgy_tsc(void);
+# 129 "include/asm/processor.h"
+static inline __attribute__((always_inline)) void cpuid(int op, int *eax, int *ebx, int *ecx, int *edx)
+{
+        __asm__("cpuid"
+                : "=a" (*eax),
+                  "=b" (*ebx),
+                  "=c" (*ecx),
+                  "=d" (*edx)
+                : "0" (op));
+}
+
+
+
+
+static inline __attribute__((always_inline)) unsigned int cpuid_eax(unsigned int op)
+{
+        unsigned int eax;
+
+        __asm__("cpuid"
+                : "=a" (eax)
+                : "0" (op)
+                : "bx", "cx", "dx");
+        return eax;
+}
+static inline __attribute__((always_inline)) unsigned int cpuid_ebx(unsigned int op)
+{
+        unsigned int eax, ebx;
+
+        __asm__("cpuid"
+                : "=a" (eax), "=b" (ebx)
+                : "0" (op)
+                : "cx", "dx" );
+        return ebx;
+}
+static inline __attribute__((always_inline)) unsigned int cpuid_ecx(unsigned int op)
+{
+        unsigned int eax, ecx;
+
+        __asm__("cpuid"
+                : "=a" (eax), "=c" (ecx)
+                : "0" (op)
+                : "bx", "dx" );
+        return ecx;
+}
+static inline __attribute__((always_inline)) unsigned int cpuid_edx(unsigned int op)
+{
+        unsigned int eax, edx;
+
+        __asm__("cpuid"
+                : "=a" (eax), "=d" (edx)
+                : "0" (op)
+                : "bx", "cx");
+        return edx;
+}
+# 208 "include/asm/processor.h"
+extern unsigned long mmu_cr4_features;
+
+static inline __attribute__((always_inline)) void set_in_cr4 (unsigned long mask)
+{
+        mmu_cr4_features |= mask;
+        __asm__("movl %%cr4,%%eax\n\t"
+                "orl %0,%%eax\n\t"
+                "movl %%eax,%%cr4\n"
+                : : "irg" (mask)
+                :"ax");
+}
+
+static inline __attribute__((always_inline)) void clear_in_cr4 (unsigned long mask)
+{
+        mmu_cr4_features &= ~mask;
+        __asm__("movl %%cr4,%%eax\n\t"
+                "andl %0,%%eax\n\t"
+                "movl %%eax,%%cr4\n"
+                : : "irg" (~mask)
+                :"ax");
+}
+# 264 "include/asm/processor.h"
+extern int MCA_bus;
+
+static inline __attribute__((always_inline)) void __monitor(const void *eax, unsigned long ecx,
+                unsigned long edx)
+{
+
+        asm volatile(
+                ".byte 0x0f,0x01,0xc8;"
+                : :"a" (eax), "c" (ecx), "d"(edx));
+}
+
+static inline __attribute__((always_inline)) void __mwait(unsigned long eax, unsigned long ecx)
+{
+
+        asm volatile(
+                ".byte 0x0f,0x01,0xc9;"
+                : :"a" (eax), "c" (ecx));
+}
+
+
+
+extern unsigned int machine_id;
+extern unsigned int machine_submodel_id;
+extern unsigned int BIOS_revision;
+extern unsigned int mca_pentium_flag;
+# 312 "include/asm/processor.h"
+struct i387_fsave_struct {
+        long cwd;
+        long swd;
+        long twd;
+        long fip;
+        long fcs;
+        long foo;
+        long fos;
+        long st_space[20];
+        long status;
+};
+
+struct i387_fxsave_struct {
+        unsigned short cwd;
+        unsigned short swd;
+        unsigned short twd;
+        unsigned short fop;
+        long fip;
+        long fcs;
+        long foo;
+        long fos;
+        long mxcsr;
+        long mxcsr_mask;
+        long st_space[32];
+        long xmm_space[32];
+        long padding[56];
+} __attribute__ ((aligned (16)));
+
+struct i387_soft_struct {
+        long cwd;
+        long swd;
+        long twd;
+        long fip;
+        long fcs;
+        long foo;
+        long fos;
+        long st_space[20];
+        unsigned char ftop, changed, lookahead, no_update, rm, alimit;
+        struct info *info;
+        unsigned long entry_eip;
+};
+
+union i387_union {
+        struct i387_fsave_struct fsave;
+        struct i387_fxsave_struct fxsave;
+        struct i387_soft_struct soft;
+};
+
+typedef struct {
+        unsigned long seg;
+} mm_segment_t;
+
+struct thread_struct;
+
+struct tss_struct {
+        unsigned short back_link,__blh;
+        unsigned long esp0;
+        unsigned short ss0,__ss0h;
+        unsigned long esp1;
+        unsigned short ss1,__ss1h;
+        unsigned long esp2;
+        unsigned short ss2,__ss2h;
+        unsigned long __cr3;
+        unsigned long eip;
+        unsigned long eflags;
+        unsigned long eax,ecx,edx,ebx;
+        unsigned long esp;
+        unsigned long ebp;
+        unsigned long esi;
+        unsigned long edi;
+        unsigned short es, __esh;
+        unsigned short cs, __csh;
+        unsigned short ss, __ssh;
+        unsigned short ds, __dsh;
+        unsigned short fs, __fsh;
+        unsigned short gs, __gsh;
+        unsigned short ldt, __ldth;
+        unsigned short trace, io_bitmap_base;
+
+
+
+
+
+
+        unsigned long io_bitmap[((65536/8)/sizeof(long)) + 1];
+
+
+
+        unsigned long io_bitmap_max;
+        struct thread_struct *io_bitmap_owner;
+
+
+
+        unsigned long __cacheline_filler[35];
+
+
+
+        unsigned long stack[64];
+} __attribute__((packed));
+
+
+
+struct thread_struct {
+
+        struct desc_struct tls_array[3];
+        unsigned long esp0;
+        unsigned long sysenter_cs;
+        unsigned long eip;
+        unsigned long esp;
+        unsigned long fs;
+        unsigned long gs;
+
+        unsigned long debugreg[8];
+
+        unsigned long cr2, trap_no, error_code;
+
+        union i387_union i387;
+
+        struct vm86_struct * vm86_info;
+        unsigned long screen_bitmap;
+        unsigned long v86flags, v86mask, saved_esp0;
+        unsigned int saved_fs, saved_gs;
+
+        unsigned long *io_bitmap_ptr;
+
+        unsigned long io_bitmap_max;
+};
+# 461 "include/asm/processor.h"
+static inline __attribute__((always_inline)) void load_esp0(struct tss_struct *tss, struct thread_struct *thread)
+{
+        tss->esp0 = thread->esp0;
+
+        if (__builtin_expect(!!(tss->ss1 != thread->sysenter_cs), 0)) {
+                tss->ss1 = thread->sysenter_cs;
+                __asm__ __volatile__("wrmsr" : : "c" (0x174), "a" (thread->sysenter_cs), "d" (0));
+        }
+}
+# 483 "include/asm/processor.h"
+struct task_struct;
+struct mm_struct;
+
+
+extern void release_thread(struct task_struct *);
+
+
+extern void prepare_to_copy(struct task_struct *tsk);
+
+
+
+
+extern int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);
+
+extern unsigned long thread_saved_pc(struct task_struct *tsk);
+void show_trace(struct task_struct *task, unsigned long *stack);
+
+unsigned long get_wchan(struct task_struct *p);
+# 520 "include/asm/processor.h"
+struct microcode_header {
+        unsigned int hdrver;
+        unsigned int rev;
+        unsigned int date;
+        unsigned int sig;
+        unsigned int cksum;
+        unsigned int ldrver;
+        unsigned int pf;
+        unsigned int datasize;
+        unsigned int totalsize;
+        unsigned int reserved[3];
+};
+
+struct microcode {
+        struct microcode_header hdr;
+        unsigned int bits[0];
+};
+
+typedef struct microcode microcode_t;
+typedef struct microcode_header microcode_header_t;
+
+
+struct extended_signature {
+        unsigned int sig;
+        unsigned int pf;
+        unsigned int cksum;
+};
+
+struct extended_sigtable {
+        unsigned int count;
+        unsigned int cksum;
+        unsigned int reserved[3];
+        struct extended_signature sigs[0];
+};
+
+
+
+
+static inline __attribute__((always_inline)) void rep_nop(void)
+{
+        __asm__ __volatile__("rep;nop": : :"memory");
+}
+# 633 "include/asm/processor.h"
+extern inline __attribute__((always_inline)) void prefetch(const void *x)
+{
+        asm volatile ("661:\n\t" ".byte 0x8d,0x74,0x26,0x00\n" "\n662:\n" ".section .altinstructions,\"a\"\n" "  .align 4\n" "  .long 661b\n" "  .long 663f\n" "  .byte %c0\n" "  .byte 662b-661b\n" "  .byte 664f-663f\n" ".previous\n" ".section .altinstr_replacement,\"ax\"\n" "663:\n\t" "prefetchnta (%1)" "\n664:\n" ".previous" :: "i" ((0*32+25)), "r" (x));
+
+
+
+}
+
+
+
+
+
+
+
+extern inline __attribute__((always_inline)) void prefetchw(const void *x)
+{
+        asm volatile ("661:\n\t" ".byte 0x8d,0x74,0x26,0x00\n" "\n662:\n" ".section .altinstructions,\"a\"\n" "  .align 4\n" "  .long 661b\n" "  .long 663f\n" "  .byte %c0\n" "  .byte 662b-661b\n" "  .byte 664f-663f\n" ".previous\n" ".section .altinstr_replacement,\"ax\"\n" "663:\n\t" "prefetchw (%1)" "\n664:\n" ".previous" :: "i" ((1*32+31)), "r" (x));
+
+
+
+}
+
+
+extern void select_idle_routine(const struct cpuinfo_x86 *c);
+# 17 "include/asm/thread_info.h" 2
+# 27 "include/asm/thread_info.h"
+struct thread_info {
+        struct task_struct *task;
+        struct exec_domain *exec_domain;
+        unsigned long flags;
+        unsigned long status;
+        __u32 cpu;
+        __s32 preempt_count;
+
+
+        mm_segment_t addr_limit;
+
+
+
+        struct restart_block restart_block;
+
+        unsigned long previous_esp;
+
+
+        __u8 supervisor_stack[0];
+};
+# 87 "include/asm/thread_info.h"
+static inline __attribute__((always_inline)) struct thread_info *current_thread_info(void)
+{
+        struct thread_info *ti;
+        __asm__("andl %%esp,%0; ":"=r" (ti) : "0" (~((8192) - 1)));
+        return ti;
+}
+
+
+static inline __attribute__((always_inline)) unsigned long current_stack_pointer(void)
+{
+        unsigned long ti;
+        __asm__("movl %%esp,%0; ":"=r" (ti) : );
+        return ti;
+}
+# 22 "include/linux/thread_info.h" 2
+# 30 "include/linux/thread_info.h"
+static inline __attribute__((always_inline)) void set_thread_flag(int flag)
+{
+        set_bit(flag,&current_thread_info()->flags);
+}
+
+static inline __attribute__((always_inline)) void clear_thread_flag(int flag)
+{
+        clear_bit(flag,&current_thread_info()->flags);
+}
+
+static inline __attribute__((always_inline)) int test_and_set_thread_flag(int flag)
+{
+        return test_and_set_bit(flag,&current_thread_info()->flags);
+}
+
+static inline __attribute__((always_inline)) int test_and_clear_thread_flag(int flag)
+{
+        return test_and_clear_bit(flag,&current_thread_info()->flags);
+}
+
+static inline __attribute__((always_inline)) int test_thread_flag(int flag)
+{
+        return (__builtin_constant_p(flag) ? constant_test_bit((flag),(&current_thread_info()->flags)) : variable_test_bit((flag),(&current_thread_info()->flags)));
+}
+
+static inline __attribute__((always_inline)) void set_ti_thread_flag(struct thread_info *ti, int flag)
+{
+        set_bit(flag,&ti->flags);
+}
+
+static inline __attribute__((always_inline)) void clear_ti_thread_flag(struct thread_info *ti, int flag)
+{
+        clear_bit(flag,&ti->flags);
+}
+
+static inline __attribute__((always_inline)) int test_and_set_ti_thread_flag(struct thread_info *ti, int flag)
+{
+        return test_and_set_bit(flag,&ti->flags);
+}
+
+static inline __attribute__((always_inline)) int test_and_clear_ti_thread_flag(struct thread_info *ti, int flag)
+{
+        return test_and_clear_bit(flag,&ti->flags);
+}
+
+static inline __attribute__((always_inline)) int test_ti_thread_flag(struct thread_info *ti, int flag)
+{
+        return (__builtin_constant_p(flag) ? constant_test_bit((flag),(&ti->flags)) : variable_test_bit((flag),(&ti->flags)));
+}
+
+static inline __attribute__((always_inline)) void set_need_resched(void)
+{
+        set_thread_flag(3);
+}
+
+static inline __attribute__((always_inline)) void clear_need_resched(void)
+{
+        clear_thread_flag(3);
+}
+# 13 "include/linux/spinlock.h" 2
+
+# 1 "include/linux/stringify.h" 1
+# 15 "include/linux/spinlock.h" 2
+# 39 "include/linux/spinlock.h"
+# 1 "include/asm/spinlock.h" 1
+
+
+
+# 1 "include/asm/atomic.h" 1
+# 22 "include/asm/atomic.h"
+typedef struct { volatile int counter; } atomic_t;
+# 50 "include/asm/atomic.h"
+static __inline__ __attribute__((always_inline)) void atomic_add(int i, atomic_t *v)
+{
+        __asm__ __volatile__(
+                "lock ; " "addl %1,%0"
+                :"=m" (v->counter)
+                :"ir" (i), "m" (v->counter));
+}
+# 65 "include/asm/atomic.h"
+static __inline__ __attribute__((always_inline)) void atomic_sub(int i, atomic_t *v)
+{
+        __asm__ __volatile__(
+                "lock ; " "subl %1,%0"
+                :"=m" (v->counter)
+                :"ir" (i), "m" (v->counter));
+}
+# 82 "include/asm/atomic.h"
+static __inline__ __attribute__((always_inline)) int atomic_sub_and_test(int i, atomic_t *v)
+{
+        unsigned char c;
+
+        __asm__ __volatile__(
+                "lock ; " "subl %2,%0; sete %1"
+                :"=m" (v->counter), "=qm" (c)
+                :"ir" (i), "m" (v->counter) : "memory");
+        return c;
+}
+
+
+
+
+
+
+
+static __inline__ __attribute__((always_inline)) void atomic_inc(atomic_t *v)
+{
+        __asm__ __volatile__(
+                "lock ; " "incl %0"
+                :"=m" (v->counter)
+                :"m" (v->counter));
+}
+
+
+
+
+
+
+
+static __inline__ __attribute__((always_inline)) void atomic_dec(atomic_t *v)
+{
+        __asm__ __volatile__(
+                "lock ; " "decl %0"
+                :"=m" (v->counter)
+                :"m" (v->counter));
+}
+# 129 "include/asm/atomic.h"
+static __inline__ __attribute__((always_inline)) int atomic_dec_and_test(atomic_t *v)
+{
+        unsigned char c;
+
+        __asm__ __volatile__(
+                "lock ; " "decl %0; sete %1"
+                :"=m" (v->counter), "=qm" (c)
+                :"m" (v->counter) : "memory");
+        return c != 0;
+}
+# 148 "include/asm/atomic.h"
+static __inline__ __attribute__((always_inline)) int atomic_inc_and_test(atomic_t *v)
+{
+        unsigned char c;
+
+        __asm__ __volatile__(
+                "lock ; " "incl %0; sete %1"
+                :"=m" (v->counter), "=qm" (c)
+                :"m" (v->counter) : "memory");
+        return c != 0;
+}
+# 168 "include/asm/atomic.h"
+static __inline__ __attribute__((always_inline)) int atomic_add_negative(int i, atomic_t *v)
+{
+        unsigned char c;
+
+        __asm__ __volatile__(
+                "lock ; " "addl %2,%0; sets %1"
+                :"=m" (v->counter), "=qm" (c)
+                :"ir" (i), "m" (v->counter) : "memory");
+        return c;
+}
+# 5 "include/asm/spinlock.h" 2
+# 1 "include/asm/rwlock.h" 1
+# 6 "include/asm/spinlock.h" 2
+
+
+
+
+extern "C" __attribute__((regparm(0))) int printk(const char * fmt, ...)
+        __attribute__ ((format (printf, 1, 2)));
+
+
+
+
+
+typedef struct {
+        volatile unsigned int lock;
+
+
+
+} spinlock_t;
+# 86 "include/asm/spinlock.h"
+static inline __attribute__((always_inline)) void _raw_spin_unlock(spinlock_t *lock)
+{
+
+
+
+
+        __asm__ __volatile__(
+                "movb $1,%0" :"=m" (lock->lock) : : "memory"
+        );
+}
+# 118 "include/asm/spinlock.h"
+static inline __attribute__((always_inline)) int _raw_spin_trylock(spinlock_t *lock)
+{
+        char oldval;
+        __asm__ __volatile__(
+                "xchgb %b0,%1"
+                :"=q" (oldval), "=m" (lock->lock)
+                :"0" (0) : "memory");
+        return oldval > 0;
+}
+
+static inline __attribute__((always_inline)) void _raw_spin_lock(spinlock_t *lock)
+{
+
+
+
+
+
+
+        __asm__ __volatile__(
+                "\n1:\t" "lock ; decb %0\n\t" "jns 3f\n" "2:\t" "rep;nop\n\t" "cmpb $0,%0\n\t" "jle 2b\n\t" "jmp 1b\n" "3:\n\t"
+                :"=m" (lock->lock) : : "memory");
+}
+
+static inline __attribute__((always_inline)) void _raw_spin_lock_flags (spinlock_t *lock, unsigned long flags)
+{
+
+
+
+
+
+
+        __asm__ __volatile__(
+                "\n1:\t" "lock ; decb %0\n\t" "jns 4f\n\t" "2:\t" "testl $0x200, %1\n\t" "jz 3f\n\t" "sti\n\t" "3:\t" "rep;nop\n\t" "cmpb $0, %0\n\t" "jle 3b\n\t" "cli\n\t" "jmp 1b\n" "4:\n\t"
+                :"=m" (lock->lock) : "r" (flags) : "memory");
+}
+# 164 "include/asm/spinlock.h"
+typedef struct {
+        volatile unsigned int lock;
+
+
+
+} rwlock_t;
+# 196 "include/asm/spinlock.h"
+static inline __attribute__((always_inline)) void _raw_read_lock(rwlock_t *rw)
+{
+
+
+
+        do { if (__builtin_constant_p(rw)) asm volatile("lock ; " "subl $1,%0\n\t" "jns 1f\n" "pushl %%eax\n\t" "leal %0,%%eax\n\t" "call " "__read_lock_failed" "\n\t" "popl %%eax\n\t" "1:\n" :"=m" (*(volatile int *)rw) : : "memory"); else asm volatile("lock ; " "subl $1,(%0)\n\t" "jns 1f\n" "call " "__read_lock_failed" "\n\t" "1:\n" ::"a" (rw) : "memory"); } while (0);
+}
+
+static inline __attribute__((always_inline)) void _raw_write_lock(rwlock_t *rw)
+{
+
+
+
+        do { if (__builtin_constant_p(rw)) asm volatile("lock ; " "subl $" "0x01000000" ",%0\n\t" "jz 1f\n" "pushl %%eax\n\t" "leal %0,%%eax\n\t" "call " "__write_lock_failed" "\n\t" "popl %%eax\n\t" "1:\n" :"=m" (*(volatile int *)rw) : : "memory"); else asm volatile("lock ; " "subl $" "0x01000000" ",(%0)\n\t" "jz 1f\n" "call " "__write_lock_failed" "\n\t" "1:\n" ::"a" (rw) : "memory"); } while (0);
+}
+
+
+
+
+static inline __attribute__((always_inline)) int _raw_write_trylock(rwlock_t *lock)
+{
+        atomic_t *count = (atomic_t *)lock;
+        if (atomic_sub_and_test(0x01000000, count))
+                return 1;
+        atomic_add(0x01000000, count);
+        return 0;
+}
+# 40 "include/linux/spinlock.h" 2
+
+
+
+int __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _spin_trylock(spinlock_t *lock);
+int __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _write_trylock(rwlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _spin_lock(spinlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _write_lock(rwlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _spin_lock(spinlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _read_lock(rwlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _spin_unlock(spinlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _write_unlock(rwlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _read_unlock(rwlock_t *lock);
+unsigned long __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _spin_lock_irqsave(spinlock_t *lock);
+unsigned long __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _read_lock_irqsave(rwlock_t *lock);
+unsigned long __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _write_lock_irqsave(rwlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _spin_lock_irq(spinlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _spin_lock_bh(spinlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _read_lock_irq(rwlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _read_lock_bh(rwlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _write_lock_irq(rwlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _write_lock_bh(rwlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _spin_unlock_irq(spinlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _spin_unlock_bh(spinlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _read_unlock_irqrestore(rwlock_t *lock, unsigned long flags);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _read_unlock_irq(rwlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _read_unlock_bh(rwlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _write_unlock_irqrestore(rwlock_t *lock, unsigned long flags);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _write_unlock_irq(rwlock_t *lock);
+void __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _write_unlock_bh(rwlock_t *lock);
+int __attribute__((regparm(3))) __attribute__((section(".spinlock.text"))) _spin_trylock_bh(spinlock_t *lock);
+int in_lock_functions(unsigned long addr);
+# 459 "include/linux/spinlock.h"
+extern int atomic_dec_and_lock(atomic_t *atomic, spinlock_t *lock);
+# 468 "include/linux/spinlock.h"
+static inline __attribute__((always_inline)) void bit_spin_lock(int bitnum, unsigned long *addr)
+{
+
+
+
+
+
+
+
+        do { do { (current_thread_info()->preempt_count)++; } while (0); __asm__ __volatile__("": : :"memory"); } while (0);
+
+        while (test_and_set_bit(bitnum, addr)) {
+                while ((__builtin_constant_p(bitnum) ? constant_test_bit((bitnum),(addr)) : variable_test_bit((bitnum),(addr))))
+                        rep_nop();
+        }
+
+}
+
+
+
+
+static inline __attribute__((always_inline)) int bit_spin_trylock(int bitnum, unsigned long *addr)
+{
+
+        int ret;
+
+        do { do { (current_thread_info()->preempt_count)++; } while (0); __asm__ __volatile__("": : :"memory"); } while (0);
+        ret = !test_and_set_bit(bitnum, addr);
+        if (!ret)
+                do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count)--; } while (0); } while (0); do { if (__builtin_expect(!!(test_thread_flag(3)), 0)) preempt_schedule(); } while (0); } while (0);
+        return ret;
+
+
+
+
+}
+
+
+
+
+static inline __attribute__((always_inline)) void bit_spin_unlock(int bitnum, unsigned long *addr)
+{
+
+        do { if (__builtin_expect(!!((!(__builtin_constant_p(bitnum) ? constant_test_bit((bitnum),(addr)) : variable_test_bit((bitnum),(addr))))!=0), 0)) __asm__ __volatile__( "ud2\n" "\t.word %c0\n" "\t.long %c1\n" : : "i" (511), "i" ("include/linux/spinlock.h")); } while(0);
+        __asm__ __volatile__("": : :"memory");
+        clear_bit(bitnum, addr);
+
+        do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count)--; } while (0); } while (0); do { if (__builtin_expect(!!(test_thread_flag(3)), 0)) preempt_schedule(); } while (0); } while (0);
+}
+
+
+
+
+static inline __attribute__((always_inline)) int bit_spin_is_locked(int bitnum, unsigned long *addr)
+{
+
+        return (__builtin_constant_p(bitnum) ? constant_test_bit((bitnum),(addr)) : variable_test_bit((bitnum),(addr)));
+
+
+
+
+
+}
+# 9 "include/linux/mmzone.h" 2
+# 1 "include/linux/list.h" 1
+
+
+
+
+
+
+# 1 "include/linux/prefetch.h" 1
+# 58 "include/linux/prefetch.h"
+static inline __attribute__((always_inline)) void prefetch_range(void *addr, size_t len)
+{
+
+        char *cp;
+        char *end = addr + len;
+
+        for (cp = addr; cp < end; cp += (4*(1 << (7))))
+                prefetch(cp);
+
+}
+# 8 "include/linux/list.h" 2
+# 28 "include/linux/list.h"
+struct list_head {
+        struct list_head *next, *prev;
+};
+# 47 "include/linux/list.h"
+static inline __attribute__((always_inline)) void __list_add(struct list_head *newx,
+                              struct list_head *prev,
+                              struct list_head *next)
+{
+        next->prev = newx;
+        newx->next = next;
+        newx->prev = prev;
+        prev->next = newx;
+}
+# 65 "include/linux/list.h"
+static inline __attribute__((always_inline)) void list_add(struct list_head *newx, struct list_head *head)
+{
+        __list_add(newx, head, head->next);
+}
+# 78 "include/linux/list.h"
+static inline __attribute__((always_inline)) void list_add_tail(struct list_head *newx, struct list_head *head)
+{
+        __list_add(newx, head->prev, head);
+}
+
+
+
+
+
+
+
+static inline __attribute__((always_inline)) void __list_add_rcu(struct list_head * newx,
+                struct list_head * prev, struct list_head * next)
+{
+        newx->next = next;
+        newx->prev = prev;
+        __asm__ __volatile__ ("": : :"memory");
+        next->prev = newx;
+        prev->next = newx;
+}
+# 115 "include/linux/list.h"
+static inline __attribute__((always_inline)) void list_add_rcu(struct list_head *newx, struct list_head *head)
+{
+        __list_add_rcu(newx, head, head->next);
+}
+# 136 "include/linux/list.h"
+static inline __attribute__((always_inline)) void list_add_tail_rcu(struct list_head *newx,
+                                        struct list_head *head)
+{
+        __list_add_rcu(newx, head->prev, head);
+}
+# 149 "include/linux/list.h"
+static inline __attribute__((always_inline)) void __list_del(struct list_head * prev, struct list_head * next)
+{
+        next->prev = prev;
+        prev->next = next;
+}
+
+
+
+
+
+
+
+static inline __attribute__((always_inline)) void list_del(struct list_head *entry)
+{
+        __list_del(entry->prev, entry->next);
+        entry->next = ((void *) 0x00100100);
+        entry->prev = ((void *) 0x00200200);
+}
+# 192 "include/linux/list.h"
+static inline __attribute__((always_inline)) void list_del_rcu(struct list_head *entry)
+{
+        __list_del(entry->prev, entry->next);
+        entry->prev = ((void *) 0x00200200);
+}
+# 205 "include/linux/list.h"
+static inline __attribute__((always_inline)) void list_replace_rcu(struct list_head *old, struct list_head *newx){
+        newx->next = old->next;
+        newx->prev = old->prev;
+        __asm__ __volatile__ ("": : :"memory");
+        newx->next->prev = newx;
+        newx->prev->next = newx;
+}
+
+
+
+
+
+static inline __attribute__((always_inline)) void list_del_init(struct list_head *entry)
+{
+        __list_del(entry->prev, entry->next);
+        do { (entry)->next = (entry); (entry)->prev = (entry); } while (0);
+}
+
+
+
+
+
+
+static inline __attribute__((always_inline)) void list_move(struct list_head *list, struct list_head *head)
+{
+        __list_del(list->prev, list->next);
+        list_add(list, head);
+}
+
+
+
+
+
+
+static inline __attribute__((always_inline)) void list_move_tail(struct list_head *list,
+                                  struct list_head *head)
+{
+        __list_del(list->prev, list->next);
+        list_add_tail(list, head);
+}
+
+
+
+
+
+static inline __attribute__((always_inline)) int list_empty(const struct list_head *head)
+{
+        return head->next == head;
+}
+# 267 "include/linux/list.h"
+static inline __attribute__((always_inline)) int list_empty_careful(const struct list_head *head)
+{
+        struct list_head *next = head->next;
+        return (next == head) && (next == head->prev);
+}
+
+static inline __attribute__((always_inline)) void __list_splice(struct list_head *list,
+                                 struct list_head *head)
+{
+        struct list_head *first = list->next;
+        struct list_head *last = list->prev;
+        struct list_head *at = head->next;
+
+        first->prev = head;
+        head->next = first;
+
+        last->next = at;
+        at->prev = last;
+}
+
+
+
+
+
+
+static inline __attribute__((always_inline)) void list_splice(struct list_head *list, struct list_head *head)
+{
+        if (!list_empty(list))
+                __list_splice(list, head);
+}
+# 305 "include/linux/list.h"
+static inline __attribute__((always_inline)) void list_splice_init(struct list_head *list,
+                                    struct list_head *head)
+{
+        if (!list_empty(list)) {
+                __list_splice(list, head);
+                do { (list)->next = (list); (list)->prev = (list); } while (0);
+        }
+}
+# 499 "include/linux/list.h"
+struct hlist_head {
+        struct hlist_node *first;
+};
+
+struct hlist_node {
+        struct hlist_node *next, **pprev;
+};
+
+
+
+
+
+
+static inline __attribute__((always_inline)) int hlist_unhashed(const struct hlist_node *h)
+{
+        return !h->pprev;
+}
+
+static inline __attribute__((always_inline)) int hlist_empty(const struct hlist_head *h)
+{
+        return !h->first;
+}
+
+static inline __attribute__((always_inline)) void __hlist_del(struct hlist_node *n)
+{
+        struct hlist_node *next = n->next;
+        struct hlist_node **pprev = n->pprev;
+        *pprev = next;
+        if (next)
+                next->pprev = pprev;
+}
+
+static inline __attribute__((always_inline)) void hlist_del(struct hlist_node *n)
+{
+        __hlist_del(n);
+        n->next = ((void *) 0x00100100);
+        n->pprev = ((void *) 0x00200200);
+}
+# 557 "include/linux/list.h"
+static inline __attribute__((always_inline)) void hlist_del_rcu(struct hlist_node *n)
+{
+        __hlist_del(n);
+        n->pprev = ((void *) 0x00200200);
+}
+
+static inline __attribute__((always_inline)) void hlist_del_init(struct hlist_node *n)
+{
+        if (n->pprev) {
+                __hlist_del(n);
+                ((n)->next = 0, (n)->pprev = 0);
+        }
+}
+
+
+
+static inline __attribute__((always_inline)) void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
+{
+        struct hlist_node *first = h->first;
+        n->next = first;
+        if (first)
+                first->pprev = &n->next;
+        h->first = n;
+        n->pprev = &h->first;
+}
+# 600 "include/linux/list.h"
+static inline __attribute__((always_inline)) void hlist_add_head_rcu(struct hlist_node *n,
+                                        struct hlist_head *h)
+{
+        struct hlist_node *first = h->first;
+        n->next = first;
+        n->pprev = &h->first;
+        __asm__ __volatile__ ("": : :"memory");
+        if (first)
+                first->pprev = &n->next;
+        h->first = n;
+}
+
+
+static inline __attribute__((always_inline)) void hlist_add_before(struct hlist_node *n,
+                                        struct hlist_node *next)
+{
+        n->pprev = next->pprev;
+        n->next = next;
+        next->pprev = &n->next;
+        *(n->pprev) = n;
+}
+
+static inline __attribute__((always_inline)) void hlist_add_after(struct hlist_node *n,
+                                        struct hlist_node *next)
+{
+        next->next = n->next;
+        n->next = next;
+        next->pprev = &n->next;
+
+        if(next->next)
+                next->next->pprev = &next->next;
+}
+# 10 "include/linux/mmzone.h" 2
+# 1 "include/linux/wait.h" 1
+# 28 "include/linux/wait.h"
+typedef struct __wait_queue wait_queue_t;
+typedef int (*wait_queue_func_t)(wait_queue_t *wait, unsigned mode, int sync, void *key);
+int default_wake_function(wait_queue_t *wait, unsigned mode, int sync, void *key);
+
+struct __wait_queue {
+        unsigned int flags;
+
+        struct task_struct * task;
+        wait_queue_func_t func;
+        struct list_head task_list;
+};
+
+struct __wait_queue_head {
+        spinlock_t lock;
+        struct list_head task_list;
+};
+typedef struct __wait_queue_head wait_queue_head_t;
+# 66 "include/linux/wait.h"
+static inline __attribute__((always_inline)) void init_waitqueue_head(wait_queue_head_t *q)
+{
+        q->lock = (spinlock_t) { 1 };
+        do { (&q->task_list)->next = (&q->task_list); (&q->task_list)->prev = (&q->task_list); } while (0);
+}
+
+static inline __attribute__((always_inline)) void init_waitqueue_entry(wait_queue_t *q, struct task_struct *p)
+{
+        q->flags = 0;
+        q->task = p;
+        q->func = default_wake_function;
+}
+
+static inline __attribute__((always_inline)) void init_waitqueue_func_entry(wait_queue_t *q,
+                                        wait_queue_func_t func)
+{
+        q->flags = 0;
+        q->task = 0;
+        q->func = func;
+}
+
+static inline __attribute__((always_inline)) int waitqueue_active(wait_queue_head_t *q)
+{
+        return !list_empty(&q->task_list);
+}
+# 101 "include/linux/wait.h"
+extern void add_wait_queue(wait_queue_head_t *q, wait_queue_t * wait) __attribute__((regparm(3)));
+extern void add_wait_queue_exclusive(wait_queue_head_t *q, wait_queue_t * wait) __attribute__((regparm(3)));
+extern void remove_wait_queue(wait_queue_head_t *q, wait_queue_t * wait) __attribute__((regparm(3)));
+
+static inline __attribute__((always_inline)) void __add_wait_queue(wait_queue_head_t *head, wait_queue_t *newx)
+{
+        list_add(&newx->task_list, &head->task_list);
+}
+
+
+
+
+static inline __attribute__((always_inline)) void __add_wait_queue_tail(wait_queue_head_t *head,
+                                                wait_queue_t *newx)
+{
+        list_add_tail(&newx->task_list, &head->task_list);
+}
+
+static inline __attribute__((always_inline)) void __remove_wait_queue(wait_queue_head_t *head,
+                                                        wait_queue_t *old)
+{
+        list_del(&old->task_list);
+}
+
+void __wake_up(wait_queue_head_t *q, unsigned int mode, int nr, void *key) __attribute__((regparm(3)));
+extern void __wake_up_locked(wait_queue_head_t *q, unsigned int mode) __attribute__((regparm(3)));
+extern void __wake_up_sync(wait_queue_head_t *q, unsigned int mode, int nr) __attribute__((regparm(3)));
+# 266 "include/linux/wait.h"
+static inline __attribute__((always_inline)) void add_wait_queue_exclusive_locked(wait_queue_head_t *q,
+                                                   wait_queue_t * wait)
+{
+        wait->flags |= 0x01;
+        __add_wait_queue_tail(q, wait);
+}
+
+
+
+
+static inline __attribute__((always_inline)) void remove_wait_queue_locked(wait_queue_head_t *q,
+                                            wait_queue_t * wait)
+{
+        __remove_wait_queue(q, wait);
+}
+
+
+
+
+
+
+extern void sleep_on(wait_queue_head_t *q) __attribute__((regparm(3)));
+extern long sleep_on_timeout(wait_queue_head_t *q, signed long timeout) __attribute__((regparm(3)));
+
+extern void interruptible_sleep_on(wait_queue_head_t *q) __attribute__((regparm(3)));
+extern long interruptible_sleep_on_timeout(wait_queue_head_t *q, signed long timeout) __attribute__((regparm(3)));
+
+
+
+
+
+void prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, int state) __attribute__((regparm(3)));
+
+void prepare_to_wait_exclusive(wait_queue_head_t *q, wait_queue_t *wait, int state) __attribute__((regparm(3)));
+
+void finish_wait(wait_queue_head_t *q, wait_queue_t *wait) __attribute__((regparm(3)));
+int autoremove_wake_function(wait_queue_t *wait, unsigned mode, int sync, void *key);
+# 11 "include/linux/mmzone.h" 2
+
+
+# 1 "include/linux/numa.h" 1
+# 14 "include/linux/mmzone.h" 2
+# 23 "include/linux/mmzone.h"
+struct free_area {
+        struct list_head free_list;
+        unsigned long *map;
+};
+
+struct pglist_data;
+# 37 "include/linux/mmzone.h"
+struct zone_padding {
+        int x;
+} __attribute__((__aligned__(1 << (7))));
+
+
+
+
+
+struct per_cpu_pages {
+        int count;
+        int low;
+        int high;
+        int batch;
+        struct list_head list;
+};
+
+struct per_cpu_pageset {
+        struct per_cpu_pages pcp[2];
+# 63 "include/linux/mmzone.h"
+} __attribute__((__aligned__((1 << (7)))));
+# 110 "include/linux/mmzone.h"
+struct zone {
+
+
+
+        spinlock_t lock;
+        unsigned long free_pages;
+        unsigned long pages_min, pages_low, pages_high;
+# 129 "include/linux/mmzone.h"
+        unsigned long protection[3];
+
+        struct zone_padding _pad1_;
+
+        spinlock_t lru_lock;
+        struct list_head active_list;
+        struct list_head inactive_list;
+        unsigned long nr_scan_active;
+        unsigned long nr_scan_inactive;
+        unsigned long nr_active;
+        unsigned long nr_inactive;
+        int all_unreclaimable;
+        unsigned long pages_scanned;
+
+        struct zone_padding _pad2_;
+# 161 "include/linux/mmzone.h"
+        int temp_priority;
+        int prev_priority;
+
+
+
+
+        struct free_area free_area[11];
+# 193 "include/linux/mmzone.h"
+        wait_queue_head_t * wait_table;
+        unsigned long wait_table_size;
+        unsigned long wait_table_bits;
+
+        struct zone_padding _pad3_;
+
+        struct per_cpu_pageset pageset[8];
+
+
+
+
+        struct pglist_data *zone_pgdat;
+        struct page *zone_mem_map;
+
+        unsigned long zone_start_pfn;
+
+
+
+
+        char *name;
+        unsigned long spanned_pages;
+        unsigned long present_pages;
+} __attribute__((__aligned__(1 << (7))));
+# 236 "include/linux/mmzone.h"
+struct zonelist {
+        struct zone *zones[(1 << 0) * 3 + 1];
+};
+# 252 "include/linux/mmzone.h"
+struct bootmem_data;
+typedef struct pglist_data {
+        struct zone node_zones[3];
+        struct zonelist node_zonelists[((0x03 + 1) / 2 + 1)];
+        int nr_zones;
+        struct page *node_mem_map;
+        struct bootmem_data *bdata;
+        unsigned long node_start_pfn;
+        unsigned long node_present_pages;
+        unsigned long node_spanned_pages;
+
+        int node_id;
+        struct pglist_data *pgdat_next;
+        wait_queue_head_t kswapd_wait;
+        struct task_struct *kswapd;
+} pg_data_t;
+
+
+
+
+extern int numnodes;
+extern struct pglist_data *pgdat_list;
+
+void __get_zone_counts(unsigned long *active, unsigned long *inactive,
+                        unsigned long *free, struct pglist_data *pgdat);
+void get_zone_counts(unsigned long *active, unsigned long *inactive,
+                        unsigned long *free);
+void build_all_zonelists(void);
+void wakeup_kswapd(struct zone *zone);
+# 305 "include/linux/mmzone.h"
+static inline __attribute__((always_inline)) struct zone *next_zone(struct zone *zone)
+{
+        pg_data_t *pgdat = zone->zone_pgdat;
+
+        if (zone - pgdat->node_zones < 3 - 1)
+                zone++;
+        else if (pgdat->pgdat_next) {
+                pgdat = pgdat->pgdat_next;
+                zone = pgdat->node_zones;
+        } else
+                zone = 0;
+
+        return zone;
+}
+# 338 "include/linux/mmzone.h"
+static inline __attribute__((always_inline)) int is_highmem_idx(int idx)
+{
+        return (idx == 2);
+}
+
+static inline __attribute__((always_inline)) int is_normal_idx(int idx)
+{
+        return (idx == 1);
+}
+
+
+
+
+
+
+static inline __attribute__((always_inline)) int is_highmem(struct zone *zone)
+{
+        return (is_highmem_idx(zone - zone->zone_pgdat->node_zones));
+}
+
+static inline __attribute__((always_inline)) int is_normal(struct zone *zone)
+{
+        return (is_normal_idx(zone - zone->zone_pgdat->node_zones));
+}
+
+
+struct ctl_table;
+struct file;
+int min_free_kbytes_sysctl_handler(struct ctl_table *, int, struct file *,
+                                        void *, size_t *, loff_t *);
+int lower_zone_protection_sysctl_handler(struct ctl_table *, int, struct file *,
+                                        void *, size_t *, loff_t *);
+
+# 1 "include/linux/topology.h" 1
+# 30 "include/linux/topology.h"
+# 1 "include/linux/cpumask.h" 1
+# 78 "include/linux/cpumask.h"
+# 1 "include/linux/bitmap.h" 1
+
+
+
+
+
+
+
+# 1 "include/linux/string.h" 1
+# 13 "include/linux/string.h"
+extern "C" {
+
+
+extern char * strpbrk(const char *,const char *);
+extern char * strsep(char **,const char *);
+extern __kernel_size_t strspn(const char *,const char *);
+extern __kernel_size_t strcspn(const char *,const char *);
+
+
+
+
+# 1 "include/asm/string.h" 1
+# 31 "include/asm/string.h"
+static inline __attribute__((always_inline)) char * strcpy(char * dest,const char *src)
+{
+int d0, d1, d2;
+__asm__ __volatile__(
+        "1:\tlodsb\n\t"
+        "stosb\n\t"
+        "testb %%al,%%al\n\t"
+        "jne 1b"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+        :"0" (src),"1" (dest) : "memory");
+return dest;
+}
+
+
+static inline __attribute__((always_inline)) char * strncpy(char * dest,const char *src,size_t count)
+{
+int d0, d1, d2, d3;
+__asm__ __volatile__(
+        "1:\tdecl %2\n\t"
+        "js 2f\n\t"
+        "lodsb\n\t"
+        "stosb\n\t"
+        "testb %%al,%%al\n\t"
+        "jne 1b\n\t"
+        "rep\n\t"
+        "stosb\n"
+        "2:"
+        : "=&S" (d0), "=&D" (d1), "=&c" (d2), "=&a" (d3)
+        :"0" (src),"1" (dest),"2" (count) : "memory");
+return dest;
+}
+
+
+static inline __attribute__((always_inline)) char * strcat(char * dest,const char * src)
+{
+int d0, d1, d2, d3;
+__asm__ __volatile__(
+        "repne\n\t"
+        "scasb\n\t"
+        "decl %1\n"
+        "1:\tlodsb\n\t"
+        "stosb\n\t"
+        "testb %%al,%%al\n\t"
+        "jne 1b"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3)
+        : "0" (src), "1" (dest), "2" (0), "3" (0xffffffffu):"memory");
+return dest;
+}
+
+
+static inline __attribute__((always_inline)) char * strncat(char * dest,const char * src,size_t count)
+{
+int d0, d1, d2, d3;
+__asm__ __volatile__(
+        "repne\n\t"
+        "scasb\n\t"
+        "decl %1\n\t"
+        "movl %8,%3\n"
+        "1:\tdecl %3\n\t"
+        "js 2f\n\t"
+        "lodsb\n\t"
+        "stosb\n\t"
+        "testb %%al,%%al\n\t"
+        "jne 1b\n"
+        "2:\txorl %2,%2\n\t"
+        "stosb"
+        : "=&S" (d0), "=&D" (d1), "=&a" (d2), "=&c" (d3)
+        : "0" (src),"1" (dest),"2" (0),"3" (0xffffffffu), "g" (count)
+        : "memory");
+return dest;
+}
+
+
+static inline __attribute__((always_inline)) int strcmp(const char * cs,const char * ct)
+{
+int d0, d1;
+register int __res;
+__asm__ __volatile__(
+        "1:\tlodsb\n\t"
+        "scasb\n\t"
+        "jne 2f\n\t"
+        "testb %%al,%%al\n\t"
+        "jne 1b\n\t"
+        "xorl %%eax,%%eax\n\t"
+        "jmp 3f\n"
+        "2:\tsbbl %%eax,%%eax\n\t"
+        "orb $1,%%al\n"
+        "3:"
+        :"=a" (__res), "=&S" (d0), "=&D" (d1)
+                     :"1" (cs),"2" (ct));
+return __res;
+}
+
+
+static inline __attribute__((always_inline)) int strncmp(const char * cs,const char * ct,size_t count)
+{
+register int __res;
+int d0, d1, d2;
+__asm__ __volatile__(
+        "1:\tdecl %3\n\t"
+        "js 2f\n\t"
+        "lodsb\n\t"
+        "scasb\n\t"
+        "jne 3f\n\t"
+        "testb %%al,%%al\n\t"
+        "jne 1b\n"
+        "2:\txorl %%eax,%%eax\n\t"
+        "jmp 4f\n"
+        "3:\tsbbl %%eax,%%eax\n\t"
+        "orb $1,%%al\n"
+        "4:"
+                     :"=a" (__res), "=&S" (d0), "=&D" (d1), "=&c" (d2)
+                     :"1" (cs),"2" (ct),"3" (count));
+return __res;
+}
+
+
+static inline __attribute__((always_inline)) char * strchr(const char * s, int c)
+{
+int d0;
+register char * __res;
+__asm__ __volatile__(
+        "movb %%al,%%ah\n"
+        "1:\tlodsb\n\t"
+        "cmpb %%ah,%%al\n\t"
+        "je 2f\n\t"
+        "testb %%al,%%al\n\t"
+        "jne 1b\n\t"
+        "movl $1,%1\n"
+        "2:\tmovl %1,%0\n\t"
+        "decl %0"
+        :"=a" (__res), "=&S" (d0) : "1" (s),"0" (c));
+return __res;
+}
+
+
+static inline __attribute__((always_inline)) char * strrchr(const char * s, int c)
+{
+int d0, d1;
+register char * __res;
+__asm__ __volatile__(
+        "movb %%al,%%ah\n"
+        "1:\tlodsb\n\t"
+        "cmpb %%ah,%%al\n\t"
+        "jne 2f\n\t"
+        "leal -1(%%esi),%0\n"
+        "2:\ttestb %%al,%%al\n\t"
+        "jne 1b"
+        :"=g" (__res), "=&S" (d0), "=&a" (d1) :"0" (0),"1" (s),"2" (c));
+return __res;
+}
+
+
+
+
+static inline __attribute__((always_inline)) size_t strlen(const char * s)
+{
+int d0;
+register int __res;
+__asm__ __volatile__(
+        "repne\n\t"
+        "scasb\n\t"
+        "notl %0\n\t"
+        "decl %0"
+        :"=c" (__res), "=&D" (d0) :"1" (s),"a" (0), "0" (0xffffffffu));
+return __res;
+}
+
+static inline __attribute__((always_inline)) void * __memcpy(void * to, const void * from, size_t n)
+{
+int d0, d1, d2;
+__asm__ __volatile__(
+        "rep ; movsl\n\t"
+        "testb $2,%b4\n\t"
+        "je 1f\n\t"
+        "movsw\n"
+        "1:\ttestb $1,%b4\n\t"
+        "je 2f\n\t"
+        "movsb\n"
+        "2:"
+        : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+        :"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
+        : "memory");
+return (to);
+}
+
+
+
+
+
+static inline __attribute__((always_inline)) void * __constant_memcpy(void * to, const void * from, size_t n)
+{
+        if (n <= 128)
+                return __builtin_memcpy(to, from, n);
+# 233 "include/asm/string.h"
+{
+        int d0, d1, d2;
+        switch (n % 4) {
+                case 0: __asm__ __volatile__( "rep ; movsl" "" : "=&c" (d0), "=&D" (d1), "=&S" (d2) : "0" (n/4),"1" ((long) to),"2" ((long) from) : "memory");; return to;
+                case 1: __asm__ __volatile__( "rep ; movsl" "\n\tmovsb" : "=&c" (d0), "=&D" (d1), "=&S" (d2) : "0" (n/4),"1" ((long) to),"2" ((long) from) : "memory");; return to;
+                case 2: __asm__ __volatile__( "rep ; movsl" "\n\tmovsw" : "=&c" (d0), "=&D" (d1), "=&S" (d2) : "0" (n/4),"1" ((long) to),"2" ((long) from) : "memory");; return to;
+                default: __asm__ __volatile__( "rep ; movsl" "\n\tmovsw\n\tmovsb" : "=&c" (d0), "=&D" (d1), "=&S" (d2) : "0" (n/4),"1" ((long) to),"2" ((long) from) : "memory");; return to;
+        }
+}
+
+
+}
+# 289 "include/asm/string.h"
+void *memmove(void * dest,const void * src, size_t n);
+
+
+
+
+static inline __attribute__((always_inline)) void * memchr(const void * cs,int c,size_t count)
+{
+int d0;
+register void * __res;
+if (!count)
+        return 0;
+__asm__ __volatile__(
+        "repne\n\t"
+        "scasb\n\t"
+        "je 1f\n\t"
+        "movl $1,%0\n"
+        "1:\tdecl %0"
+        :"=D" (__res), "=&c" (d0) : "a" (c),"0" (cs),"1" (count));
+return __res;
+}
+
+static inline __attribute__((always_inline)) void * __memset_generic(void * s, char c,size_t count)
+{
+int d0, d1;
+__asm__ __volatile__(
+        "rep\n\t"
+        "stosb"
+        : "=&c" (d0), "=&D" (d1)
+        :"a" (c),"1" (s),"0" (count)
+        :"memory");
+return s;
+}
+# 330 "include/asm/string.h"
+static inline __attribute__((always_inline)) void * __constant_c_memset(void * s, unsigned long c, size_t count)
+{
+int d0, d1;
+__asm__ __volatile__(
+        "rep ; stosl\n\t"
+        "testb $2,%b3\n\t"
+        "je 1f\n\t"
+        "stosw\n"
+        "1:\ttestb $1,%b3\n\t"
+        "je 2f\n\t"
+        "stosb\n"
+        "2:"
+        : "=&c" (d0), "=&D" (d1)
+        :"a" (c), "q" (count), "0" (count/4), "1" ((long) s)
+        :"memory");
+return (s);
+}
+
+
+
+static inline __attribute__((always_inline)) size_t strnlen(const char * s, size_t count)
+{
+int d0;
+register int __res;
+__asm__ __volatile__(
+        "movl %2,%0\n\t"
+        "jmp 2f\n"
+        "1:\tcmpb $0,(%0)\n\t"
+        "je 3f\n\t"
+        "incl %0\n"
+        "2:\tdecl %1\n\t"
+        "cmpl $-1,%1\n\t"
+        "jne 1b\n"
+        "3:\tsubl %2,%0"
+        :"=a" (__res), "=&d" (d0)
+        :"c" (s),"1" (count));
+return __res;
+}
+
+
+
+
+extern char *strstr(const char *cs, const char *ct);
+
+
+
+
+
+static inline __attribute__((always_inline)) void * __constant_c_and_count_memset(void * s, unsigned long pattern, size_t count)
+{
+        switch (count) {
+                case 0:
+                        return s;
+                case 1:
+                        *(unsigned char *)s = pattern;
+                        return s;
+                case 2:
+                        *(unsigned short *)s = pattern;
+                        return s;
+                case 3:
+                        *(unsigned short *)s = pattern;
+                        *(2+(unsigned char *)s) = pattern;
+                        return s;
+                case 4:
+                        *(unsigned long *)s = pattern;
+                        return s;
+        }
+
+
+
+
+
+
+
+{
+        int d0, d1;
+        switch (count % 4) {
+                case 0: __asm__ __volatile__( "rep ; stosl" "" : "=&c" (d0), "=&D" (d1) : "a" (pattern),"0" (count/4),"1" ((long) s) : "memory"); return s;
+                case 1: __asm__ __volatile__( "rep ; stosl" "\n\tstosb" : "=&c" (d0), "=&D" (d1) : "a" (pattern),"0" (count/4),"1" ((long) s) : "memory"); return s;
+                case 2: __asm__ __volatile__( "rep ; stosl" "\n\tstosw" : "=&c" (d0), "=&D" (d1) : "a" (pattern),"0" (count/4),"1" ((long) s) : "memory"); return s;
+                default: __asm__ __volatile__( "rep ; stosl" "\n\tstosw\n\tstosb" : "=&c" (d0), "=&D" (d1) : "a" (pattern),"0" (count/4),"1" ((long) s) : "memory"); return s;
+        }
+}
+
+
+}
+# 437 "include/asm/string.h"
+static inline __attribute__((always_inline)) void * memscan(void * addr, int c, size_t size)
+{
+        if (!size)
+                return addr;
+        __asm__("repnz; scasb\n\t"
+                "jnz 1f\n\t"
+                "dec %%edi\n"
+                "1:"
+                : "=D" (addr), "=c" (size)
+                : "0" (addr), "1" (size), "a" (c));
+        return addr;
+}
+# 25 "include/linux/string.h" 2
+# 33 "include/linux/string.h"
+size_t strlcpy(char *, const char *, size_t);
+# 42 "include/linux/string.h"
+extern size_t strlcat(char *, const char *, __kernel_size_t);
+# 51 "include/linux/string.h"
+extern int strnicmp(const char *, const char *, __kernel_size_t);
+
+
+
+
+
+extern char * strnchr(const char *, size_t, int);
+# 85 "include/linux/string.h"
+extern int __builtin_memcmp(const void *,const void *,__kernel_size_t);
+
+
+
+
+
+
+}
+# 9 "include/linux/bitmap.h" 2
+# 73 "include/linux/bitmap.h"
+extern int __bitmap_empty(const unsigned long *bitmap, int bits);
+extern int __bitmap_full(const unsigned long *bitmap, int bits);
+extern int __bitmap_equal(const unsigned long *bitmap1,
+                        const unsigned long *bitmap2, int bits);
+extern void __bitmap_complement(unsigned long *dst, const unsigned long *src,
+                        int bits);
+extern void __bitmap_shift_right(unsigned long *dst,
+                        const unsigned long *src, int shift, int bits);
+extern void __bitmap_shift_left(unsigned long *dst,
+                        const unsigned long *src, int shift, int bits);
+extern void __bitmap_and(unsigned long *dst, const unsigned long *bitmap1,
+                        const unsigned long *bitmap2, int bits);
+extern void __bitmap_or(unsigned long *dst, const unsigned long *bitmap1,
+                        const unsigned long *bitmap2, int bits);
+extern void __bitmap_xor(unsigned long *dst, const unsigned long *bitmap1,
+                        const unsigned long *bitmap2, int bits);
+extern void __bitmap_andnot(unsigned long *dst, const unsigned long *bitmap1,
+                        const unsigned long *bitmap2, int bits);
+extern int __bitmap_intersects(const unsigned long *bitmap1,
+                        const unsigned long *bitmap2, int bits);
+extern int __bitmap_subset(const unsigned long *bitmap1,
+                        const unsigned long *bitmap2, int bits);
+extern int __bitmap_weight(const unsigned long *bitmap, int bits);
+
+extern int bitmap_scnprintf(char *buf, unsigned int len,
+                        const unsigned long *src, int nbits);
+extern int bitmap_parse(const char *ubuf, unsigned int ulen,
+                        unsigned long *dst, int nbits);
+extern int bitmap_find_free_region(unsigned long *bitmap, int bits, int order);
+extern void bitmap_release_region(unsigned long *bitmap, int pos, int order);
+extern int bitmap_allocate_region(unsigned long *bitmap, int pos, int order);
+
+
+
+
+
+
+
+static inline __attribute__((always_inline)) void bitmap_zero(unsigned long *dst, int nbits)
+{
+        if (nbits <= 32)
+                *dst = 0UL;
+        else {
+                int len = (((nbits)+32 -1)/32) * sizeof(unsigned long);
+                (__builtin_constant_p(0) ? (__builtin_constant_p((len)) ? __constant_c_and_count_memset(((dst)),((0x01010101UL*(unsigned char)(0))),((len))) : __constant_c_memset(((dst)),((0x01010101UL*(unsigned char)(0))),((len)))) : (__builtin_constant_p((len)) ? __memset_generic((((dst))),(((0))),(((len)))) : __memset_generic(((dst)),((0)),((len)))));
+        }
+}
+
+static inline __attribute__((always_inline)) void bitmap_fill(unsigned long *dst, int nbits)
+{
+        size_t nlongs = (((nbits)+32 -1)/32);
+        if (nlongs > 1) {
+                int len = (nlongs - 1) * sizeof(unsigned long);
+                (__builtin_constant_p(0xff) ? (__builtin_constant_p((len)) ? __constant_c_and_count_memset(((dst)),((0x01010101UL*(unsigned char)(0xff))),((len))) : __constant_c_memset(((dst)),((0x01010101UL*(unsigned char)(0xff))),((len)))) : (__builtin_constant_p((len)) ? __memset_generic((((dst))),(((0xff))),(((len)))) : __memset_generic(((dst)),((0xff)),((len)))));
+        }
+        dst[nlongs - 1] = ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL );
+}
+
+static inline __attribute__((always_inline)) void bitmap_copy(unsigned long *dst, const unsigned long *src,
+                        int nbits)
+{
+        if (nbits <= 32)
+                *dst = *src;
+        else {
+                int len = (((nbits)+32 -1)/32) * sizeof(unsigned long);
+                (__builtin_constant_p(len) ? __constant_memcpy((dst),(src),(len)) : __memcpy((dst),(src),(len)));
+        }
+}
+
+static inline __attribute__((always_inline)) void bitmap_and(unsigned long *dst, const unsigned long *src1,
+                        const unsigned long *src2, int nbits)
+{
+        if (nbits <= 32)
+                *dst = *src1 & *src2;
+        else
+                __bitmap_and(dst, src1, src2, nbits);
+}
+
+static inline __attribute__((always_inline)) void bitmap_or(unsigned long *dst, const unsigned long *src1,
+                        const unsigned long *src2, int nbits)
+{
+        if (nbits <= 32)
+                *dst = *src1 | *src2;
+        else
+                __bitmap_or(dst, src1, src2, nbits);
+}
+
+static inline __attribute__((always_inline)) void bitmap_xor(unsigned long *dst, const unsigned long *src1,
+                        const unsigned long *src2, int nbits)
+{
+        if (nbits <= 32)
+                *dst = *src1 ^ *src2;
+        else
+                __bitmap_xor(dst, src1, src2, nbits);
+}
+
+static inline __attribute__((always_inline)) void bitmap_andnot(unsigned long *dst, const unsigned long *src1,
+                        const unsigned long *src2, int nbits)
+{
+        if (nbits <= 32)
+                *dst = *src1 & ~(*src2);
+        else
+                __bitmap_andnot(dst, src1, src2, nbits);
+}
+
+static inline __attribute__((always_inline)) void bitmap_complement(unsigned long *dst, const unsigned long *src,
+                        int nbits)
+{
+        if (nbits <= 32)
+                *dst = ~(*src) & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL );
+        else
+                __bitmap_complement(dst, src, nbits);
+}
+
+static inline __attribute__((always_inline)) int bitmap_equal(const unsigned long *src1,
+                        const unsigned long *src2, int nbits)
+{
+        if (nbits <= 32)
+                return ! ((*src1 ^ *src2) & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL ));
+        else
+                return __bitmap_equal(src1, src2, nbits);
+}
+
+static inline __attribute__((always_inline)) int bitmap_intersects(const unsigned long *src1,
+                        const unsigned long *src2, int nbits)
+{
+        if (nbits <= 32)
+                return ((*src1 & *src2) & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL )) != 0;
+        else
+                return __bitmap_intersects(src1, src2, nbits);
+}
+
+static inline __attribute__((always_inline)) int bitmap_subset(const unsigned long *src1,
+                        const unsigned long *src2, int nbits)
+{
+        if (nbits <= 32)
+                return ! ((*src1 & ~(*src2)) & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL ));
+        else
+                return __bitmap_subset(src1, src2, nbits);
+}
+
+static inline __attribute__((always_inline)) int bitmap_empty(const unsigned long *src, int nbits)
+{
+        if (nbits <= 32)
+                return ! (*src & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL ));
+        else
+                return __bitmap_empty(src, nbits);
+}
+
+static inline __attribute__((always_inline)) int bitmap_full(const unsigned long *src, int nbits)
+{
+        if (nbits <= 32)
+                return ! (~(*src) & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL ));
+        else
+                return __bitmap_full(src, nbits);
+}
+
+static inline __attribute__((always_inline)) int bitmap_weight(const unsigned long *src, int nbits)
+{
+        return __bitmap_weight(src, nbits);
+}
+
+static inline __attribute__((always_inline)) void bitmap_shift_right(unsigned long *dst,
+                        const unsigned long *src, int n, int nbits)
+{
+        if (nbits <= 32)
+                *dst = *src >> n;
+        else
+                __bitmap_shift_right(dst, src, n, nbits);
+}
+
+static inline __attribute__((always_inline)) void bitmap_shift_left(unsigned long *dst,
+                        const unsigned long *src, int n, int nbits)
+{
+        if (nbits <= 32)
+                *dst = (*src << n) & ( ((nbits) % 32) ? (1UL<<((nbits) % 32))-1 : ~0UL );
+        else
+                __bitmap_shift_left(dst, src, n, nbits);
+}
+# 79 "include/linux/cpumask.h" 2
+
+
+typedef struct { unsigned long bits[(((8)+32 -1)/32)]; } cpumask_t;
+extern cpumask_t _unused_cpumask_arg_;
+
+
+static inline __attribute__((always_inline)) void __cpu_set(int cpu, volatile cpumask_t *dstp)
+{
+        set_bit(cpu, dstp->bits);
+}
+
+
+static inline __attribute__((always_inline)) void __cpu_clear(int cpu, volatile cpumask_t *dstp)
+{
+        clear_bit(cpu, dstp->bits);
+}
+
+
+static inline __attribute__((always_inline)) void __cpus_setall(cpumask_t *dstp, int nbits)
+{
+        bitmap_fill(dstp->bits, nbits);
+}
+
+
+static inline __attribute__((always_inline)) void __cpus_clear(cpumask_t *dstp, int nbits)
+{
+        bitmap_zero(dstp->bits, nbits);
+}
+
+
+
+
+
+static inline __attribute__((always_inline)) int __cpu_test_and_set(int cpu, cpumask_t *addr)
+{
+        return test_and_set_bit(cpu, addr->bits);
+}
+
+
+static inline __attribute__((always_inline)) void __cpus_and(cpumask_t *dstp, const cpumask_t *src1p,
+                                        const cpumask_t *src2p, int nbits)
+{
+        bitmap_and(dstp->bits, src1p->bits, src2p->bits, nbits);
+}
+
+
+static inline __attribute__((always_inline)) void __cpus_or(cpumask_t *dstp, const cpumask_t *src1p,
+                                        const cpumask_t *src2p, int nbits)
+{
+        bitmap_or(dstp->bits, src1p->bits, src2p->bits, nbits);
+}
+
+
+static inline __attribute__((always_inline)) void __cpus_xor(cpumask_t *dstp, const cpumask_t *src1p,
+                                        const cpumask_t *src2p, int nbits)
+{
+        bitmap_xor(dstp->bits, src1p->bits, src2p->bits, nbits);
+}
+
+
+
+static inline __attribute__((always_inline)) void __cpus_andnot(cpumask_t *dstp, const cpumask_t *src1p,
+                                        const cpumask_t *src2p, int nbits)
+{
+        bitmap_andnot(dstp->bits, src1p->bits, src2p->bits, nbits);
+}
+
+
+static inline __attribute__((always_inline)) void __cpus_complement(cpumask_t *dstp,
+                                        const cpumask_t *srcp, int nbits)
+{
+        bitmap_complement(dstp->bits, srcp->bits, nbits);
+}
+
+
+static inline __attribute__((always_inline)) int __cpus_equal(const cpumask_t *src1p,
+                                        const cpumask_t *src2p, int nbits)
+{
+        return bitmap_equal(src1p->bits, src2p->bits, nbits);
+}
+
+
+static inline __attribute__((always_inline)) int __cpus_intersects(const cpumask_t *src1p,
+                                        const cpumask_t *src2p, int nbits)
+{
+        return bitmap_intersects(src1p->bits, src2p->bits, nbits);
+}
+
+
+static inline __attribute__((always_inline)) int __cpus_subset(const cpumask_t *src1p,
+                                        const cpumask_t *src2p, int nbits)
+{
+        return bitmap_subset(src1p->bits, src2p->bits, nbits);
+}
+
+
+static inline __attribute__((always_inline)) int __cpus_empty(const cpumask_t *srcp, int nbits)
+{
+        return bitmap_empty(srcp->bits, nbits);
+}
+
+
+static inline __attribute__((always_inline)) int __cpus_full(const cpumask_t *srcp, int nbits)
+{
+        return bitmap_full(srcp->bits, nbits);
+}
+
+
+static inline __attribute__((always_inline)) int __cpus_weight(const cpumask_t *srcp, int nbits)
+{
+        return bitmap_weight(srcp->bits, nbits);
+}
+
+
+
+static inline __attribute__((always_inline)) void __cpus_shift_right(cpumask_t *dstp,
+                                        const cpumask_t *srcp, int n, int nbits)
+{
+        bitmap_shift_right(dstp->bits, srcp->bits, n, nbits);
+}
+
+
+
+static inline __attribute__((always_inline)) void __cpus_shift_left(cpumask_t *dstp,
+                                        const cpumask_t *srcp, int n, int nbits)
+{
+        bitmap_shift_left(dstp->bits, srcp->bits, n, nbits);
+}
+
+
+static inline __attribute__((always_inline)) int __first_cpu(const cpumask_t *srcp, int nbits)
+{
+        return ({ int __x = (nbits); int __y = (find_first_bit(srcp->bits, nbits)); __x < __y ? __x: __y; });
+}
+
+
+static inline __attribute__((always_inline)) int __next_cpu(int n, const cpumask_t *srcp, int nbits)
+{
+        return ({ int __x = (nbits); int __y = (find_next_bit(srcp->bits, nbits, n+1)); __x < __y ? __x: __y; });
+}
+# 265 "include/linux/cpumask.h"
+static inline __attribute__((always_inline)) int __cpumask_scnprintf(char *buf, int len,
+                                        const cpumask_t *srcp, int nbits)
+{
+        return bitmap_scnprintf(buf, len, srcp->bits, nbits);
+}
+
+
+
+static inline __attribute__((always_inline)) int __cpumask_parse(const char *buf, int len,
+                                        cpumask_t *dstp, int nbits)
+{
+        return bitmap_parse(buf, len, dstp->bits, nbits);
+}
+# 344 "include/linux/cpumask.h"
+extern cpumask_t cpu_possible_map;
+extern cpumask_t cpu_online_map;
+extern cpumask_t cpu_present_map;
+# 31 "include/linux/topology.h" 2
+
+# 1 "include/linux/mmzone.h" 1
+# 33 "include/linux/topology.h" 2
+# 1 "include/linux/smp.h" 1
+# 17 "include/linux/smp.h"
+# 1 "include/asm/smp.h" 1
+# 16 "include/asm/smp.h"
+# 1 "include/asm/fixmap.h" 1
+# 27 "include/asm/fixmap.h"
+# 1 "include/asm/acpi.h" 1
+# 58 "include/asm/acpi.h"
+static inline __attribute__((always_inline)) int
+__acpi_acquire_global_lock (unsigned int *lock)
+{
+        unsigned int old, newx, val;
+        do {
+                old = *lock;
+                newx = (((old & ~0x3) + 2) + ((old >> 1) & 0x1));
+                val = ((__typeof__(*(lock)))__cmpxchg((lock),(unsigned long)(old), (unsigned long)(newx),sizeof(*(lock))));
+        } while (__builtin_expect(!!(val != old), 0));
+        return (newx < 3) ? -1 : 0;
+}
+
+static inline __attribute__((always_inline)) int
+__acpi_release_global_lock (unsigned int *lock)
+{
+        unsigned int old, newx, val;
+        do {
+                old = *lock;
+                newx = old & ~0x3;
+                val = ((__typeof__(*(lock)))__cmpxchg((lock),(unsigned long)(old), (unsigned long)(newx),sizeof(*(lock))));
+        } while (__builtin_expect(!!(val != old), 0));
+        return old & 0x1;
+}
+# 117 "include/asm/acpi.h"
+extern int acpi_lapic;
+extern int acpi_ioapic;
+extern int acpi_noirq;
+extern int acpi_strict;
+extern int acpi_disabled;
+extern int acpi_ht;
+extern int acpi_pci_disabled;
+static inline __attribute__((always_inline)) void disable_acpi(void)
+{
+        acpi_disabled = 1;
+        acpi_ht = 0;
+        acpi_pci_disabled = 1;
+        acpi_noirq = 1;
+}
+
+
+
+
+extern int acpi_gsi_to_irq(u32 gsi, unsigned int *irq);
+extern int (*platform_rename_gsi)(int ioapic, int gsi);
+
+
+extern int skip_ioapic_setup;
+extern int acpi_skip_timer_override;
+
+static inline __attribute__((always_inline)) void disable_ioapic_setup(void)
+{
+        skip_ioapic_setup = 1;
+}
+
+static inline __attribute__((always_inline)) int ioapic_setup_disabled(void)
+{
+        return skip_ioapic_setup;
+}
+# 165 "include/asm/acpi.h"
+static inline __attribute__((always_inline)) void acpi_noirq_set(void) { acpi_noirq = 1; }
+static inline __attribute__((always_inline)) void acpi_disable_pci(void)
+{
+        acpi_pci_disabled = 1;
+        acpi_noirq_set();
+}
+extern int acpi_irq_balance_set(char *str);
+# 181 "include/asm/acpi.h"
+extern int acpi_save_state_mem(void);
+extern int acpi_save_state_disk(void);
+extern void acpi_restore_state_mem(void);
+
+extern unsigned long acpi_wakeup_address;
+
+
+extern void acpi_reserve_bootmem(void);
+
+
+
+extern u8 x86_acpiid_to_apicid[];
+# 28 "include/asm/fixmap.h" 2
+# 1 "include/asm/apicdef.h" 1
+# 127 "include/asm/apicdef.h"
+struct local_apic {
+
+        struct { unsigned int __reserved[4]; } __reserved_01;
+
+        struct { unsigned int __reserved[4]; } __reserved_02;
+
+        struct {
+                unsigned int __reserved_1 : 24,
+                        phys_apic_id : 4,
+                        __reserved_2 : 4;
+                unsigned int __reserved[3];
+        } id;
+
+        const
+        struct {
+                unsigned int version : 8,
+                        __reserved_1 : 8,
+                        max_lvt : 8,
+                        __reserved_2 : 8;
+                unsigned int __reserved[3];
+        } version;
+
+        struct { unsigned int __reserved[4]; } __reserved_03;
+
+        struct { unsigned int __reserved[4]; } __reserved_04;
+
+        struct { unsigned int __reserved[4]; } __reserved_05;
+
+        struct { unsigned int __reserved[4]; } __reserved_06;
+
+        struct {
+                unsigned int priority : 8,
+                        __reserved_1 : 24;
+                unsigned int __reserved_2[3];
+        } tpr;
+
+        const
+        struct {
+                unsigned int priority : 8,
+                        __reserved_1 : 24;
+                unsigned int __reserved_2[3];
+        } apr;
+
+        const
+        struct {
+                unsigned int priority : 8,
+                        __reserved_1 : 24;
+                unsigned int __reserved_2[3];
+        } ppr;
+
+        struct {
+                unsigned int eoi;
+                unsigned int __reserved[3];
+        } eoi;
+
+        struct { unsigned int __reserved[4]; } __reserved_07;
+
+        struct {
+                unsigned int __reserved_1 : 24,
+                        logical_dest : 8;
+                unsigned int __reserved_2[3];
+        } ldr;
+
+        struct {
+                unsigned int __reserved_1 : 28,
+                        model : 4;
+                unsigned int __reserved_2[3];
+        } dfr;
+
+        struct {
+                unsigned int spurious_vector : 8,
+                        apic_enabled : 1,
+                        focus_cpu : 1,
+                        __reserved_2 : 22;
+                unsigned int __reserved_3[3];
+        } svr;
+
+        struct {
+                unsigned int bitfield;
+                unsigned int __reserved[3];
+        } isr [8];
+
+        struct {
+                unsigned int bitfield;
+                unsigned int __reserved[3];
+        } tmr [8];
+
+        struct {
+                unsigned int bitfield;
+                unsigned int __reserved[3];
+        } irr [8];
+
+        union {
+                struct {
+                        unsigned int send_cs_error : 1,
+                                receive_cs_error : 1,
+                                send_accept_error : 1,
+                                receive_accept_error : 1,
+                                __reserved_1 : 1,
+                                send_illegal_vector : 1,
+                                receive_illegal_vector : 1,
+                                illegal_register_address : 1,
+                                __reserved_2 : 24;
+                        unsigned int __reserved_3[3];
+                } error_bits;
+                struct {
+                        unsigned int errors;
+                        unsigned int __reserved_3[3];
+                } all_errors;
+        } esr;
+
+        struct { unsigned int __reserved[4]; } __reserved_08;
+
+        struct { unsigned int __reserved[4]; } __reserved_09;
+
+        struct { unsigned int __reserved[4]; } __reserved_10;
+
+        struct { unsigned int __reserved[4]; } __reserved_11;
+
+        struct { unsigned int __reserved[4]; } __reserved_12;
+
+        struct { unsigned int __reserved[4]; } __reserved_13;
+
+        struct { unsigned int __reserved[4]; } __reserved_14;
+
+        struct {
+                unsigned int vector : 8,
+                        delivery_mode : 3,
+                        destination_mode : 1,
+                        delivery_status : 1,
+                        __reserved_1 : 1,
+                        level : 1,
+                        trigger : 1,
+                        __reserved_2 : 2,
+                        shorthand : 2,
+                        __reserved_3 : 12;
+                unsigned int __reserved_4[3];
+        } icr1;
+
+        struct {
+                union {
+                        unsigned int __reserved_1 : 24,
+                                phys_dest : 4,
+                                __reserved_2 : 4;
+                        unsigned int __reserved_3 : 24,
+                                logical_dest : 8;
+                } dest;
+                unsigned int __reserved_4[3];
+        } icr2;
+
+        struct {
+                unsigned int vector : 8,
+                        __reserved_1 : 4,
+                        delivery_status : 1,
+                        __reserved_2 : 3,
+                        mask : 1,
+                        timer_mode : 1,
+                        __reserved_3 : 14;
+                unsigned int __reserved_4[3];
+        } lvt_timer;
+
+        struct {
+                unsigned int vector : 8,
+                        delivery_mode : 3,
+                        __reserved_1 : 1,
+                        delivery_status : 1,
+                        __reserved_2 : 3,
+                        mask : 1,
+                        __reserved_3 : 15;
+                unsigned int __reserved_4[3];
+        } lvt_thermal;
+
+        struct {
+                unsigned int vector : 8,
+                        delivery_mode : 3,
+                        __reserved_1 : 1,
+                        delivery_status : 1,
+                        __reserved_2 : 3,
+                        mask : 1,
+                        __reserved_3 : 15;
+                unsigned int __reserved_4[3];
+        } lvt_pc;
+
+        struct {
+                unsigned int vector : 8,
+                        delivery_mode : 3,
+                        __reserved_1 : 1,
+                        delivery_status : 1,
+                        polarity : 1,
+                        remote_irr : 1,
+                        trigger : 1,
+                        mask : 1,
+                        __reserved_2 : 15;
+                unsigned int __reserved_3[3];
+        } lvt_lint0;
+
+        struct {
+                unsigned int vector : 8,
+                        delivery_mode : 3,
+                        __reserved_1 : 1,
+                        delivery_status : 1,
+                        polarity : 1,
+                        remote_irr : 1,
+                        trigger : 1,
+                        mask : 1,
+                        __reserved_2 : 15;
+                unsigned int __reserved_3[3];
+        } lvt_lint1;
+
+        struct {
+                unsigned int vector : 8,
+                        __reserved_1 : 4,
+                        delivery_status : 1,
+                        __reserved_2 : 3,
+                        mask : 1,
+                        __reserved_3 : 15;
+                unsigned int __reserved_4[3];
+        } lvt_error;
+
+        struct {
+                unsigned int initial_count;
+                unsigned int __reserved_2[3];
+        } timer_icr;
+
+        const
+        struct {
+                unsigned int curr_count;
+                unsigned int __reserved_2[3];
+        } timer_ccr;
+
+        struct { unsigned int __reserved[4]; } __reserved_16;
+
+        struct { unsigned int __reserved[4]; } __reserved_17;
+
+        struct { unsigned int __reserved[4]; } __reserved_18;
+
+        struct { unsigned int __reserved[4]; } __reserved_19;
+
+        struct {
+                unsigned int divisor : 4,
+                        __reserved_1 : 28;
+                unsigned int __reserved_2[3];
+        } timer_dcr;
+
+        struct { unsigned int __reserved[4]; } __reserved_20;
+
+} __attribute__ ((packed));
+# 29 "include/asm/fixmap.h" 2
+# 53 "include/asm/fixmap.h"
+enum fixed_addresses {
+        FIX_HOLE,
+        FIX_VSYSCALL,
+
+        FIX_APIC_BASE,
+
+
+        FIX_IO_APIC_BASE_0,
+        FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + 8 -1,
+# 80 "include/asm/fixmap.h"
+        FIX_ACPI_BEGIN,
+        FIX_ACPI_END = FIX_ACPI_BEGIN + 4 - 1,
+
+
+        FIX_PCIE_MCFG,
+
+        __end_of_permanent_fixed_addresses,
+
+
+        FIX_BTMAP_END = __end_of_permanent_fixed_addresses,
+        FIX_BTMAP_BEGIN = FIX_BTMAP_END + 16 - 1,
+        FIX_WP_TEST,
+        __end_of_fixed_addresses
+};
+
+extern void __set_fixmap (enum fixed_addresses idx,
+                                        unsigned long phys, pgprot_t flags);
+# 125 "include/asm/fixmap.h"
+extern void __this_fixmap_does_not_exist(void);
+
+
+
+
+
+
+static inline __attribute__((always_inline)) unsigned long fix_to_virt(const unsigned int idx)
+{
+# 143 "include/asm/fixmap.h"
+        if (idx >= __end_of_fixed_addresses)
+                __this_fixmap_does_not_exist();
+
+        return (((unsigned long)0xfffff000) - ((idx) << 12));
+}
+
+static inline __attribute__((always_inline)) unsigned long virt_to_fix(const unsigned long vaddr)
+{
+        do { if (__builtin_expect(!!((vaddr >= ((unsigned long)0xfffff000) || vaddr < (((unsigned long)0xfffff000) - (__end_of_permanent_fixed_addresses << 12)))!=0), 0)) __asm__ __volatile__( "ud2\n" "\t.word %c0\n" "\t.long %c1\n" : : "i" (151), "i" ("include/asm/fixmap.h")); } while(0);
+        return ((((unsigned long)0xfffff000) - ((vaddr)&(~((1UL << 12)-1)))) >> 12);
+}
+# 17 "include/asm/smp.h" 2
+
+# 1 "include/asm/mpspec.h" 1
+
+
+
+
+# 1 "include/asm/mpspec_def.h" 1
+# 19 "include/asm/mpspec_def.h"
+struct intel_mp_floating
+{
+        char mpf_signature[4];
+        unsigned long mpf_physptr;
+        unsigned char mpf_length;
+        unsigned char mpf_specification;
+        unsigned char mpf_checksum;
+        unsigned char mpf_feature1;
+        unsigned char mpf_feature2;
+        unsigned char mpf_feature3;
+        unsigned char mpf_feature4;
+        unsigned char mpf_feature5;
+};
+
+struct mp_config_table
+{
+        char mpc_signature[4];
+
+        unsigned short mpc_length;
+        char mpc_spec;
+        char mpc_checksum;
+        char mpc_oem[8];
+        char mpc_productid[12];
+        unsigned long mpc_oemptr;
+        unsigned short mpc_oemsize;
+        unsigned short mpc_oemcount;
+        unsigned long mpc_lapic;
+        unsigned long reserved;
+};
+# 58 "include/asm/mpspec_def.h"
+struct mpc_config_processor
+{
+        unsigned char mpc_type;
+        unsigned char mpc_apicid;
+        unsigned char mpc_apicver;
+        unsigned char mpc_cpuflag;
+
+
+        unsigned long mpc_cpufeature;
+
+
+
+        unsigned long mpc_featureflag;
+        unsigned long mpc_reserved[2];
+};
+
+struct mpc_config_bus
+{
+        unsigned char mpc_type;
+        unsigned char mpc_busid;
+        unsigned char mpc_bustype[6] __attribute((packed));
+};
+# 102 "include/asm/mpspec_def.h"
+struct mpc_config_ioapic
+{
+        unsigned char mpc_type;
+        unsigned char mpc_apicid;
+        unsigned char mpc_apicver;
+        unsigned char mpc_flags;
+
+        unsigned long mpc_apicaddr;
+};
+
+struct mpc_config_intsrc
+{
+        unsigned char mpc_type;
+        unsigned char mpc_irqtype;
+        unsigned short mpc_irqflag;
+        unsigned char mpc_srcbus;
+        unsigned char mpc_srcbusirq;
+        unsigned char mpc_dstapic;
+        unsigned char mpc_dstirq;
+};
+
+enum mp_irq_source_types {
+        mp_INT = 0,
+        mp_NMI = 1,
+        mp_SMI = 2,
+        mp_ExtINT = 3
+};
+
+
+
+
+
+
+struct mpc_config_lintsrc
+{
+        unsigned char mpc_type;
+        unsigned char mpc_irqtype;
+        unsigned short mpc_irqflag;
+        unsigned char mpc_srcbusid;
+        unsigned char mpc_srcbusirq;
+        unsigned char mpc_destapic;
+
+        unsigned char mpc_destapiclint;
+};
+
+struct mp_config_oemtable
+{
+        char oem_signature[4];
+
+        unsigned short oem_length;
+        char oem_rev;
+        char oem_checksum;
+        char mpc_oem[8];
+};
+
+struct mpc_config_translation
+{
+        unsigned char mpc_type;
+        unsigned char trans_len;
+        unsigned char trans_type;
+        unsigned char trans_quad;
+        unsigned char trans_global;
+        unsigned char trans_local;
+        unsigned short trans_reserved;
+};
+# 180 "include/asm/mpspec_def.h"
+enum mp_bustype {
+        MP_BUS_ISA = 1,
+        MP_BUS_EISA,
+        MP_BUS_PCI,
+        MP_BUS_MCA,
+        MP_BUS_NEC98
+};
+# 6 "include/asm/mpspec.h" 2
+# 1 "include/asm-i386/mach-default/mach_mpspec.h" 1
+# 7 "include/asm/mpspec.h" 2
+
+extern int mp_bus_id_to_type [32];
+extern int mp_bus_id_to_node [32];
+extern int mp_bus_id_to_local [32];
+extern int quad_local_to_mp_bus_id [8/4][4];
+extern int mp_bus_id_to_pci_bus [32];
+
+extern unsigned int boot_cpu_physical_apicid;
+extern int smp_found_config;
+extern void find_smp_config (void);
+extern void get_smp_config (void);
+extern int nr_ioapics;
+extern int apic_version [256];
+extern int mp_bus_id_to_type [32];
+extern int mp_irq_entries;
+extern struct mpc_config_intsrc mp_irqs [256];
+extern int mpc_default_type;
+extern int mp_bus_id_to_pci_bus [32];
+extern int mp_current_pci_id;
+extern unsigned long mp_lapic_addr;
+extern int pic_mode;
+extern int using_apic_timer;
+
+
+extern void mp_register_lapic (u8 id, u8 enabled);
+extern void mp_register_lapic_address (u64 address);
+extern void mp_register_ioapic (u8 id, u32 address, u32 gsi_base);
+extern void mp_override_legacy_irq (u8 bus_irq, u8 polarity, u8 trigger, u32 gsi);
+extern void mp_config_acpi_legacy_irqs (void);
+extern void mp_register_gsi (u32 gsi, int edge_level, int active_high_low);
+
+
+
+
+struct physid_mask
+{
+        unsigned long mask[(((256)+32 -1)/32)];
+};
+
+typedef struct physid_mask physid_mask_t;
+# 81 "include/asm/mpspec.h"
+extern physid_mask_t phys_cpu_present_map;
+# 19 "include/asm/smp.h" 2
+
+# 1 "include/asm/io_apic.h" 1
+# 36 "include/asm/io_apic.h"
+static inline __attribute__((always_inline)) int use_pci_vector(void) {return 0;}
+static inline __attribute__((always_inline)) void disable_edge_ioapic_irq(unsigned int irq) { }
+static inline __attribute__((always_inline)) void mask_and_ack_level_ioapic_irq(unsigned int irq) { }
+static inline __attribute__((always_inline)) void end_edge_ioapic_irq (unsigned int irq) { }
+# 65 "include/asm/io_apic.h"
+union IO_APIC_reg_00 {
+        u32 raw;
+        struct {
+                u32 __reserved_2 : 14,
+                        LTS : 1,
+                        delivery_type : 1,
+                        __reserved_1 : 8,
+                        ID : 8;
+        } __attribute__ ((packed)) bits;
+};
+
+union IO_APIC_reg_01 {
+        u32 raw;
+        struct {
+                u32 version : 8,
+                        __reserved_2 : 7,
+                        PRQ : 1,
+                        entries : 8,
+                        __reserved_1 : 8;
+        } __attribute__ ((packed)) bits;
+};
+
+union IO_APIC_reg_02 {
+        u32 raw;
+        struct {
+                u32 __reserved_2 : 24,
+                        arbitration : 4,
+                        __reserved_1 : 4;
+        } __attribute__ ((packed)) bits;
+};
+
+union IO_APIC_reg_03 {
+        u32 raw;
+        struct {
+                u32 boot_DT : 1,
+                        __reserved_1 : 31;
+        } __attribute__ ((packed)) bits;
+};
+
+
+
+
+extern int nr_ioapics;
+extern int nr_ioapic_registers[8];
+
+enum ioapic_irq_destination_types {
+        dest_Fixed = 0,
+        dest_LowestPrio = 1,
+        dest_SMI = 2,
+        dest__reserved_1 = 3,
+        dest_NMI = 4,
+        dest_INIT = 5,
+        dest__reserved_2 = 6,
+        dest_ExtINT = 7
+};
+
+struct IO_APIC_route_entry {
+        __u32 vector : 8,
+                delivery_mode : 3,
+
+
+
+                dest_mode : 1,
+                delivery_status : 1,
+                polarity : 1,
+                irr : 1,
+                trigger : 1,
+                mask : 1,
+                __reserved_2 : 15;
+
+        union { struct { __u32
+                                        __reserved_1 : 24,
+                                        physical_dest : 4,
+                                        __reserved_2 : 4;
+                        } physical;
+
+                        struct { __u32
+                                        __reserved_1 : 24,
+                                        logical_dest : 8;
+                        } logical;
+        } dest;
+
+} __attribute__ ((packed));
+
+
+
+
+
+
+extern struct mpc_config_ioapic mp_ioapics[8];
+
+
+extern int mp_irq_entries;
+
+
+extern struct mpc_config_intsrc mp_irqs[256];
+
+
+extern int mpc_default_type;
+
+static inline __attribute__((always_inline)) unsigned int io_apic_read(unsigned int apic, unsigned int reg)
+{
+        *((volatile int *)((((unsigned long)0xfffff000) - ((FIX_IO_APIC_BASE_0 + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr & ~(~((1UL << 12)-1))))) = reg;
+        return *(((volatile int *)((((unsigned long)0xfffff000) - ((FIX_IO_APIC_BASE_0 + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr & ~(~((1UL << 12)-1)))))+4);
+}
+
+static inline __attribute__((always_inline)) void io_apic_write(unsigned int apic, unsigned int reg, unsigned int value)
+{
+        *((volatile int *)((((unsigned long)0xfffff000) - ((FIX_IO_APIC_BASE_0 + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr & ~(~((1UL << 12)-1))))) = reg;
+        *(((volatile int *)((((unsigned long)0xfffff000) - ((FIX_IO_APIC_BASE_0 + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr & ~(~((1UL << 12)-1)))))+4) = value;
+}
+
+
+
+
+
+
+
+extern int sis_apic_bug;
+static inline __attribute__((always_inline)) void io_apic_modify(unsigned int apic, unsigned int reg, unsigned int value)
+{
+        if (sis_apic_bug)
+                *((volatile int *)((((unsigned long)0xfffff000) - ((FIX_IO_APIC_BASE_0 + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr & ~(~((1UL << 12)-1))))) = reg;
+        *(((volatile int *)((((unsigned long)0xfffff000) - ((FIX_IO_APIC_BASE_0 + apic) << 12)) + (mp_ioapics[apic].mpc_apicaddr & ~(~((1UL << 12)-1)))))+4) = value;
+}
+
+
+extern int skip_ioapic_setup;
+# 201 "include/asm/io_apic.h"
+extern int io_apic_get_unique_id (int ioapic, int apic_id);
+extern int io_apic_get_version (int ioapic);
+extern int io_apic_get_redir_entries (int ioapic);
+extern int io_apic_set_pci_routing (int ioapic, int pin, int irq, int edge_level, int active_high_low);
+
+
+
+
+
+
+extern int assign_irq_vector(int irq);
+# 21 "include/asm/smp.h" 2
+
+# 1 "include/asm/apic.h" 1
+
+
+
+
+# 1 "include/linux/pm.h" 1
+# 33 "include/linux/pm.h"
+enum
+{
+        PM_SUSPEND,
+        PM_RESUME,
+
+        PM_SAVE_STATE,
+
+
+        PM_SET_WAKEUP,
+
+
+        PM_GET_RESOURCES,
+        PM_SET_RESOURCES,
+
+
+        PM_EJECT,
+        PM_LOCK,
+};
+
+typedef int pm_request_t;
+
+
+
+
+enum
+{
+        PM_UNKNOWN_DEV = 0,
+        PM_SYS_DEV,
+        PM_PCI_DEV,
+        PM_USB_DEV,
+        PM_SCSI_DEV,
+        PM_ISA_DEV,
+        PM_MTD_DEV,
+};
+
+typedef int pm_dev_t;
+
+
+
+
+enum
+{
+        PM_SYS_UNKNOWN = 0x00000000,
+        PM_SYS_KBC = 0x41d00303,
+        PM_SYS_COM = 0x41d00500,
+        PM_SYS_IRDA = 0x41d00510,
+        PM_SYS_FDC = 0x41d00700,
+        PM_SYS_VGA = 0x41d00900,
+        PM_SYS_PCMCIA = 0x41d00e00,
+};
+# 92 "include/linux/pm.h"
+struct pm_dev;
+
+typedef int (*pm_callback)(struct pm_dev *dev, pm_request_t rqst, void *data);
+
+
+
+
+struct pm_dev
+{
+        pm_dev_t type;
+        unsigned long id;
+        pm_callback callback;
+        void *data;
+
+        unsigned long flags;
+        unsigned long state;
+        unsigned long prev_state;
+
+        struct list_head entry;
+};
+
+
+
+extern int pm_active;
+
+
+
+
+
+
+struct pm_dev *pm_register(pm_dev_t type,
+                           unsigned long id,
+                           pm_callback callback);
+
+
+
+
+void pm_unregister(struct pm_dev *dev);
+
+
+
+
+void pm_unregister_all(pm_callback callback);
+
+
+
+
+int pm_send(struct pm_dev *dev, pm_request_t rqst, void *data);
+
+
+
+
+int pm_send_all(pm_request_t rqst, void *data);
+
+
+
+
+struct pm_dev *pm_find(pm_dev_t type, struct pm_dev *from);
+
+static inline __attribute__((always_inline)) void pm_access(struct pm_dev *dev) {}
+static inline __attribute__((always_inline)) void pm_dev_idle(struct pm_dev *dev) {}
+# 193 "include/linux/pm.h"
+extern void (*pm_idle)(void);
+extern void (*pm_power_off)(void);
+
+enum {
+        PM_SUSPEND_ON = 0,
+        PM_SUSPEND_STANDBY = 1,
+
+        PM_SUSPEND_MEM = 3,
+        PM_SUSPEND_DISK = 4,
+        PM_SUSPEND_MAX = 5,
+};
+
+enum {
+        PM_DISK_FIRMWARE = 1,
+        PM_DISK_PLATFORM,
+        PM_DISK_SHUTDOWN,
+        PM_DISK_REBOOT,
+        PM_DISK_MAX,
+};
+
+
+struct pm_ops {
+        u32 pm_disk_mode;
+        int (*prepare)(u32 state);
+        int (*enter)(u32 state);
+        int (*finish)(u32 state);
+};
+
+extern void pm_set_ops(struct pm_ops *);
+
+extern int pm_suspend(u32 state);
+
+
+
+
+
+
+struct device;
+
+struct dev_pm_info {
+        u32 power_state;
+
+        u32 prev_state;
+        u8 * saved_state;
+        atomic_t pm_users;
+        struct device * pm_parent;
+        struct list_head entry;
+
+};
+
+extern void device_pm_set_parent(struct device * dev, struct device * parent);
+
+extern int device_suspend(u32 state);
+extern int device_power_down(u32 state);
+extern void device_power_up(void);
+extern void device_resume(void);
+# 6 "include/asm/apic.h" 2
+# 19 "include/asm/apic.h"
+extern int apic_verbosity;
+# 39 "include/asm/apic.h"
+static __inline __attribute__((always_inline)) void apic_write(unsigned long reg, unsigned long v)
+{
+        *((volatile unsigned long *)((fix_to_virt(FIX_APIC_BASE))+reg)) = v;
+}
+
+static __inline __attribute__((always_inline)) void apic_write_atomic(unsigned long reg, unsigned long v)
+{
+        ((__typeof__(*((volatile unsigned long *)((fix_to_virt(FIX_APIC_BASE))+reg))))__xchg((unsigned long)(v),((volatile unsigned long *)((fix_to_virt(FIX_APIC_BASE))+reg)),sizeof(*((volatile unsigned long *)((fix_to_virt(FIX_APIC_BASE))+reg)))));
+}
+
+static __inline __attribute__((always_inline)) unsigned long apic_read(unsigned long reg)
+{
+        return *((volatile unsigned long *)((fix_to_virt(FIX_APIC_BASE))+reg));
+}
+
+static __inline__ __attribute__((always_inline)) void apic_wait_icr_idle(void)
+{
+        do { } while ( apic_read( 0x300 ) & 0x01000 );
+}
+
+int get_physical_broadcast(void);
+# 71 "include/asm/apic.h"
+static inline __attribute__((always_inline)) void ack_APIC_irq(void)
+{
+# 81 "include/asm/apic.h"
+        apic_write((0xB0),(0));
+}
+
+extern void (*wait_timer_tick)(void);
+
+extern int get_maxlvt(void);
+extern void clear_local_APIC(void);
+extern void connect_bsp_APIC (void);
+extern void disconnect_bsp_APIC (void);
+extern void disable_local_APIC (void);
+extern int verify_local_APIC (void);
+extern void cache_APIC_registers (void);
+extern void sync_Arb_IDs (void);
+extern void init_bsp_APIC (void);
+extern void setup_local_APIC (void);
+extern void init_apic_mappings (void);
+extern void smp_local_timer_interrupt (struct pt_regs * regs);
+extern void setup_boot_APIC_clock (void);
+extern void setup_secondary_APIC_clock (void);
+extern void setup_apic_nmi_watchdog (void);
+extern int reserve_lapic_nmi(void);
+extern void release_lapic_nmi(void);
+extern void disable_timer_nmi_watchdog(void);
+extern void enable_timer_nmi_watchdog(void);
+extern void nmi_watchdog_tick (struct pt_regs * regs);
+extern int APIC_init_uniprocessor (void);
+extern void disable_APIC_timer(void);
+extern void enable_APIC_timer(void);
+
+extern int check_nmi_watchdog (void);
+extern void enable_NMI_through_LVT0 (void * dummy);
+
+extern unsigned int nmi_watchdog;
+# 23 "include/asm/smp.h" 2
+# 34 "include/asm/smp.h"
+extern void smp_alloc_memory(void);
+extern int pic_mode;
+extern int smp_num_siblings;
+extern cpumask_t cpu_sibling_map[];
+
+extern void smp_flush_tlb(void);
+extern void smp_message_irq(int cpl, void *dev_id, struct pt_regs *regs);
+extern void smp_invalidate_rcv(void);
+extern void (*mtrr_hook) (void);
+extern void zap_low_mappings (void);
+
+
+extern u8 x86_cpu_to_apicid[];
+# 55 "include/asm/smp.h"
+extern cpumask_t cpu_callout_map;
+
+
+
+static inline __attribute__((always_inline)) int num_booting_cpus(void)
+{
+        return __cpus_weight(&(cpu_callout_map), 8);
+}
+
+extern void map_cpu_to_logical_apicid(void);
+extern void unmap_cpu_to_logical_apicid(int cpu);
+
+
+
+
+
+
+# 1 "include/asm-i386/mach-default/mach_apicdef.h" 1
+
+
+
+
+
+static inline __attribute__((always_inline)) unsigned get_apic_id(unsigned long x)
+{
+        return (((x)>>24)&0xF);
+}
+# 73 "include/asm/smp.h" 2
+static inline __attribute__((always_inline)) int hard_smp_processor_id(void)
+{
+
+        return get_apic_id(*(unsigned long *)((fix_to_virt(FIX_APIC_BASE))+0x20));
+}
+
+
+static __inline __attribute__((always_inline)) int logical_smp_processor_id(void)
+{
+
+        return (((*(unsigned long *)((fix_to_virt(FIX_APIC_BASE))+0xD0))>>24)&0xFF);
+}
+# 18 "include/linux/smp.h" 2
+# 28 "include/linux/smp.h"
+extern void smp_send_stop(void);
+
+
+
+
+extern void smp_send_reschedule(int cpu);
+
+
+
+
+
+extern void smp_prepare_cpus(unsigned int max_cpus);
+
+
+
+
+extern int __cpu_up(unsigned int cpunum);
+
+
+
+
+extern void smp_cpus_done(unsigned int max_cpus);
+
+
+
+
+extern int smp_call_function (void (*func) (void *info), void *info,
+                              int retry, int wait);
+
+
+
+
+static inline __attribute__((always_inline)) int on_each_cpu(void (*func) (void *info), void *info,
+                              int retry, int wait)
+{
+        int ret = 0;
+
+        do { do { (current_thread_info()->preempt_count)++; } while (0); __asm__ __volatile__("": : :"memory"); } while (0);
+        ret = smp_call_function(func, info, retry, wait);
+        func(info);
+        do { do { __asm__ __volatile__("": : :"memory"); do { (current_thread_info()->preempt_count)--; } while (0); } while (0); do { if (__builtin_expect(!!(test_thread_flag(3)), 0)) preempt_schedule(); } while (0); } while (0);
+        return ret;
+}
+
+
+
+
+extern int smp_threads_ready;
+# 91 "include/linux/smp.h"
+void smp_prepare_boot_cpu(void);
+# 34 "include/linux/topology.h" 2
+
+# 1 "include/asm/topology.h" 1
+# 81 "include/asm/topology.h"
+# 1 "include/asm-generic/topology.h" 1
+# 82 "include/asm/topology.h" 2
+# 36 "include/linux/topology.h" 2
+# 46 "include/linux/topology.h"
+static inline __attribute__((always_inline)) int __next_node_with_cpus(int node)
+{
+        do
+                ++node;
+        while (node < numnodes && !({ cpumask_t __tmp__; __tmp__ = (cpu_online_map); __cpus_weight(&(__tmp__), 8); }));
+        return node;
+}
+# 372 "include/linux/mmzone.h" 2
+
+
+
+
+
+extern struct pglist_data contig_page_data;
+# 413 "include/linux/mmzone.h"
+extern unsigned long node_online_map[((((1 << 0))+32 -1)/32)];
+# 5 "include/linux/gfp.h" 2
+
+
+
+
+struct vm_area_struct;
+# 78 "include/linux/gfp.h"
+static inline __attribute__((always_inline)) void arch_free_page(struct page *page, int order) { }
+
+
+extern struct page *
+__alloc_pages(unsigned int, unsigned int, struct zonelist *) __attribute__((regparm(3)));
+
+static inline __attribute__((always_inline)) struct page *alloc_pages_node(int nid, unsigned int gfp_mask,
+                                                unsigned int order)
+{
+        if (__builtin_expect(!!(order >= 11), 0))
+                return 0;
+
+        return __alloc_pages(gfp_mask, order,
+                (&contig_page_data)->node_zonelists + (gfp_mask & 0x03));
+}
+# 114 "include/linux/gfp.h"
+extern unsigned long __get_free_pages(unsigned int gfp_mask, unsigned int order) __attribute__((regparm(3)));
+extern unsigned long get_zeroed_page(unsigned int gfp_mask) __attribute__((regparm(3)));
+
+
+
+
+
+
+
+extern void __free_pages(struct page *page, unsigned int order) __attribute__((regparm(3)));
+extern void free_pages(unsigned long addr, unsigned int order) __attribute__((regparm(3)));
+extern void free_hot_page(struct page *page) __attribute__((regparm(3)));
+extern void free_cold_page(struct page *page) __attribute__((regparm(3)));
+
+
+
+
+void page_alloc_init(void);
+# 16 "include/linux/slab.h" 2
+# 56 "include/linux/slab.h"
+extern void kmem_cache_init(void);
+
+extern kmem_cache_t *kmem_cache_create(const char *, size_t, size_t, unsigned long,
+                                       void (*)(void *, kmem_cache_t *, unsigned long),
+                                       void (*)(void *, kmem_cache_t *, unsigned long));
+extern int kmem_cache_destroy(kmem_cache_t *);
+extern int kmem_cache_shrink(kmem_cache_t *);
+extern void *kmem_cache_alloc(kmem_cache_t *, int);
+extern void *kmem_cache_alloc_node(kmem_cache_t *, int);
+extern void kmem_cache_free(kmem_cache_t *, void *);
+extern unsigned int kmem_cache_size(kmem_cache_t *);
+
+
+struct cache_sizes {
+        size_t cs_size;
+        kmem_cache_t *cs_cachep;
+        kmem_cache_t *cs_dmacachep;
+};
+extern struct cache_sizes malloc_sizes[];
+extern void *__kmalloc(size_t, int);
+
+static inline __attribute__((always_inline)) void *kmalloc(size_t size, int flags)
+{
+        if (__builtin_constant_p(size)) {
+                int i = 0;
+
+
+
+
+
+# 1 "include/linux/kmalloc_sizes.h" 1
+
+        if (size <= 32) goto found; else i++;
+
+        if (size <= 64) goto found; else i++;
+
+
+
+        if (size <= 128) goto found; else i++;
+
+
+
+        if (size <= 256) goto found; else i++;
+        if (size <= 512) goto found; else i++;
+        if (size <= 1024) goto found; else i++;
+        if (size <= 2048) goto found; else i++;
+        if (size <= 4096) goto found; else i++;
+        if (size <= 8192) goto found; else i++;
+        if (size <= 16384) goto found; else i++;
+        if (size <= 32768) goto found; else i++;
+        if (size <= 65536) goto found; else i++;
+        if (size <= 131072) goto found; else i++;
+# 87 "include/linux/slab.h" 2
+
+                {
+                        extern void __you_cannot_kmalloc_that_much(void);
+                        __you_cannot_kmalloc_that_much();
+                }
+found:
+                return kmem_cache_alloc((flags & 0x01) ?
+                        malloc_sizes[i].cs_dmacachep :
+                        malloc_sizes[i].cs_cachep, flags);
+        }
+        return __kmalloc(size, flags);
+}
+
+extern void *kcalloc(size_t, size_t, int);
+extern void kfree(const void *);
+extern unsigned int ksize(const void *);
+
+extern int kmem_cache_reap(int) __attribute__((regparm(3)));
+extern int kmem_ptr_validate(kmem_cache_t *cachep, void *ptr) __attribute__((regparm(3)));
+
+
+extern kmem_cache_t *vm_area_cachep;
+extern kmem_cache_t *mm_cachep;
+extern kmem_cache_t *names_cachep;
+extern kmem_cache_t *files_cachep;
+extern kmem_cache_t *filp_cachep;
+extern kmem_cache_t *dquot_cachep;
+extern kmem_cache_t *fs_cachep;
+extern kmem_cache_t *signal_cachep;
+extern kmem_cache_t *sighand_cachep;
+extern kmem_cache_t *bio_cachep;
+
+extern atomic_t slab_reclaim_pages;
+# 12 "lib/gcc/fixdefines.h" 2
+# 1 "include/c++/end_include.h" 1
+# 21 "include/c++/end_include.h"
+}
+# 13 "lib/gcc/fixdefines.h" 2
+
+
+
+
+extern "C"
+
+
+
+inline __attribute__((always_inline)) void* cxx_malloc(size_t sz)
+{
+   return kmalloc(sz, (0x10 | 0x40 | 0x80));
+}
+
+
+extern "C"
+
+
+
+inline __attribute__((always_inline)) void cxx_free(void* p)
+{
+   kfree(p);
+}
+
+
+
+
+
+extern "C"
+inline __attribute__((always_inline)) void __attribute__((__noreturn__)) cxx_abort(void)
+{
+   printk("Aborted\n");
+   __asm__ __volatile__( "ud2\n" "\t.word %c0\n" "\t.long %c1\n" : : "i" (44), "i" ("lib/gcc/fixdefines.h"));
+   for (;;);
+}
+# 10 "<command line>" 2
+# 1 "lib/libstdc++-v3/libsupc++/eh_alloc.cc"
+# 33 "lib/libstdc++-v3/libsupc++/eh_alloc.cc"
+# 1 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/cstdlib" 1
+# 10 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/cstdlib"
+# 1 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/begin_include.h" 1
+# 17 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/begin_include.h"
+extern "C" {
+# 11 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/cstdlib" 2
+
+# 1 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/end_include.h" 1
+# 21 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/end_include.h"
+}
+# 13 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/cstdlib" 2
+
+namespace std {
+   using ::cxx_malloc;
+   using ::cxx_free;
+   using ::cxx_abort;
+}
+# 34 "lib/libstdc++-v3/libsupc++/eh_alloc.cc" 2
+# 1 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/cstring" 1
+
+
+
+
+
+namespace std {
+   extern "C" inline __attribute__((always_inline)) void* cxx_memset(void* dst, const void* src, size_t sz)
+   {
+      return (__builtin_constant_p(src) ? (__builtin_constant_p((sz)) ? __constant_c_and_count_memset(((dst)),((0x01010101UL*(unsigned char)(src))),((sz))) : __constant_c_memset(((dst)),((0x01010101UL*(unsigned char)(src))),((sz)))) : (__builtin_constant_p((sz)) ? __memset_generic((((dst))),(((src))),(((sz)))) : __memset_generic(((dst)),((src)),((sz)))));
+   }
+}
+
+using std::cxx_memset;
+# 35 "lib/libstdc++-v3/libsupc++/eh_alloc.cc" 2
+# 1 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/climits" 1
+# 36 "lib/libstdc++-v3/libsupc++/eh_alloc.cc" 2
+# 1 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/exception" 1
+# 40 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/exception"
+extern "C++" {
+
+namespace std
+{
+# 52 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/exception"
+  class exception
+  {
+  public:
+    exception() throw() { }
+    virtual ~exception() throw();
+
+
+    virtual const char* what() const throw();
+  };
+
+
+
+  class bad_exception : public exception
+  {
+  public:
+    bad_exception() throw() { }
+
+
+    virtual ~bad_exception() throw();
+  };
+
+
+  typedef void (*terminate_handler) ();
+
+  typedef void (*unexpected_handler) ();
+
+
+  terminate_handler set_terminate(terminate_handler) throw();
+
+
+  void terminate() __attribute__ ((__noreturn__));
+
+
+  unexpected_handler set_unexpected(unexpected_handler) throw();
+
+
+  void unexpected() __attribute__ ((__noreturn__));
+# 100 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/exception"
+  bool uncaught_exception() throw();
+}
+
+namespace __gnu_cxx
+{
+# 115 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/exception"
+  void __verbose_terminate_handler ();
+}
+
+}
+# 37 "lib/libstdc++-v3/libsupc++/eh_alloc.cc" 2
+# 1 "lib/libstdc++-v3/libsupc++/unwind-cxx.h" 1
+# 38 "lib/libstdc++-v3/libsupc++/unwind-cxx.h"
+# 1 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/typeinfo" 1
+# 40 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/typeinfo"
+extern "C++" {
+
+namespace __cxxabiv1
+{
+  class __class_type_info;
+}
+# 58 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/typeinfo"
+namespace std
+{
+
+
+
+
+
+
+  class type_info
+  {
+  public:
+
+
+
+
+    virtual ~type_info();
+
+  private:
+
+    type_info& operator=(const type_info&);
+    type_info(const type_info&);
+
+  protected:
+    const char *__name;
+
+  protected:
+    explicit type_info(const char *__n): __name(__n) { }
+
+  public:
+
+
+
+    const char* name() const
+    { return __name; }
+# 104 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/typeinfo"
+    bool before(const type_info& __arg) const;
+    bool operator==(const type_info& __arg) const;
+
+    bool operator!=(const type_info& __arg) const
+    { return !operator==(__arg); }
+
+
+  public:
+
+    virtual bool __is_pointer_p() const;
+
+    virtual bool __is_function_p() const;
+
+
+
+
+
+
+
+    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
+                            unsigned __outer) const;
+
+
+    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
+                             void **__obj_ptr) const;
+  };
+
+
+
+
+
+
+  class bad_cast : public exception
+  {
+  public:
+    bad_cast() throw() { }
+
+
+    virtual ~bad_cast() throw();
+  };
+
+
+  class bad_typeid : public exception
+  {
+  public:
+    bad_typeid () throw() { }
+
+
+    virtual ~bad_typeid() throw();
+  };
+}
+
+}
+# 39 "lib/libstdc++-v3/libsupc++/unwind-cxx.h" 2
+
+# 1 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/cstddef" 1
+# 10 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/cstddef"
+# 1 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/begin_include.h" 1
+# 17 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/begin_include.h"
+extern "C" {
+# 11 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/cstddef" 2
+
+# 1 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/end_include.h" 1
+# 21 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/end_include.h"
+}
+# 13 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/cstddef" 2
+
+namespace std {
+   using ::size_t;
+}
+# 41 "lib/libstdc++-v3/libsupc++/unwind-cxx.h" 2
+# 1 "/usr/lib/gcc-lib/i386-redhat-linux/3.3.3/include/unwind.h" 1 3 4
+# 32 "/usr/lib/gcc-lib/i386-redhat-linux/3.3.3/include/unwind.h" 3 4
+extern "C" {
+
+
+
+
+
+
+typedef unsigned _Unwind_Word __attribute__((__mode__(__word__)));
+typedef signed _Unwind_Sword __attribute__((__mode__(__word__)));
+
+
+
+typedef unsigned _Unwind_Ptr __attribute__((__mode__(__pointer__)));
+
+typedef unsigned _Unwind_Internal_Ptr __attribute__((__mode__(__pointer__)));
+
+
+
+
+
+typedef unsigned _Unwind_Exception_Class __attribute__((__mode__(__DI__)));
+
+
+
+typedef enum
+{
+  _URC_NO_REASON = 0,
+  _URC_FOREIGN_EXCEPTION_CAUGHT = 1,
+  _URC_FATAL_PHASE2_ERROR = 2,
+  _URC_FATAL_PHASE1_ERROR = 3,
+  _URC_NORMAL_STOP = 4,
+  _URC_END_OF_STACK = 5,
+  _URC_HANDLER_FOUND = 6,
+  _URC_INSTALL_CONTEXT = 7,
+  _URC_CONTINUE_UNWIND = 8
+} _Unwind_Reason_Code;
+# 76 "/usr/lib/gcc-lib/i386-redhat-linux/3.3.3/include/unwind.h" 3 4
+struct _Unwind_Exception;
+
+typedef void (*_Unwind_Exception_Cleanup_Fn) (_Unwind_Reason_Code,
+                                              struct _Unwind_Exception *);
+
+struct _Unwind_Exception
+{
+  _Unwind_Exception_Class exception_class;
+  _Unwind_Exception_Cleanup_Fn exception_cleanup;
+  _Unwind_Word private_1;
+  _Unwind_Word private_2;
+
+
+
+
+} __attribute__((__aligned__));
+
+
+
+
+typedef int _Unwind_Action;
+# 108 "/usr/lib/gcc-lib/i386-redhat-linux/3.3.3/include/unwind.h" 3 4
+struct _Unwind_Context;
+
+
+extern _Unwind_Reason_Code _Unwind_RaiseException (struct _Unwind_Exception *);
+
+
+
+typedef _Unwind_Reason_Code (*_Unwind_Stop_Fn)
+     (int, _Unwind_Action, _Unwind_Exception_Class,
+      struct _Unwind_Exception *, struct _Unwind_Context *, void *);
+
+extern _Unwind_Reason_Code _Unwind_ForcedUnwind (struct _Unwind_Exception *,
+                                                 _Unwind_Stop_Fn,
+                                                 void *);
+
+
+extern void _Unwind_DeleteException (struct _Unwind_Exception *);
+
+
+
+extern void _Unwind_Resume (struct _Unwind_Exception *);
+
+
+
+extern _Unwind_Reason_Code _Unwind_Resume_or_Rethrow (struct _Unwind_Exception *);
+
+
+
+
+typedef _Unwind_Reason_Code (*_Unwind_Trace_Fn)
+     (struct _Unwind_Context *, void *);
+
+extern _Unwind_Reason_Code _Unwind_Backtrace (_Unwind_Trace_Fn, void *);
+
+
+
+
+
+
+extern _Unwind_Word _Unwind_GetGR (struct _Unwind_Context *, int);
+extern void _Unwind_SetGR (struct _Unwind_Context *, int, _Unwind_Word);
+
+extern _Unwind_Ptr _Unwind_GetIP (struct _Unwind_Context *);
+extern void _Unwind_SetIP (struct _Unwind_Context *, _Unwind_Ptr);
+
+
+extern _Unwind_Word _Unwind_GetCFA (struct _Unwind_Context *);
+
+extern void *_Unwind_GetLanguageSpecificData (struct _Unwind_Context *);
+
+extern _Unwind_Ptr _Unwind_GetRegionStart (struct _Unwind_Context *);
+# 175 "/usr/lib/gcc-lib/i386-redhat-linux/3.3.3/include/unwind.h" 3 4
+typedef _Unwind_Reason_Code (*_Unwind_Personality_Fn)
+     (int, _Unwind_Action, _Unwind_Exception_Class,
+      struct _Unwind_Exception *, struct _Unwind_Context *);
+
+
+
+
+struct SjLj_Function_Context;
+extern void _Unwind_SjLj_Register (struct SjLj_Function_Context *);
+extern void _Unwind_SjLj_Unregister (struct SjLj_Function_Context *);
+
+extern _Unwind_Reason_Code _Unwind_SjLj_RaiseException
+     (struct _Unwind_Exception *);
+extern _Unwind_Reason_Code _Unwind_SjLj_ForcedUnwind
+     (struct _Unwind_Exception *, _Unwind_Stop_Fn, void *);
+extern void _Unwind_SjLj_Resume (struct _Unwind_Exception *);
+extern _Unwind_Reason_Code _Unwind_SjLj_Resume_or_Rethrow (struct _Unwind_Exception *);
+# 217 "/usr/lib/gcc-lib/i386-redhat-linux/3.3.3/include/unwind.h" 3 4
+extern _Unwind_Ptr _Unwind_GetDataRelBase (struct _Unwind_Context *);
+extern _Unwind_Ptr _Unwind_GetTextRelBase (struct _Unwind_Context *);
+
+
+
+
+extern void * _Unwind_FindEnclosingFunction (void *pc);
+
+
+}
+# 42 "lib/libstdc++-v3/libsupc++/unwind-cxx.h" 2
+
+namespace __cxxabiv1
+{
+
+
+
+
+
+struct __cxa_exception
+{
+
+  std::type_info *exceptionType;
+  void (*exceptionDestructor)(void *);
+
+
+
+  std::unexpected_handler unexpectedHandler;
+  std::terminate_handler terminateHandler;
+
+
+  __cxa_exception *nextException;
+
+
+
+  int handlerCount;
+
+
+
+  int handlerSwitchValue;
+  const unsigned char *actionRecord;
+  const unsigned char *languageSpecificData;
+  _Unwind_Ptr catchTemp;
+  void *adjustedPtr;
+
+
+  _Unwind_Exception unwindHeader;
+};
+
+
+struct __cxa_eh_globals
+{
+  __cxa_exception *caughtExceptions;
+  unsigned int uncaughtExceptions;
+};
+
+
+
+
+
+
+extern "C" __cxa_eh_globals *__cxa_get_globals () throw();
+extern "C" __cxa_eh_globals *__cxa_get_globals_fast () throw();
+
+
+extern "C" void *__cxa_allocate_exception(std::size_t thrown_size) throw();
+
+
+extern "C" void __cxa_free_exception(void *thrown_exception) throw();
+
+
+extern "C" void __cxa_throw (void *thrown_exception,
+                             std::type_info *tinfo,
+                             void (*dest) (void *))
+     __attribute__((noreturn));
+
+
+extern "C" void *__cxa_begin_catch (void *) throw();
+extern "C" void __cxa_end_catch ();
+extern "C" void __cxa_rethrow () __attribute__((noreturn));
+
+
+extern "C" void __cxa_bad_cast ();
+extern "C" void __cxa_bad_typeid ();
+
+
+
+
+
+
+extern "C" void __cxa_call_unexpected (void *) __attribute__((noreturn));
+
+
+
+extern void __terminate(std::terminate_handler) __attribute__((noreturn));
+extern void __unexpected(std::unexpected_handler) __attribute__((noreturn));
+
+
+extern std::terminate_handler __terminate_handler;
+extern std::unexpected_handler __unexpected_handler;
+
+
+
+
+const _Unwind_Exception_Class __gxx_exception_class
+= ((((((((_Unwind_Exception_Class) 'G'
+         << 8 | (_Unwind_Exception_Class) 'N')
+        << 8 | (_Unwind_Exception_Class) 'U')
+       << 8 | (_Unwind_Exception_Class) 'C')
+      << 8 | (_Unwind_Exception_Class) 'C')
+     << 8 | (_Unwind_Exception_Class) '+')
+    << 8 | (_Unwind_Exception_Class) '+')
+   << 8 | (_Unwind_Exception_Class) '\0');
+
+
+extern "C" _Unwind_Reason_Code __gxx_personality_v0
+     (int, _Unwind_Action, _Unwind_Exception_Class,
+      struct _Unwind_Exception *, struct _Unwind_Context *);
+
+
+extern "C" _Unwind_Reason_Code __gxx_personality_sj0
+     (int, _Unwind_Action, _Unwind_Exception_Class,
+      struct _Unwind_Exception *, struct _Unwind_Context *);
+
+
+static inline __attribute__((always_inline)) __cxa_exception *
+__get_exception_header_from_obj (void *ptr)
+{
+  return reinterpret_cast<__cxa_exception *>(ptr) - 1;
+}
+
+
+static inline __attribute__((always_inline)) __cxa_exception *
+__get_exception_header_from_ue (_Unwind_Exception *exc)
+{
+  return reinterpret_cast<__cxa_exception *>(exc + 1) - 1;
+}
+
+}
+# 38 "lib/libstdc++-v3/libsupc++/eh_alloc.cc" 2
+# 1 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/bits/c++config.h" 1
+# 39 "lib/libstdc++-v3/libsupc++/eh_alloc.cc" 2
+# 1 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/bits/gthr.h" 1
+# 13 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/bits/gthr.h"
+# 1 "include/c++/begin_include.h" 1
+# 17 "include/c++/begin_include.h"
+extern "C" {
+# 14 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/bits/gthr.h" 2
+
+# 1 "include/c++/end_include.h" 1
+# 21 "include/c++/end_include.h"
+}
+# 16 "/home/halldorisak/workspace/linux-2.6.9/linux-2.6.9/include/c++/bits/gthr.h" 2
+
+
+
+typedef spinlock_t __gthread_mutex_t;
+
+
+
+
+
+typedef struct {
+   spinlock_t lock;
+   volatile int initialized;
+} __gthread_once_t;
+
+
+
+
+extern "C"
+
+
+
+inline __attribute__((always_inline)) int __gthread_once(__gthread_once_t *once, void (*func) (void))
+{
+   if (!once->initialized) {
+      _spin_lock_irq(&once->lock);
+
+      if (!once->initialized) {
+         func();
+         once->initialized = 1;
+      }
+
+      _spin_unlock_irq(&once->lock);
+   }
+   return 0;
+}
+
+
+extern "C"
+
+
+
+inline __attribute__((always_inline)) int __gthread_active_p(void)
+{
+   return 1;
+}
+# 40 "lib/libstdc++-v3/libsupc++/eh_alloc.cc" 2
+
+using namespace __cxxabiv1;
+# 68 "lib/libstdc++-v3/libsupc++/eh_alloc.cc"
+typedef unsigned int bitmask_type;
+
+
+
+
+
+typedef char one_buffer[512] __attribute__((aligned));
+static one_buffer emergency_buffer[32];
+static bitmask_type emergency_used;
+
+
+
+
+static __gthread_mutex_t emergency_mutex =(spinlock_t) { 1 };
+# 96 "lib/libstdc++-v3/libsupc++/eh_alloc.cc"
+extern "C" void *
+__cxa_allocate_exception(std::size_t thrown_size)
+{
+  void *ret;
+  thrown_size += sizeof (__cxa_exception);
+  ret = std::cxx_malloc (thrown_size);
+
+  if (! ret)
+    {
+
+
+
+
+
+      _spin_lock_irq(&emergency_mutex);
+
+
+      bitmask_type used = emergency_used;
+      unsigned int which = 0;
+
+      if (thrown_size > 512)
+        goto failed;
+      while (used & 1)
+        {
+          used >>= 1;
+          if (++which >= 32)
+            goto failed;
+        }
+
+      emergency_used |= (bitmask_type)1 << which;
+      ret = &emergency_buffer[which][0];
+
+    failed:;
+
+      _spin_unlock_irq(&emergency_mutex);
+
+      if (!ret)
+        std::terminate ();
+    }
+
+  std::cxx_memset (ret, 0, sizeof (__cxa_exception));
+
+  return (void *)((char *)ret + sizeof (__cxa_exception));
+}
+
+
+extern "C" void
+__cxa_free_exception(void *vptr)
+{
+  char *ptr = (char *) vptr;
+  if (ptr >= &emergency_buffer[0][0]
+      && ptr < &emergency_buffer[0][0] + sizeof (emergency_buffer))
+    {
+      unsigned int which
+        = (unsigned)(ptr - &emergency_buffer[0][0]) / 512;
+
+
+      _spin_lock_irq(&emergency_mutex);
+      emergency_used &= ~((bitmask_type)1 << which);
+      _spin_unlock_irq(&emergency_mutex);
+
+
+
+    }
+  else
+    std::cxx_free (ptr - sizeof (__cxa_exception));
+}
